(dlv) p tmpObjectPrefix
".gcsfuse_tmp/"
(dlv) frame 0
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(351):1 total:4) (PC: 0x18c1f48)
Frame 0: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (PC: 18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
Values returned:
        listing: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc0007a7dc0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 0, cap: 0, nil,
                CollapsedRuns: []string len: 0, cap: 0, nil,
                ContinuationToken: "",}
        err: error nil

   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ListPrefix() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/list_prefix.go:39 (PC: 0xfff892)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc0007a7dc0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 0, cap: 0, nil,
                CollapsedRuns: []string len: 0, cap: 0, nil,
                ContinuationToken: "",}
        ~r1: error nil

    19:
    20:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs"
    21:         "golang.org/x/net/context"
    22: )
    23:
    24: // List objects in the supplied bucket whose name starts with the given prefix.
    25: // Write them into the supplied channel in an undefined order.
    26: func ListPrefix(
    27:         ctx context.Context,
    28:         bucket gcs.Bucket,
    29:         prefix string,
    30:         objects chan<- *gcs.Object) (err error) {
    31:         req := &gcs.ListObjectsRequest{
    32:                 Prefix: prefix,
    33:         }
    34:
    35:         // List until we run out.
    36:         for {
    37:                 // Fetch the next batch.
    38:                 var listing *gcs.Listing
=>  39:                 listing, err = bucket.ListObjects(ctx, req)
    40:                 if err != nil {
    41:                         err = fmt.Errorf("ListObjects: %v", err)
    42:                         return
    43:                 }
    44:
    45:                 // Pass on each object.
    46:                 for _, o := range listing.Objects {
    47:                         select {
    48:                         case objects <- o:
    49:
    50:                                 // Cancelled?
    51:                         case <-ctx.Done():
    52:                                 err = ctx.Err()
    53:                                 return
    54:                         }
    55:                 }
    56:
    57:                 // Are we done?
    58:                 if listing.ContinuationToken == "" {
    59:                         break
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.garbageCollectOnce.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/gcsx/garbage_collect.go:41 (PC: 0x18fed76)
Values returned:
        err: error nil

    21:
    22:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs"
    23:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil"
    24:         "golang.org/x/net/context"
    25:
    26:         "github.com/googlecloudplatform/gcsfuse/v2/internal/logger"
    27:         "github.com/jacobsa/syncutil"
    28: )
    29:
    30: func garbageCollectOnce(
    31:         ctx context.Context,
    32:         tmpObjectPrefix string,
    33:         bucket gcs.Bucket) (objectsDeleted uint64, err error) {
    34:         const stalenessThreshold = 30 * time.Minute
    35:         b := syncutil.NewBundle(ctx)
    36:
    37:         // List all objects with the temporary prefix.
    38:         objects := make(chan *gcs.Object, 100)
    39:         b.Add(func(ctx context.Context) (err error) {
    40:                 defer close(objects)
=>  41:                 err = storageutil.ListPrefix(ctx, bucket, tmpObjectPrefix, objects)
    42:                 if err != nil {
    43:                         err = fmt.Errorf("ListPrefix: %w", err)
    44:                         return
    45:                 }
    46:
    47:                 return
    48:         })
    49:
    50:         // Filter to the names of objects that are stale.
    51:         now := time.Now()
    52:         staleNames := make(chan string, 100)
    53:         b.Add(func(ctx context.Context) (err error) {
    54:                 defer close(staleNames)
    55:                 for o := range objects {
    56:                         if now.Sub(o.Updated) < stalenessThreshold {
    57:                                 continue
    58:                         }
    59:
    60:                         select {
    61:                         case <-ctx.Done():
(dlv) 
> github.com/jacobsa/syncutil.(*Bundle).Add.func1() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89 (PC: 0xed4a31)
Values returned:
        err: error nil

    69: type Bundle struct {
    70:         context context.Context
    71:         cancel  context.CancelFunc
    72:
    73:         waitGroup sync.WaitGroup
    74:
    75:         errorOnce  sync.Once
    76:         firstError error
    77: }
    78:
    79: // Add a new operation to the bundle. The operation will be invoked with a
    80: // context that will be cancelled if any other operation fails or has already
    81: // failed.
    82: func (b *Bundle) Add(f func(context.Context) error) {
    83:         b.waitGroup.Add(1)
    84:
    85:         // Run the function in the background.
    86:         go func() {
    87:                 defer b.waitGroup.Done()
    88:
=>  89:                 err := f(b.context)
    90:                 if err == nil {
    91:                         return
    92:                 }
    93:
    94:                 // On first error, cancel the context and save the error.
    95:                 b.errorOnce.Do(func() {
    96:                         b.firstError = err
    97:                         b.cancel()
    98:                 })
    99:         }()
   100: }
   101:
   102: // Wait for all previously-added operations to complete. Return nil if all
   103: // operations succeeded. Otherwise return the first error.
   104: //
   105: // Add must not be called concurrently with or after Join.
   106: func (b *Bundle) Join() error {
   107:         b.waitGroup.Wait()
   108:
   109:         // context.WithCancel requires that we arrange for this to be called
(dlv) 
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Values returned:

  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
  1695:         BYTE    $0x90   // NOP
=>1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
  1716: #ifndef GOOS_plan9
(dlv) c
received SIGINT, stopping process (will not forward signal)
> runtime.futex() /usr/lib/google-golang/src/runtime/sys_linux_amd64.s:559 (PC: 0x4835c3)
Warning: debugging optimized function
   539: TEXT runtime·madvise(SB),NOSPLIT,$0
   540:         MOVQ    addr+0(FP), DI
   541:         MOVQ    n+8(FP), SI
   542:         MOVL    flags+16(FP), DX
   543:         MOVQ    $SYS_madvise, AX
   544:         SYSCALL
   545:         MOVL    AX, ret+24(FP)
   546:         RET
   547:
   548: // int64 futex(int32 *uaddr, int32 op, int32 val,
   549: //      struct timespec *timeout, int32 *uaddr2, int32 val2);
   550: TEXT runtime·futex(SB),NOSPLIT,$0
   551:         MOVQ    addr+0(FP), DI
   552:         MOVL    op+8(FP), SI
   553:         MOVL    val+12(FP), DX
   554:         MOVQ    ts+16(FP), R10
   555:         MOVQ    addr2+24(FP), R8
   556:         MOVL    val3+32(FP), R9
   557:         MOVL    $SYS_futex, AX
   558:         SYSCALL
=> 559:         MOVL    AX, ret+40(FP)
   560:         RET
   561:
   562: // int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
   563: TEXT runtime·clone(SB),NOSPLIT|NOFRAME,$0
   564:         MOVL    flags+0(FP), DI
   565:         MOVQ    stk+8(FP), SI
   566:         MOVQ    $0, DX
   567:         MOVQ    $0, R10
   568:         MOVQ    $0, R8
   569:         // Copy mp, gp, fn off parent stack for use by child.
   570:         // Careful: Linux system call clobbers CX and R11.
   571:         MOVQ    mp+16(FP), R13
   572:         MOVQ    gp+24(FP), R9
   573:         MOVQ    fn+32(FP), R12
   574:         CMPQ    R13, $0    // m
   575:         JEQ     nog1
   576:         CMPQ    R9, $0    // g
   577:         JEQ     nog1
   578:         LEAQ    m_tls(R13), R8
   579: #ifdef GOOS_android
(dlv) r
Process restarted with PID 3669518
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446724,0x45f40e,0x446804 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (0)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (0)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (0)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (0)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (0)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (0)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (0)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (0)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (0)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (0)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (0)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (0)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (0)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (0)
(dlv) ^C
(dlv) r
Process restarted with PID 3672231
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446724,0x45f40e,0x446804 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (0)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (0)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (0)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (0)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (0)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (0)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (0)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (0)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (0)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (0)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (0)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (0)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (0)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (0)
(dlv) c
{"timestamp":{"seconds":1714798168,"nanos":752808526},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(1):1 total:1) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) toggle all
Command failed: no breakpoint with name all
(dlv) bp        
Breakpoint runtime-fatal-throw (enabled) at 0x446804,0x446724,0x45f40e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (0)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (0)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (0)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (1)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (0)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (0)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (0)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (0)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (0)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (0)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (0)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (0)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (0)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (0)
(dlv) toggle
Command failed: not enough arguments
(dlv) r
Process restarted with PID 3676879
(dlv) c
{"timestamp":{"seconds":1714798312,"nanos":488416112},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(1):1 total:1) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(1):1 total:1) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) display attrs 
Command failed: wrong arguments
(dlv) display attrs.Name
Command failed: wrong arguments
(dlv) display locals    
Command failed: wrong arguments
(dlv) help
The following commands are available:

Running the program:
    call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!)
    continue (alias: c) --------- Run until breakpoint or program termination.
    next (alias: n) ------------- Step over to next source line.
    rebuild --------------------- Rebuild the target executable and restarts it. It does not work if the executable was not built by delve.
    restart (alias: r) ---------- Restart process.
    step (alias: s) ------------- Single step through program.
    step-instruction (alias: si)  Single step a single cpu instruction.
    stepout (alias: so) --------- Step out of the current function.

Manipulating breakpoints:
    break (alias: b) ------- Sets a breakpoint.
    breakpoints (alias: bp)  Print out info for active breakpoints.
    clear ------------------ Deletes breakpoint.
    clearall --------------- Deletes multiple breakpoints.
    condition (alias: cond)  Set breakpoint condition.
    on --------------------- Executes a command when a breakpoint is hit.
    toggle ----------------- Toggles on or off a breakpoint.
    trace (alias: t) ------- Set tracepoint.
    watch ------------------ Set watchpoint.

Viewing program variables and memory:
    args ----------------- Print function arguments.
    display -------------- Print value of an expression every time the program stops.
    examinemem (alias: x)  Examine raw memory at the given address.
    locals --------------- Print local variables.
    print (alias: p) ----- Evaluate an expression.
    regs ----------------- Print contents of CPU registers.
    set ------------------ Changes the value of a variable.
    vars ----------------- Print package variables.
    whatis --------------- Prints type of an expression.

Listing and switching between threads and goroutines:
    goroutine (alias: gr) -- Shows or changes current goroutine
    goroutines (alias: grs)  List program goroutines.
    thread (alias: tr) ----- Switch to the specified thread.
    threads ---------------- Print out info for every traced thread.

Viewing the call stack and selecting frames:
    deferred --------- Executes command in the context of a deferred call.
    down ------------- Move the current frame down.
    frame ------------ Set the current frame, or execute command on a different frame.
    stack (alias: bt)  Print stack trace.
    up --------------- Move the current frame up.

Other commands:
    config --------------------- Changes configuration parameters.
    disassemble (alias: disass)  Disassembler.
    dump ----------------------- Creates a core dump from the current process state
    edit (alias: ed) ----------- Open where you are in $DELVE_EDITOR or $EDITOR
    exit (alias: quit | q) ----- Exit the debugger.
    funcs ---------------------- Print list of functions.
    help (alias: h) ------------ Prints the help message.
    libraries ------------------ List loaded dynamic libraries
    list (alias: ls | l) ------- Show source code.
    packages ------------------- Print list of packages.
    source --------------------- Executes a file containing a list of delve commands
    sources -------------------- Print list of source files.
    target --------------------- Manages child process debugging.
    transcript ----------------- Appends command output to a file.
    types ---------------------- Print list of types

Type help followed by a command for full documentation.
(dlv) display attrs 
Command failed: wrong arguments
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(1):1 total:1) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) p attrs.c
Command failed: attrs has no member c
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(145):1 total:1) (PC: 0x193b036)
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(145):1 total:1) (PC: 0x193866a)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(161):1 total:1) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(145):1 total:1) (PC: 0x1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(13):1 total:1) (PC: 0x1918397)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(14):1 total:1) (PC: 0x1918017)
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
=> 454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(14):1 total:1) (PC: 0x1916836)
   306:         // Suppress "not found" errors.
   307:         var gcsErr *gcs.NotFoundError
   308:         if errors.As(err, &gcsErr) {
   309:                 return nil, nil
   310:         }
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
=> 326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(14):1 total:1) (PC: 0x19169a5)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(14):1 total:2) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(145):1 total:1) (PC: 0x1917da2)
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
=> 488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(88):1 total:2) (PC: 0x193b036)
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(88):1 total:2) (PC: 0x193866a)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(88):1 total:2) (PC: 0x1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(69):1 total:2) (PC: 0x1918397)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(70):1 total:2) (PC: 0x1918017)
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
=> 454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(70):1 total:2) (PC: 0x1916836)
   306:         // Suppress "not found" errors.
   307:         var gcsErr *gcs.NotFoundError
   308:         if errors.As(err, &gcsErr) {
   309:                 return nil, nil
   310:         }
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
=> 326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(70):1 total:2) (PC: 0x19169a5)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(70):1 total:3) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(88):1 total:2) (PC: 0x1917da2)
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
=> 488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(16):1 total:3) (PC: 0x193b036)
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(16):1 total:3) (PC: 0x193866a)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(16):1 total:3) (PC: 0x1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(72):1 total:3) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(71):1 total:3) (PC: 0x1918397)
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
=> 446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(72):1 total:3) (PC: 0x1916836)
   306:         // Suppress "not found" errors.
   307:         var gcsErr *gcs.NotFoundError
   308:         if errors.As(err, &gcsErr) {
   309:                 return nil, nil
   310:         }
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
=> 326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(72):1 total:3) (PC: 0x19169a5)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(72):1 total:4) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(16):1 total:3) (PC: 0x1917da2)
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
=> 488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(90):1 total:1) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(90):1 total:5) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(90):1 total:2) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(90):1 total:1) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(90):2 total:2) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(90):3 total:3) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(90):4 total:4) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(193):1 total:2) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(196):1 total:2) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(210):1 total:3) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(210):1 total:6) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(210):1 total:3) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(210):1 total:5) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(210):2 total:6) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(210):3 total:7) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(210):4 total:8) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(139):1 total:4) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(213):1 total:3) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(215):1 total:5) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(215):1 total:7) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(215):1 total:4) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(215):1 total:9) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(215):2 total:10) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(215):3 total:11) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(215):4 total:12) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(216):1 total:6) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(94):1 total:4) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(140):1 total:7) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(140):1 total:8) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(140):1 total:5) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(140):1 total:13) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(140):2 total:14) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(140):3 total:15) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(140):4 total:16) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(197):1 total:8) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(200):1 total:5) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(218):1 total:9) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(218):1 total:9) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(218):1 total:6) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(218):1 total:17) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(218):2 total:18) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(218):3 total:19) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(218):4 total:20) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(219):1 total:10) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(222):1 total:6) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(225):1 total:11) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(225):1 total:10) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(225):1 total:7) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(225):1 total:21) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(225):2 total:22) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(225):3 total:23) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(225):4 total:24) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(223):1 total:12) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(227):1 total:7) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(229):1 total:13) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(229):1 total:11) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(229):1 total:8) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(229):1 total:25) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(229):2 total:26) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(229):3 total:27) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(229):4 total:28) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(201):1 total:14) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(142):1 total:8) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(144):1 total:15) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(144):1 total:12) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(144):1 total:9) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(144):1 total:29) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(144):2 total:30) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(144):3 total:31) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(144):4 total:32) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(241):1 total:16) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(244):1 total:9) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(258):1 total:17) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(258):1 total:13) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(258):1 total:10) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(258):1 total:33) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(258):2 total:34) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(258):3 total:35) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(258):4 total:36) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(245):1 total:18) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(248):1 total:10) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(259):1 total:19) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(259):1 total:14) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(259):1 total:11) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(259):1 total:37) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(259):2 total:38) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(259):3 total:39) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(259):4 total:40) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(260):1 total:20) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(232):1 total:11) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(234):1 total:21) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(234):1 total:15) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(234):1 total:12) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(234):1 total:41) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(234):2 total:42) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(234):3 total:43) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(234):4 total:44) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(262):1 total:22) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(266):1 total:12) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(268):1 total:23) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(268):1 total:16) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(268):1 total:13) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(268):1 total:45) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(268):2 total:46) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(268):3 total:47) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(268):4 total:48) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(235):1 total:24) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(253):1 total:13) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(255):1 total:25) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(255):1 total:17) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(255):1 total:14) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(255):1 total:49) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(255):2 total:50) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(255):3 total:51) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(255):4 total:52) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(73):1 total:26) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(271):1 total:14) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(74):1 total:27) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(74):1 total:18) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(74):1 total:15) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(74):1 total:53) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(74):2 total:54) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(74):3 total:55) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(74):4 total:56) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(273):1 total:28) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(76):1 total:15) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(204):1 total:29) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(204):1 total:19) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(204):1 total:16) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(204):1 total:57) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(204):2 total:58) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(204):3 total:59) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(204):4 total:60) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(205):1 total:30) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(79):1 total:16) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(289):1 total:31) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(289):1 total:20) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(289):1 total:17) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(289):1 total:61) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(289):2 total:62) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(289):3 total:63) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(289):4 total:64) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(290):1 total:32) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(277):1 total:17) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(305):1 total:33) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(305):1 total:21) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(305):1 total:18) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(305):1 total:65) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(305):2 total:66) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(305):3 total:67) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(305):4 total:68) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(278):1 total:34) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(238):1 total:18) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(307):1 total:35) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(307):1 total:22) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(307):1 total:19) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(307):1 total:69) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(307):2 total:70) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(307):3 total:71) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(307):4 total:72) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(308):1 total:36) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(281):1 total:19) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(283):1 total:37) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(283):1 total:23) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(283):1 total:20) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(283):1 total:73) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(283):2 total:74) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(283):3 total:75) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(283):4 total:76) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(239):1 total:38) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(322):1 total:20) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(310):1 total:39) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(310):1 total:24) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(310):1 total:21) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(310):1 total:77) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(310):2 total:78) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(310):3 total:79) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(310):4 total:80) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(311):1 total:40) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(286):1 total:21) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(288):1 total:41) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(288):1 total:25) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(288):1 total:22) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(288):1 total:81) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(288):2 total:82) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(288):3 total:83) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(288):4 total:84) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(312):1 total:42) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(339):1 total:22) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(207):1 total:43) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(207):1 total:26) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(207):1 total:23) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(207):1 total:85) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(207):2 total:86) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(207):3 total:87) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(207):4 total:88) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(208):1 total:44) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(355):1 total:23) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(340):1 total:45) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(340):1 total:27) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(340):1 total:24) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(340):1 total:89) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(340):2 total:90) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(340):3 total:91) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(340):4 total:92) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(341):1 total:46) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(344):1 total:24) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(324):1 total:47) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(324):1 total:28) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(324):1 total:25) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(324):1 total:93) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(324):2 total:94) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(324):3 total:95) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(324):4 total:96) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(325):1 total:48) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(328):1 total:25) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(314):1 total:49) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(314):1 total:29) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(314):1 total:26) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(314):1 total:97) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(314):2 total:98) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(314):3 total:99) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(314):4 total:100) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(315):1 total:50) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(318):1 total:26) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(330):1 total:51) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(330):1 total:30) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(330):1 total:27) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(330):1 total:101) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(330):2 total:102) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(330):3 total:103) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(330):4 total:104) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(320):1 total:52) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(359):1 total:4) (PC: 0x193b036)
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(359):1 total:4) (PC: 0x193866a)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(359):1 total:4) (PC: 0x1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(332):1 total:4) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(331):1 total:4) (PC: 0x1918397)
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
=> 446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(332):1 total:4) (PC: 0x1916836)
   306:         // Suppress "not found" errors.
   307:         var gcsErr *gcs.NotFoundError
   308:         if errors.As(err, &gcsErr) {
   309:                 return nil, nil
   310:         }
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
=> 326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(332):1 total:4) (PC: 0x19169a5)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(332):1 total:31) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(359):1 total:4) (PC: 0x1917da2)
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
=> 488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(346):1 total:5) (PC: 0x193b036)
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(346):1 total:5) (PC: 0x193866a)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(346):1 total:5) (PC: 0x1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) bt
0  0x0000000001917596 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437
1  0x00000000019386b4 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929
2  0x0000000001938154 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:937
3  0x000000000193b23f in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330
4  0x000000000192a1a6 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126
5  0x000000000192edab in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156
6  0x0000000001911d44 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144
7  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
8  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) frame 4
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(346):1 total:5) (PC: 0x1917596)
Frame 4: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126 (PC: 192a1a6)
   106: func (em *errorMapping) Destroy() {
   107:         defer em.handlePanic()
   108:
   109:         em.wrapped.Destroy()
   110: }
   111:
   112: func (em *errorMapping) StatFS(
   113:         ctx context.Context,
   114:         op *fuseops.StatFSOp) error {
   115:         defer em.handlePanic()
   116:
   117:         err := em.wrapped.StatFS(ctx, op)
   118:         return em.mapError("StatFS", err)
   119: }
   120:
   121: func (em *errorMapping) LookUpInode(
   122:         ctx context.Context,
   123:         op *fuseops.LookUpInodeOp) error {
   124:         defer em.handlePanic()
   125:
=> 126:         err := em.wrapped.LookUpInode(ctx, op)
   127:         return em.mapError("LookUpInode", err)
   128: }
   129:
   130: func (em *errorMapping) GetInodeAttributes(
   131:         ctx context.Context,
   132:         op *fuseops.GetInodeAttributesOp) error {
   133:         defer em.handlePanic()
   134:
   135:         err := em.wrapped.GetInodeAttributes(ctx, op)
   136:         return em.mapError("GetInodeAttributes", err)
   137: }
   138:
   139: func (em *errorMapping) SetInodeAttributes(
   140:         ctx context.Context,
   141:         op *fuseops.SetInodeAttributesOp) error {
   142:         defer em.handlePanic()
   143:
   144:         err := em.wrapped.SetInodeAttributes(ctx, op)
   145:         return em.mapError("SetInodeAttributes", err)
   146: }
(dlv) frame 5
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(346):1 total:5) (PC: 0x1917596)
Frame 5: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156 (PC: 192edab)
   136:         wrapped fuseutil.FileSystem
   137: }
   138:
   139: func (fs *monitoring) Destroy() {
   140:         fs.wrapped.Destroy()
   141: }
   142:
   143: func (fs *monitoring) StatFS(
   144:         ctx context.Context,
   145:         op *fuseops.StatFSOp) error {
   146:         startTime := time.Now()
   147:         err := fs.wrapped.StatFS(ctx, op)
   148:         recordOp(ctx, "StatFS", startTime, err)
   149:         return err
   150: }
   151:
   152: func (fs *monitoring) LookUpInode(
   153:         ctx context.Context,
   154:         op *fuseops.LookUpInodeOp) error {
   155:         startTime := time.Now()
=> 156:         err := fs.wrapped.LookUpInode(ctx, op)
   157:         recordOp(ctx, "LookUpInode", startTime, err)
   158:         return err
   159: }
   160:
   161: func (fs *monitoring) GetInodeAttributes(
   162:         ctx context.Context,
   163:         op *fuseops.GetInodeAttributesOp) error {
   164:         startTime := time.Now()
   165:         err := fs.wrapped.GetInodeAttributes(ctx, op)
   166:         recordOp(ctx, "GetInodeAttributes", startTime, err)
   167:         return err
   168: }
   169:
   170: func (fs *monitoring) SetInodeAttributes(
   171:         ctx context.Context,
   172:         op *fuseops.SetInodeAttributesOp) error {
   173:         startTime := time.Now()
   174:         err := fs.wrapped.SetInodeAttributes(ctx, op)
   175:         recordOp(ctx, "SetInodeAttributes", startTime, err)
   176:         return err
(dlv) frame 3
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(346):1 total:5) (PC: 0x1917596)
Frame 3: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330 (PC: 193b23f)
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
=>1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
(dlv) frame 2
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(346):1 total:5) (PC: 0x1917596)
Frame 2: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:937 (PC: 1938154)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
=> 937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
(dlv) frame 1
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(346):1 total:5) (PC: 0x1917596)
Frame 1: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (PC: 19386b4)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) frame 0
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(346):1 total:5) (PC: 0x1917596)
Frame 0: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (PC: 1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:439 (PC: 0x19175d4)
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
=> 439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:443 (PC: 0x19176c4)
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
=> 443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:444 (PC: 0x19176fa)
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
=> 444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:445 (PC: 0x1917731)
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
=> 445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446724,0x446804,0x45f40e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (5)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (52)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (26)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (31)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (104)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (27)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (4)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (4)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (5)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (5)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (4)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (4)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (4)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (0)
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:445 (PC: 0x1917731)
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
=> 445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x45f40e,0x446724,0x446804 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (5)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (52)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (26)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (31)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (104)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (27)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (4)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (4)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (5)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (5)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (4)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (4)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (4)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (0)
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:445 (PC: 0x1917731)
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
=> 445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:449 (PC: 0x191780d)
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
=> 449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:453 (PC: 0x19178e8)
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
=> 453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:458 (PC: 0x19179c5)
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
=> 458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:460 (PC: 0x19179e2)
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
=> 460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:461 (PC: 0x1917a68)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
=> 461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:470 (PC: 0x1917a71)
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
=> 470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:474 (PC: 0x1917a78)
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
=> 474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:475 (PC: 0x1917a82)
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
=> 475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:476 (PC: 0x1917a97)
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
=> 476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(347):1 total:5) (PC: 0x1918397)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:477 (PC: 0x1917aa9)
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
=> 477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(348):1 total:5) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:476 (PC: 0x1917ad4)
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
=> 476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(348):1 total:5) (PC: 0x1916836)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:483 (PC: 0x1917d44)
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
=> 483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(348):1 total:5) (PC: 0x19169a5)
        breakpoint hit during next
[c] continue [s] stop here and cancel next, [f] finish next skipping all breakpoints? c
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(348):1 total:32) (PC: 0x18c1f48)
        breakpoint hit during next
[c] continue [s] stop here and cancel next, [f] finish next skipping all breakpoints? c
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(348):1 total:28) (PC: 0x18c22cc)
        breakpoint hit during next
[c] continue [s] stop here and cancel next, [f] finish next skipping all breakpoints? s
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) p name
Command failed: could not find symbol value for name
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:285 (PC: 0x18c22e1)
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
=> 285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
(dlv) p attrs.Name
"a/../8"
(dlv) p attrs.Prefix
""
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x45f40e,0x446724,0x446804 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (5)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (52)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (26)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (32)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (104)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (28)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (5)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (5)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (5)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (5)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (5)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (5)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (4)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (0)
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:285 (PC: 0x18c22e1)
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
=> 285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000b0c3c0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "a/", Delimiter: "", IncludeTrailingDelimiter: false, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 1, ProjectionVal: Full (0)}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:296 (PC: 0x18c23c0)
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
=> 296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:300 (PC: 0x18c23c2)
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
=> 300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
(dlv) p list
github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00036fa40),
        ],
        CollapsedRuns: []string len: 0, cap: 0, nil,
        ContinuationToken: "",}
(dlv) p list.Objects[0]
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00036fa40)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object {
        Name: "a/../8",
        ContentType: "text/plain",
        ContentLanguage: "",
        CacheControl: "",
        Owner: "",
        Size: 6,
        ContentEncoding: "",
        MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
        CRC32C: *893245630,
        MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+77 more",
        Metadata: map[string]string nil,
        Generation: 1714642897885179,
        MetaGeneration: 1,
        StorageClass: "STANDARD",
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(2024-05-02T09:41:37Z){
                wall: 887000000,
                ext: 63850239697,
                loc: *time.Location nil,},
        ComponentCount: 0,
        ContentDisposition: "",
        CustomTime: "0001-01-01T00:00:00Z",
        EventBasedHold: false,
        Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,}
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:300 (PC: 0x18c23c2)
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
=> 300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:301 (PC: 0x18c240c)
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
=> 301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
   321:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:302 (PC: 0x18c2419)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
=> 302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
   321:
   322:         if req.ContentEncoding != nil {
(dlv) p listing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000b8e040)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00036fa40),
        ],
        CollapsedRuns: []string len: 0, cap: 0, nil,
        ContinuationToken: "CgZhLy4uLzg=",}
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
Values returned:
        listing: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000b8e040)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00036fa40),
                ],
                CollapsedRuns: []string len: 0, cap: 0, nil,
                ContinuationToken: "CgZhLy4uLzg=",}
        err: error nil

   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (PC: 0x19169e8)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000b8e040)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00036fa40),
                ],
                CollapsedRuns: []string len: 0, cap: 0, nil,
                ContinuationToken: "CgZhLy4uLzg=",}
        ~r1: error nil

   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:336 (PC: 0x1916a57)
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
=> 336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:340 (PC: 0x1916b8c)
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
=> 340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916bc8)
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
=> 344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
(dlv) p name
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"}
(dlv) bt
0  0x0000000001916bc8 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344
1  0x00000000019180cc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454
2  0x0000000000ed4a31 in github.com/jacobsa/syncutil.(*Bundle).Add.func1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89
3  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) frame 1
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916bc8)
Frame 1: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (PC: 19180cc)
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
=> 454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
(dlv) frame 2
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916bc8)
Frame 2: /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89 (PC: ed4a31)
    69: type Bundle struct {
    70:         context context.Context
    71:         cancel  context.CancelFunc
    72:
    73:         waitGroup sync.WaitGroup
    74:
    75:         errorOnce  sync.Once
    76:         firstError error
    77: }
    78:
    79: // Add a new operation to the bundle. The operation will be invoked with a
    80: // context that will be cancelled if any other operation fails or has already
    81: // failed.
    82: func (b *Bundle) Add(f func(context.Context) error) {
    83:         b.waitGroup.Add(1)
    84:
    85:         // Run the function in the background.
    86:         go func() {
    87:                 defer b.waitGroup.Done()
    88:
=>  89:                 err := f(b.context)
    90:                 if err == nil {
    91:                         return
    92:                 }
    93:
    94:                 // On first error, cancel the context and save the error.
    95:                 b.errorOnce.Do(func() {
    96:                         b.firstError = err
    97:                         b.cancel()
    98:                 })
    99:         }()
   100: }
   101:
   102: // Wait for all previously-added operations to complete. Return nil if all
   103: // operations succeeded. Otherwise return the first error.
   104: //
   105: // Add must not be called concurrently with or after Join.
   106: func (b *Bundle) Join() error {
   107:         b.waitGroup.Wait()
   108:
   109:         // context.WithCancel requires that we arrange for this to be called
(dlv) frame 3
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916bc8)
Frame 3: /usr/lib/google-golang/src/runtime/asm_amd64.s:1695 (PC: 4817c1)
  1675: GLOBL shifts<>(SB),RODATA,$256
  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
=>1695:         BYTE    $0x90   // NOP
  1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
(dlv) frame 0
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916bc8)
Frame 0: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 1916bc8)
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
=> 344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:345 (PC: 0x1916c2c)
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
=> 345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(417):1 total:33) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916c58)
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
=> 344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:346 (PC: 0x1916c62)
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
=> 346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
   366:                 Metadata:               metadata,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916cbb)
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
=> 344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:348 (PC: 0x1916cc8)
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
=> 348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
   366:                 Metadata:               metadata,
   367:         }
   368:
(dlv) p result
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000b16000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:351 (PC: 0x1916da4)
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
=> 351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
   366:                 Metadata:               metadata,
   367:         }
   368:
   369:         o, err = d.bucket.CreateObject(ctx, createReq)
   370:         if err != nil {
   371:                 return
(dlv) p o
Command failed: could not find symbol value for o
(dlv) p result.MinObject
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil
(dlv) p listing.Objects
[]*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
        *{
                Name: "a/../8",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+77 more",
                Metadata: map[string]string nil,
                Generation: 1714642897885179,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc00036faf0),
                Updated: (*time.Time)(0xc00036fb08),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
]
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:351 (PC: 0x1916da4)
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
=> 351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
   366:                 Metadata:               metadata,
   367:         }
   368:
   369:         o, err = d.bucket.CreateObject(ctx, createReq)
   370:         if err != nil {
   371:                 return
(dlv) call 349 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:351 (PC: 0x1916da4)
Command failed: function calls not supported by this version of Go
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (PC: 0x19180cc)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000b16000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
                FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
                Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                        Bucket: (unreadable invalid interface type),
                        Syncer: (unreadable invalid interface type),},
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}
        ~r1: error nil

   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
=> 454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:455 (PC: 0x191814e)
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
=> 455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
(dlv) p dirResult
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000b16000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) n
> github.com/jacobsa/syncutil.(*Bundle).Add.func1() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89 (PC: 0xed4a31)
Values returned:
        err: error nil

    69: type Bundle struct {
    70:         context context.Context
    71:         cancel  context.CancelFunc
    72:
    73:         waitGroup sync.WaitGroup
    74:
    75:         errorOnce  sync.Once
    76:         firstError error
    77: }
    78:
    79: // Add a new operation to the bundle. The operation will be invoked with a
    80: // context that will be cancelled if any other operation fails or has already
    81: // failed.
    82: func (b *Bundle) Add(f func(context.Context) error) {
    83:         b.waitGroup.Add(1)
    84:
    85:         // Run the function in the background.
    86:         go func() {
    87:                 defer b.waitGroup.Done()
    88:
=>  89:                 err := f(b.context)
    90:                 if err == nil {
    91:                         return
    92:                 }
    93:
    94:                 // On first error, cancel the context and save the error.
    95:                 b.errorOnce.Do(func() {
    96:                         b.firstError = err
    97:                         b.cancel()
    98:                 })
    99:         }()
   100: }
   101:
   102: // Wait for all previously-added operations to complete. Return nil if all
   103: // operations succeeded. Otherwise return the first error.
   104: //
   105: // Add must not be called concurrently with or after Join.
   106: func (b *Bundle) Join() error {
   107:         b.waitGroup.Wait()
   108:
   109:         // context.WithCancel requires that we arrange for this to be called
(dlv) n
> github.com/jacobsa/syncutil.(*Bundle).Add.func1() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:90 (PC: 0xed4a40)
    70:         context context.Context
    71:         cancel  context.CancelFunc
    72:
    73:         waitGroup sync.WaitGroup
    74:
    75:         errorOnce  sync.Once
    76:         firstError error
    77: }
    78:
    79: // Add a new operation to the bundle. The operation will be invoked with a
    80: // context that will be cancelled if any other operation fails or has already
    81: // failed.
    82: func (b *Bundle) Add(f func(context.Context) error) {
    83:         b.waitGroup.Add(1)
    84:
    85:         // Run the function in the background.
    86:         go func() {
    87:                 defer b.waitGroup.Done()
    88:
    89:                 err := f(b.context)
=>  90:                 if err == nil {
    91:                         return
    92:                 }
    93:
    94:                 // On first error, cancel the context and save the error.
    95:                 b.errorOnce.Do(func() {
    96:                         b.firstError = err
    97:                         b.cancel()
    98:                 })
    99:         }()
   100: }
   101:
   102: // Wait for all previously-added operations to complete. Return nil if all
   103: // operations succeeded. Otherwise return the first error.
   104: //
   105: // Add must not be called concurrently with or after Join.
   106: func (b *Bundle) Join() error {
   107:         b.waitGroup.Wait()
   108:
   109:         // context.WithCancel requires that we arrange for this to be called
   110:         // eventually in order to avoid leaking resources. Since everything is done,
(dlv) 
> github.com/jacobsa/syncutil.(*Bundle).Add.func1() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:91 (PC: 0xed4b00)
    71:         cancel  context.CancelFunc
    72:
    73:         waitGroup sync.WaitGroup
    74:
    75:         errorOnce  sync.Once
    76:         firstError error
    77: }
    78:
    79: // Add a new operation to the bundle. The operation will be invoked with a
    80: // context that will be cancelled if any other operation fails or has already
    81: // failed.
    82: func (b *Bundle) Add(f func(context.Context) error) {
    83:         b.waitGroup.Add(1)
    84:
    85:         // Run the function in the background.
    86:         go func() {
    87:                 defer b.waitGroup.Done()
    88:
    89:                 err := f(b.context)
    90:                 if err == nil {
=>  91:                         return
    92:                 }
    93:
    94:                 // On first error, cancel the context and save the error.
    95:                 b.errorOnce.Do(func() {
    96:                         b.firstError = err
    97:                         b.cancel()
    98:                 })
    99:         }()
   100: }
   101:
   102: // Wait for all previously-added operations to complete. Return nil if all
   103: // operations succeeded. Otherwise return the first error.
   104: //
   105: // Add must not be called concurrently with or after Join.
   106: func (b *Bundle) Join() error {
   107:         b.waitGroup.Wait()
   108:
   109:         // context.WithCancel requires that we arrange for this to be called
   110:         // eventually in order to avoid leaking resources. Since everything is done,
   111:         // to do so now is harmless.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(346):1 total:5) (PC: 0x1917da2)
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Values returned:

  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
  1695:         BYTE    $0x90   // NOP
=>1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
  1716: #ifndef GOOS_plan9
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(346):1 total:5) (PC: 0x1917da2)
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Command failed: nothing to stepout to
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(346):1 total:5) (PC: 0x1917da2)
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Command failed: nothing to stepout to
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(346):1 total:5) (PC: 0x1917da2)
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Command failed: nothing to stepout to
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(346):1 total:5) (PC: 0x1917da2)
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Command failed: nothing to stepout to
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (hits goroutine(346):1 total:1) (PC: 0x193b43f)
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
=>1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
(dlv) p child
(unreadable invalid interface type)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1339 (PC: 0x193b455)
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
=>1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1340 (PC: 0x193b482)
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
=>1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
(dlv) p e
("*github.com/jacobsa/fuse/fuseops.ChildInodeEntry")(0xc0008c11e8)
*github.com/jacobsa/fuse/fuseops.ChildInodeEntry {
        Child: 2,
        Generation: 0,
        Attributes: github.com/jacobsa/fuse/fuseops.InodeAttributes {
                Size: 0,
                Nlink: 0,
                Mode: 0,
                Rdev: 0,
                Atime: (*time.Time)(0xc0008c1210),
                Mtime: (*time.Time)(0xc0008c1228),
                Ctime: (*time.Time)(0xc0008c1240),
                Crtime: (*time.Time)(0xc0008c1258),
                Uid: 0,
                Gid: 0,},
        AttributesExpiration: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        EntryExpiration: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1342 (PC: 0x193b68c)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
=>1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
  1361:         fs.mu.Lock()
  1362:         in := fs.inodeOrDie(op.Inode)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1346 (PC: 0x193b6b1)
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
=>1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
  1361:         fs.mu.Lock()
  1362:         in := fs.inodeOrDie(op.Inode)
  1363:         fs.mu.Unlock()
  1364:
  1365:         in.Lock()
  1366:         defer in.Unlock()
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126 (PC: 0x192a1a6)
Values returned:
        err: error nil

   106: func (em *errorMapping) Destroy() {
   107:         defer em.handlePanic()
   108:
   109:         em.wrapped.Destroy()
   110: }
   111:
   112: func (em *errorMapping) StatFS(
   113:         ctx context.Context,
   114:         op *fuseops.StatFSOp) error {
   115:         defer em.handlePanic()
   116:
   117:         err := em.wrapped.StatFS(ctx, op)
   118:         return em.mapError("StatFS", err)
   119: }
   120:
   121: func (em *errorMapping) LookUpInode(
   122:         ctx context.Context,
   123:         op *fuseops.LookUpInodeOp) error {
   124:         defer em.handlePanic()
   125:
=> 126:         err := em.wrapped.LookUpInode(ctx, op)
   127:         return em.mapError("LookUpInode", err)
   128: }
   129:
   130: func (em *errorMapping) GetInodeAttributes(
   131:         ctx context.Context,
   132:         op *fuseops.GetInodeAttributesOp) error {
   133:         defer em.handlePanic()
   134:
   135:         err := em.wrapped.GetInodeAttributes(ctx, op)
   136:         return em.mapError("GetInodeAttributes", err)
   137: }
   138:
   139: func (em *errorMapping) SetInodeAttributes(
   140:         ctx context.Context,
   141:         op *fuseops.SetInodeAttributesOp) error {
   142:         defer em.handlePanic()
   143:
   144:         err := em.wrapped.SetInodeAttributes(ctx, op)
   145:         return em.mapError("SetInodeAttributes", err)
   146: }
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156 (PC: 0x192edab)
Values returned:
        ~r0: error nil

   136:         wrapped fuseutil.FileSystem
   137: }
   138:
   139: func (fs *monitoring) Destroy() {
   140:         fs.wrapped.Destroy()
   141: }
   142:
   143: func (fs *monitoring) StatFS(
   144:         ctx context.Context,
   145:         op *fuseops.StatFSOp) error {
   146:         startTime := time.Now()
   147:         err := fs.wrapped.StatFS(ctx, op)
   148:         recordOp(ctx, "StatFS", startTime, err)
   149:         return err
   150: }
   151:
   152: func (fs *monitoring) LookUpInode(
   153:         ctx context.Context,
   154:         op *fuseops.LookUpInodeOp) error {
   155:         startTime := time.Now()
=> 156:         err := fs.wrapped.LookUpInode(ctx, op)
   157:         recordOp(ctx, "LookUpInode", startTime, err)
   158:         return err
   159: }
   160:
   161: func (fs *monitoring) GetInodeAttributes(
   162:         ctx context.Context,
   163:         op *fuseops.GetInodeAttributesOp) error {
   164:         startTime := time.Now()
   165:         err := fs.wrapped.GetInodeAttributes(ctx, op)
   166:         recordOp(ctx, "GetInodeAttributes", startTime, err)
   167:         return err
   168: }
   169:
   170: func (fs *monitoring) SetInodeAttributes(
   171:         ctx context.Context,
   172:         op *fuseops.SetInodeAttributesOp) error {
   173:         startTime := time.Now()
   174:         err := fs.wrapped.SetInodeAttributes(ctx, op)
   175:         recordOp(ctx, "SetInodeAttributes", startTime, err)
   176:         return err
(dlv) so
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144 (PC: 0x1911d44)
Values returned:
        ~r0: error nil

   124:                 }
   125:         }
   126: }
   127:
   128: func (s *fileSystemServer) handleOp(
   129:         c *fuse.Connection,
   130:         ctx context.Context,
   131:         op interface{}) {
   132:         defer s.opsInFlight.Done()
   133:
   134:         // Dispatch to the appropriate method.
   135:         var err error
   136:         switch typed := op.(type) {
   137:         default:
   138:                 err = fuse.ENOSYS
   139:
   140:         case *fuseops.StatFSOp:
   141:                 err = s.fs.StatFS(ctx, typed)
   142:
   143:         case *fuseops.LookUpInodeOp:
=> 144:                 err = s.fs.LookUpInode(ctx, typed)
   145:
   146:         case *fuseops.GetInodeAttributesOp:
   147:                 err = s.fs.GetInodeAttributes(ctx, typed)
   148:
   149:         case *fuseops.SetInodeAttributesOp:
   150:                 err = s.fs.SetInodeAttributes(ctx, typed)
   151:
   152:         case *fuseops.ForgetInodeOp:
   153:                 err = s.fs.ForgetInode(ctx, typed)
   154:
   155:         case *fuseops.BatchForgetOp:
   156:                 err = s.fs.BatchForget(ctx, typed)
   157:                 if err == fuse.ENOSYS {
   158:                         // Handle as a series of single-inode forget operations
   159:                         for _, entry := range typed.Entries {
   160:                                 err = s.fs.ForgetInode(ctx, &fuseops.ForgetInodeOp{
   161:                                         Inode:     entry.Inode,
   162:                                         N:         entry.N,
   163:                                         OpContext: typed.OpContext,
   164:                                 })
(dlv) so
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Values returned:

  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
  1695:         BYTE    $0x90   // NOP
=>1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
  1716: #ifndef GOOS_plan9
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(112):1 total:6) (PC: 0x193b036)
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1317 (PC: 0x193b066)
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
=>1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1325 (PC: 0x193b172)
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
=>1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1326 (PC: 0x193b18f)
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
=>1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1327 (PC: 0x193b1c1)
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
=>1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330 (PC: 0x193b1de)
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
=>1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
(dlv) p op.Name
"a"
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:911 (PC: 0x1937f76)
   891:                 // Replace it with a newly-mintend inode and then go around, acquiring its
   892:                 // lock in accordance with our lock ordering rules.
   893:                 existingInode.Unlock()
   894:
   895:                 in = fs.mintInode(ic)
   896:                 fs.generationBackedInodes[in.Name()] = in.(inode.GenerationBackedInode)
   897:
   898:                 continue
   899:         }
   900: }
   901:
   902: // Look up the child with the given name within the parent, then return an
   903: // existing inode for that child or create a new one if necessary. Return
   904: // ENOENT if the child doesn't exist.
   905: //
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
=> 911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:916 (PC: 0x1937fc1)
   896:                 fs.generationBackedInodes[in.Name()] = in.(inode.GenerationBackedInode)
   897:
   898:                 continue
   899:         }
   900: }
   901:
   902: // Look up the child with the given name within the parent, then return an
   903: // existing inode for that child or create a new one if necessary. Return
   904: // ENOENT if the child doesn't exist.
   905: //
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
=> 916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
(dlv) p parent
(unreadable invalid interface type)
(dlv) p childName
"a"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:917 (PC: 0x1937ff8)
   897:
   898:                 continue
   899:         }
   900: }
   901:
   902: // Look up the child with the given name within the parent, then return an
   903: // existing inode for that child or create a new one if necessary. Return
   904: // ENOENT if the child doesn't exist.
   905: //
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
=> 917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
(dlv) p child
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Inode nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:926 (PC: 0x1938012)
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
=> 926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446724,0x446804,0x45f40e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (6)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (52)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (26)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (33)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (104)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (28)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (5)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (5)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (5)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (5)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (5)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (5)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (5)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (1)
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:926 (PC: 0x1938012)
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
=> 926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:934 (PC: 0x1938114)
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
=> 934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:936 (PC: 0x193812c)
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
=> 936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:937 (PC: 0x1938135)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
=> 937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:926 (PC: 0x1938556)
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
=> 926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:927 (PC: 0x19385ae)
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
=> 927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:928 (PC: 0x19385c3)
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
=> 928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(112):1 total:6) (PC: 0x193866a)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) p childName
"a"
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(112):1 total:6) (PC: 0x1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:439 (PC: 0x19175d4)
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
=> 439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:443 (PC: 0x19176c4)
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
=> 443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:444 (PC: 0x19176fa)
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
=> 444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:445 (PC: 0x1917731)
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
=> 445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:449 (PC: 0x191780d)
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
=> 449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:453 (PC: 0x19178e8)
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
=> 453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:458 (PC: 0x19179c5)
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
=> 458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:460 (PC: 0x19179e2)
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
=> 460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:461 (PC: 0x1917a68)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
=> 461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
(dlv) p cachedType
UnknownType (0)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:470 (PC: 0x1917a71)
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
=> 470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:474 (PC: 0x1917a78)
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
=> 474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:475 (PC: 0x1917a82)
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
=> 475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(386):1 total:6) (PC: 0x1918397)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:476 (PC: 0x1917a97)
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
=> 476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:477 (PC: 0x1917aa9)
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
=> 477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:476 (PC: 0x1917ad4)
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
=> 476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x45f40e,0x446724,0x446804 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (6)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (52)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (26)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (33)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (104)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (28)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (5)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (5)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (6)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (6)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (6)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (5)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (5)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (1)
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:476 (PC: 0x1917ad4)
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
=> 476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(387):1 total:6) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:483 (PC: 0x1917d44)
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
=> 483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
(dlv) b 494
Breakpoint 17 set at 0x1917dea for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(387):1 total:6) (PC: 0x1916836)
   306:         // Suppress "not found" errors.
   307:         var gcsErr *gcs.NotFoundError
   308:         if errors.As(err, &gcsErr) {
   309:                 return nil, nil
   310:         }
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
=> 326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:327 (PC: 0x1916884)
   307:         var gcsErr *gcs.NotFoundError
   308:         if errors.As(err, &gcsErr) {
   309:                 return nil, nil
   310:         }
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
=> 327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
(dlv) p name
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:332 (PC: 0x19168b6)
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
=> 332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:331 (PC: 0x19168eb)
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
=> 331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:332 (PC: 0x1916951)
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
=> 332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:331 (PC: 0x1916986)
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
=> 331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:333 (PC: 0x1916990)
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
=> 333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:331 (PC: 0x1916998)
   311:
   312:         // Annotate others.
   313:         if err != nil {
   314:                 return nil, fmt.Errorf("StatObject: %w", err)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
=> 331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(387):1 total:6) (PC: 0x19169a5)
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) p req 
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000c08000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "a/", Delimiter: "", IncludeTrailingDelimiter: false, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 1, ProjectionVal: Full (0)}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(387):1 total:34) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:261 (PC: 0x18c1f86)
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
=> 261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:264 (PC: 0x18c1fdb)
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
=> 264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c1fdd)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000c08000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "a/", Delimiter: "", IncludeTrailingDelimiter: false, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 1, ProjectionVal: Full (0)}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(387):1 total:29) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:285 (PC: 0x18c22e1)
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
=> 285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:296 (PC: 0x18c23c0)
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
=> 296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:300 (PC: 0x18c23c2)
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
=> 300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:301 (PC: 0x18c240c)
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
=> 301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
   321:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:302 (PC: 0x18c2419)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
=> 302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
   321:
   322:         if req.ContentEncoding != nil {
(dlv) p listing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000b8e040)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc0008ca140),
        ],
        CollapsedRuns: []string len: 0, cap: 0, nil,
        ContinuationToken: "CgZhLy4uLzg=",}
(dlv) p listing.Objects
[]*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
        *{
                Name: "a/../8",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+77 more",
                Metadata: map[string]string nil,
                Generation: 1714642897885179,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc0008ca1f0),
                Updated: (*time.Time)(0xc0008ca208),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
]
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
Values returned:
        listing: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000b8e040)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc0008ca140),
                ],
                CollapsedRuns: []string len: 0, cap: 0, nil,
                ContinuationToken: "CgZhLy4uLzg=",}
        err: error nil

   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (PC: 0x19169e8)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000b8e040)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc0008ca140),
                ],
                CollapsedRuns: []string len: 0, cap: 0, nil,
                ContinuationToken: "CgZhLy4uLzg=",}
        ~r1: error nil

   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:336 (PC: 0x1916a57)
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
=> 336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:340 (PC: 0x1916b8c)
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
=> 340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916bc8)
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
=> 344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:345 (PC: 0x1916c2c)
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
=> 345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916c58)
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
=> 344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:346 (PC: 0x1916c62)
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
=> 346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
   366:                 Metadata:               metadata,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:344 (PC: 0x1916cbb)
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
=> 344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:348 (PC: 0x1916cc8)
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
=> 348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
   366:                 Metadata:               metadata,
   367:         }
   368:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:351 (PC: 0x1916da4)
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
   335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
=> 351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
   356:         ctx context.Context,
   357:         name Name,
   358:         metadata map[string]string) (o *gcs.Object, err error) {
   359:         // Create an empty backing object for the child, failing if it already
   360:         // exists.
   361:         var precond int64
   362:         createReq := &gcs.CreateObjectRequest{
   363:                 Name:                   name.GcsObjectName(),
   364:                 Contents:               strings.NewReader(""),
   365:                 GenerationPrecondition: &precond,
   366:                 Metadata:               metadata,
   367:         }
   368:
   369:         o, err = d.bucket.CreateObject(ctx, createReq)
   370:         if err != nil {
   371:                 return
(dlv) p result
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000d9a540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (PC: 0x19180cc)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000d9a540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
                FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
                Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                        Bucket: (unreadable invalid interface type),
                        Syncer: (unreadable invalid interface type),},
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}
        ~r1: error nil

   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
=> 454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:455 (PC: 0x191814e)
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
=> 455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
(dlv) n
> github.com/jacobsa/syncutil.(*Bundle).Add.func1() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89 (PC: 0xed4a31)
Values returned:
        err: error nil

    69: type Bundle struct {
    70:         context context.Context
    71:         cancel  context.CancelFunc
    72:
    73:         waitGroup sync.WaitGroup
    74:
    75:         errorOnce  sync.Once
    76:         firstError error
    77: }
    78:
    79: // Add a new operation to the bundle. The operation will be invoked with a
    80: // context that will be cancelled if any other operation fails or has already
    81: // failed.
    82: func (b *Bundle) Add(f func(context.Context) error) {
    83:         b.waitGroup.Add(1)
    84:
    85:         // Run the function in the background.
    86:         go func() {
    87:                 defer b.waitGroup.Done()
    88:
=>  89:                 err := f(b.context)
    90:                 if err == nil {
    91:                         return
    92:                 }
    93:
    94:                 // On first error, cancel the context and save the error.
    95:                 b.errorOnce.Do(func() {
    96:                         b.firstError = err
    97:                         b.cancel()
    98:                 })
    99:         }()
   100: }
   101:
   102: // Wait for all previously-added operations to complete. Return nil if all
   103: // operations succeeded. Otherwise return the first error.
   104: //
   105: // Add must not be called concurrently with or after Join.
   106: func (b *Bundle) Join() error {
   107:         b.waitGroup.Wait()
   108:
   109:         // context.WithCancel requires that we arrange for this to be called
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(112):1 total:6) (PC: 0x1917da2)
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
=> 488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:489 (PC: 0x1917db2)
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
=> 489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
   509:                         Delimiter:         "", // recursively
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (hits goroutine(112):1 total:1) (PC: 0x1917dea)
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
=> 494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
   509:                         Delimiter:         "", // recursively
   510:                         Prefix:            d.Name().GcsObjectName(),
   511:                         ContinuationToken: tok,
   512:                         MaxResults:        limit + 1, // to exclude itself
   513:                 })
   514:                 if err != nil {
(dlv) p result
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000d9a540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:495 (PC: 0x1917df7)
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
=> 495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
   509:                         Delimiter:         "", // recursively
   510:                         Prefix:            d.Name().GcsObjectName(),
   511:                         ContinuationToken: tok,
   512:                         MaxResults:        limit + 1, // to exclude itself
   513:                 })
   514:                 if err != nil {
   515:                         return nil, fmt.Errorf("list objects: %w", err)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:500 (PC: 0x1917f55)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
=> 500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
   509:                         Delimiter:         "", // recursively
   510:                         Prefix:            d.Name().GcsObjectName(),
   511:                         ContinuationToken: tok,
   512:                         MaxResults:        limit + 1, // to exclude itself
   513:                 })
   514:                 if err != nil {
   515:                         return nil, fmt.Errorf("list objects: %w", err)
   516:                 }
   517:
   518:                 for _, o := range listing.Objects {
   519:                         if len(descendants) >= limit {
   520:                                 return descendants, nil
(dlv) p d.cache
(unreadable invalid interface type)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (PC: 0x19386b4)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000d9a540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
                FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
                Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                        Bucket: (unreadable invalid interface type),
                        Syncer: (unreadable invalid interface type),},
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}
        ~r1: error nil

   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:937 (PC: 0x1938154)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000d9a540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
                FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
                Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                        Bucket: (unreadable invalid interface type),
                        Syncer: (unreadable invalid interface type),},
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}
        ~r1: error nil

   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
=> 937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:939 (PC: 0x19381c0)
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
=> 939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
(dlv) p err
error nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:943 (PC: 0x19381da)
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
=> 943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
(dlv) p core
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000d9a540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) n 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:949 (PC: 0x19381e7)
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
=> 949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
   964: // LOCK_FUNCTION(child)
   965: func (fs *fileSystem) lookUpLocalFileInode(parent inode.DirInode, childName string) (child inode.Inode) {
   966:         defer func() {
   967:                 if child != nil {
   968:                         child.IncrementLookupCount()
   969:                 }
(dlv) p core
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000d9a540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:771 (PC: 0x1937116)
   751:                         ic.Local)
   752:         }
   753:
   754:         // Place it in our map of IDs to inodes.
   755:         fs.inodes[in.ID()] = in
   756:
   757:         return
   758: }
   759:
   760: // Attempt to find an inode for a backing object or an implicit directory.
   761: // Create an inode if (1) it has never yet existed, or (2) the object is newer
   762: // than the existing one.
   763: //
   764: // If the backing object is older than the existing inode, return nil. In this
   765: // case, the caller may obtain a fresh record and try again. Otherwise,
   766: // increment the inode's lookup count and return it locked.
   767: //
   768: // LOCKS_EXCLUDED(fs.mu)
   769: // UNLOCK_FUNCTION(fs.mu)
   770: // LOCK_FUNCTION(in)
=> 771: func (fs *fileSystem) lookUpOrCreateInodeIfNotStale(ic inode.Core) (in inode.Inode) {
   772:
   773:         // Sanity check.
   774:         if err := ic.SanityCheck(); err != nil {
   775:                 panic(err.Error())
   776:         }
   777:
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:774 (PC: 0x1937166)
   754:         // Place it in our map of IDs to inodes.
   755:         fs.inodes[in.ID()] = in
   756:
   757:         return
   758: }
   759:
   760: // Attempt to find an inode for a backing object or an implicit directory.
   761: // Create an inode if (1) it has never yet existed, or (2) the object is newer
   762: // than the existing one.
   763: //
   764: // If the backing object is older than the existing inode, return nil. In this
   765: // case, the caller may obtain a fresh record and try again. Otherwise,
   766: // increment the inode's lookup count and return it locked.
   767: //
   768: // LOCKS_EXCLUDED(fs.mu)
   769: // UNLOCK_FUNCTION(fs.mu)
   770: // LOCK_FUNCTION(in)
   771: func (fs *fileSystem) lookUpOrCreateInodeIfNotStale(ic inode.Core) (in inode.Inode) {
   772:
   773:         // Sanity check.
=> 774:         if err := ic.SanityCheck(); err != nil {
   775:                 panic(err.Error())
   776:         }
   777:
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:780 (PC: 0x19371c2)
   760: // Attempt to find an inode for a backing object or an implicit directory.
   761: // Create an inode if (1) it has never yet existed, or (2) the object is newer
   762: // than the existing one.
   763: //
   764: // If the backing object is older than the existing inode, return nil. In this
   765: // case, the caller may obtain a fresh record and try again. Otherwise,
   766: // increment the inode's lookup count and return it locked.
   767: //
   768: // LOCKS_EXCLUDED(fs.mu)
   769: // UNLOCK_FUNCTION(fs.mu)
   770: // LOCK_FUNCTION(in)
   771: func (fs *fileSystem) lookUpOrCreateInodeIfNotStale(ic inode.Core) (in inode.Inode) {
   772:
   773:         // Sanity check.
   774:         if err := ic.SanityCheck(); err != nil {
   775:                 panic(err.Error())
   776:         }
   777:
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
=> 780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:788 (PC: 0x1937274)
   768: // LOCKS_EXCLUDED(fs.mu)
   769: // UNLOCK_FUNCTION(fs.mu)
   770: // LOCK_FUNCTION(in)
   771: func (fs *fileSystem) lookUpOrCreateInodeIfNotStale(ic inode.Core) (in inode.Inode) {
   772:
   773:         // Sanity check.
   774:         if err := ic.SanityCheck(); err != nil {
   775:                 panic(err.Error())
   776:         }
   777:
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
=> 788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:791 (PC: 0x1937291)
   771: func (fs *fileSystem) lookUpOrCreateInodeIfNotStale(ic inode.Core) (in inode.Inode) {
   772:
   773:         // Sanity check.
   774:         if err := ic.SanityCheck(); err != nil {
   775:                 panic(err.Error())
   776:         }
   777:
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
=> 791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:792 (PC: 0x19372cf)
   772:
   773:         // Sanity check.
   774:         if err := ic.SanityCheck(); err != nil {
   775:                 panic(err.Error())
   776:         }
   777:
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
=> 792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
(dlv) p ic 
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:796 (PC: 0x1937305)
   776:         }
   777:
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
=> 796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
   814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:797 (PC: 0x193730a)
   777:
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
=> 797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
   814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:798 (PC: 0x1937313)
   778:         // Ensure that no matter which inode we return, we increase its lookup count
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
=> 798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
   814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
   818:                         // its means inode is in the process of getting destroyed. Try creating it
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:799 (PC: 0x193734f)
   779:         // on the way out and then release the file system lock.
   780:         defer func() {
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
=> 799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
   814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
   818:                         // its means inode is in the process of getting destroyed. Try creating it
   819:                         // again.
(dlv) p fs.implicitDirInodes
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.DirInode [
        {bucketName: "", objectName: ""}: (unreadable invalid interface type), 
        {bucketName: "", objectName: "a/"}: (unreadable invalid interface type), 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(456):1 total:35) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:801 (PC: 0x1937446)
   781:                 if in != nil {
   782:                         in.IncrementLookupCount()
   783:                 }
   784:
   785:                 fs.mu.Unlock()
   786:         }()
   787:
   788:         fs.mu.Lock()
   789:
   790:         // Handle implicit directories.
   791:         if ic.MinObject == nil {
   792:                 if !ic.FullName.IsDir() {
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
=> 801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
   814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
   818:                         // its means inode is in the process of getting destroyed. Try creating it
   819:                         // again.
   820:                         if fs.implicitDirInodes[ic.FullName] != in {
   821:                                 in.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:813 (PC: 0x193744d)
   793:                         panic(fmt.Sprintf("Unexpected name for an implicit directory: %q", ic.FullName))
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
=> 813:                         fs.mu.Unlock()
   814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
   818:                         // its means inode is in the process of getting destroyed. Try creating it
   819:                         // again.
   820:                         if fs.implicitDirInodes[ic.FullName] != in {
   821:                                 in.Unlock()
   822:                                 continue
   823:                         }
   824:
   825:                         return
   826:                 }
   827:
   828:                 // Incase we exhausted the number of tries to createInode, we will return
   829:                 // nil object. Returning nil is handled by callers to throw appropriate
   830:                 // errors back to kernel.
   831:                 in = nil
   832:                 return
   833:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:814 (PC: 0x193746a)
   794:                 }
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
=> 814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
   818:                         // its means inode is in the process of getting destroyed. Try creating it
   819:                         // again.
   820:                         if fs.implicitDirInodes[ic.FullName] != in {
   821:                                 in.Unlock()
   822:                                 continue
   823:                         }
   824:
   825:                         return
   826:                 }
   827:
   828:                 // Incase we exhausted the number of tries to createInode, we will return
   829:                 // nil object. Returning nil is handled by callers to throw appropriate
   830:                 // errors back to kernel.
   831:                 in = nil
   832:                 return
   833:         }
   834:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:815 (PC: 0x1937482)
   795:
   796:                 var ok bool
   797:                 var maxTriesToCreateInode = 3
   798:                 for n := 0; n < maxTriesToCreateInode; n++ {
   799:                         in, ok = fs.implicitDirInodes[ic.FullName]
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
   814:                         in.Lock()
=> 815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
   818:                         // its means inode is in the process of getting destroyed. Try creating it
   819:                         // again.
   820:                         if fs.implicitDirInodes[ic.FullName] != in {
   821:                                 in.Unlock()
   822:                                 continue
   823:                         }
   824:
   825:                         return
   826:                 }
   827:
   828:                 // Incase we exhausted the number of tries to createInode, we will return
   829:                 // nil object. Returning nil is handled by callers to throw appropriate
   830:                 // errors back to kernel.
   831:                 in = nil
   832:                 return
   833:         }
   834:
   835:         oGen := inode.Generation{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:820 (PC: 0x193749f)
   800:                         // If we don't have an entry, create one.
   801:                         if !ok {
   802:                                 in = fs.mintInode(ic)
   803:                                 fs.implicitDirInodes[in.Name()] = in.(inode.DirInode)
   804:                                 // Since we are creating inode here, there is no chance that something else
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
   814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
   818:                         // its means inode is in the process of getting destroyed. Try creating it
   819:                         // again.
=> 820:                         if fs.implicitDirInodes[ic.FullName] != in {
   821:                                 in.Unlock()
   822:                                 continue
   823:                         }
   824:
   825:                         return
   826:                 }
   827:
   828:                 // Incase we exhausted the number of tries to createInode, we will return
   829:                 // nil object. Returning nil is handled by callers to throw appropriate
   830:                 // errors back to kernel.
   831:                 in = nil
   832:                 return
   833:         }
   834:
   835:         oGen := inode.Generation{
   836:                 Object:   ic.MinObject.Generation,
   837:                 Metadata: ic.MinObject.MetaGeneration,
   838:         }
   839:
   840:         // Retry loop for the stale index entry case below. On entry, we hold fs.mu
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateInodeIfNotStale() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:825 (PC: 0x1937560)
   805:                                 // is holding the lock for inode. Hence its safe to take lock on inode
   806:                                 // without releasing fs.mu.lock.
   807:                                 in.Lock()
   808:                                 return
   809:                         }
   810:
   811:                         // If the inode already exists, we need to follow the lock ordering rules
   812:                         // to get the lock. First get inode lock and then fs lock.
   813:                         fs.mu.Unlock()
   814:                         in.Lock()
   815:                         fs.mu.Lock()
   816:
   817:                         // Check if inode is still valid by the time we got the lock. If not,
   818:                         // its means inode is in the process of getting destroyed. Try creating it
   819:                         // again.
   820:                         if fs.implicitDirInodes[ic.FullName] != in {
   821:                                 in.Unlock()
   822:                                 continue
   823:                         }
   824:
=> 825:                         return
   826:                 }
   827:
   828:                 // Incase we exhausted the number of tries to createInode, we will return
   829:                 // nil object. Returning nil is handled by callers to throw appropriate
   830:                 // errors back to kernel.
   831:                 in = nil
   832:                 return
   833:         }
   834:
   835:         oGen := inode.Generation{
   836:                 Object:   ic.MinObject.Generation,
   837:                 Metadata: ic.MinObject.MetaGeneration,
   838:         }
   839:
   840:         // Retry loop for the stale index entry case below. On entry, we hold fs.mu
   841:         // but no inode lock.
   842:         for {
   843:                 // Look at the current index entry.
   844:                 existingInode, ok := fs.generationBackedInodes[ic.FullName]
   845:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:949 (PC: 0x1938265)
Values returned:
        in: (unreadable invalid interface type)

   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
=> 949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
   964: // LOCK_FUNCTION(child)
   965: func (fs *fileSystem) lookUpLocalFileInode(parent inode.DirInode, childName string) (child inode.Inode) {
   966:         defer func() {
   967:                 if child != nil {
   968:                         child.IncrementLookupCount()
   969:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:950 (PC: 0x193826f)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
=> 950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
   964: // LOCK_FUNCTION(child)
   965: func (fs *fileSystem) lookUpLocalFileInode(parent inode.DirInode, childName string) (child inode.Inode) {
   966:         defer func() {
   967:                 if child != nil {
   968:                         child.IncrementLookupCount()
   969:                 }
   970:                 fs.mu.Unlock()
(dlv) p f
Command failed: could not find symbol value for f
(dlv) p fs.implicitDirInodes
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.DirInode [
        {bucketName: "", objectName: ""}: (unreadable invalid interface type), 
        {bucketName: "", objectName: "a/"}: (unreadable invalid interface type), 
]
(dlv) bt
0  0x000000000193826f in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:950
1  0x000000000193b23f in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330
2  0x000000000192a1a6 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126
3  0x000000000192edab in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156
4  0x0000000001911d44 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144
5  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
6  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:951 (PC: 0x1938276)
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
=> 951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
   964: // LOCK_FUNCTION(child)
   965: func (fs *fileSystem) lookUpLocalFileInode(parent inode.DirInode, childName string) (child inode.Inode) {
   966:         defer func() {
   967:                 if child != nil {
   968:                         child.IncrementLookupCount()
   969:                 }
   970:                 fs.mu.Unlock()
   971:         }()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330 (PC: 0x193b23f)
Values returned:
        child: (unreadable invalid interface type)
        err: error nil

  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
=>1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1331 (PC: 0x193b2e0)
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
=>1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
(dlv) p err
error nil
(dlv) p child
(unreadable invalid interface type)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1335 (PC: 0x193b305)
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
=>1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (hits goroutine(112):1 total:2) (PC: 0x193b43f)
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
=>1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1339 (PC: 0x193b455)
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
=>1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1340 (PC: 0x193b482)
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
=>1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1342 (PC: 0x193b68c)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
=>1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
  1361:         fs.mu.Lock()
  1362:         in := fs.inodeOrDie(op.Inode)
(dlv) p err
error nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1346 (PC: 0x193b6b1)
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
=>1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
  1361:         fs.mu.Lock()
  1362:         in := fs.inodeOrDie(op.Inode)
  1363:         fs.mu.Unlock()
  1364:
  1365:         in.Lock()
  1366:         defer in.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126 (PC: 0x192a1a6)
Values returned:
        err: error nil

   106: func (em *errorMapping) Destroy() {
   107:         defer em.handlePanic()
   108:
   109:         em.wrapped.Destroy()
   110: }
   111:
   112: func (em *errorMapping) StatFS(
   113:         ctx context.Context,
   114:         op *fuseops.StatFSOp) error {
   115:         defer em.handlePanic()
   116:
   117:         err := em.wrapped.StatFS(ctx, op)
   118:         return em.mapError("StatFS", err)
   119: }
   120:
   121: func (em *errorMapping) LookUpInode(
   122:         ctx context.Context,
   123:         op *fuseops.LookUpInodeOp) error {
   124:         defer em.handlePanic()
   125:
=> 126:         err := em.wrapped.LookUpInode(ctx, op)
   127:         return em.mapError("LookUpInode", err)
   128: }
   129:
   130: func (em *errorMapping) GetInodeAttributes(
   131:         ctx context.Context,
   132:         op *fuseops.GetInodeAttributesOp) error {
   133:         defer em.handlePanic()
   134:
   135:         err := em.wrapped.GetInodeAttributes(ctx, op)
   136:         return em.mapError("GetInodeAttributes", err)
   137: }
   138:
   139: func (em *errorMapping) SetInodeAttributes(
   140:         ctx context.Context,
   141:         op *fuseops.SetInodeAttributesOp) error {
   142:         defer em.handlePanic()
   143:
   144:         err := em.wrapped.SetInodeAttributes(ctx, op)
   145:         return em.mapError("SetInodeAttributes", err)
   146: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:127 (PC: 0x192a1b0)
   107:         defer em.handlePanic()
   108:
   109:         em.wrapped.Destroy()
   110: }
   111:
   112: func (em *errorMapping) StatFS(
   113:         ctx context.Context,
   114:         op *fuseops.StatFSOp) error {
   115:         defer em.handlePanic()
   116:
   117:         err := em.wrapped.StatFS(ctx, op)
   118:         return em.mapError("StatFS", err)
   119: }
   120:
   121: func (em *errorMapping) LookUpInode(
   122:         ctx context.Context,
   123:         op *fuseops.LookUpInodeOp) error {
   124:         defer em.handlePanic()
   125:
   126:         err := em.wrapped.LookUpInode(ctx, op)
=> 127:         return em.mapError("LookUpInode", err)
   128: }
   129:
   130: func (em *errorMapping) GetInodeAttributes(
   131:         ctx context.Context,
   132:         op *fuseops.GetInodeAttributesOp) error {
   133:         defer em.handlePanic()
   134:
   135:         err := em.wrapped.GetInodeAttributes(ctx, op)
   136:         return em.mapError("GetInodeAttributes", err)
   137: }
   138:
   139: func (em *errorMapping) SetInodeAttributes(
   140:         ctx context.Context,
   141:         op *fuseops.SetInodeAttributesOp) error {
   142:         defer em.handlePanic()
   143:
   144:         err := em.wrapped.SetInodeAttributes(ctx, op)
   145:         return em.mapError("SetInodeAttributes", err)
   146: }
   147:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156 (PC: 0x192edab)
Values returned:
        ~r0: error nil

   136:         wrapped fuseutil.FileSystem
   137: }
   138:
   139: func (fs *monitoring) Destroy() {
   140:         fs.wrapped.Destroy()
   141: }
   142:
   143: func (fs *monitoring) StatFS(
   144:         ctx context.Context,
   145:         op *fuseops.StatFSOp) error {
   146:         startTime := time.Now()
   147:         err := fs.wrapped.StatFS(ctx, op)
   148:         recordOp(ctx, "StatFS", startTime, err)
   149:         return err
   150: }
   151:
   152: func (fs *monitoring) LookUpInode(
   153:         ctx context.Context,
   154:         op *fuseops.LookUpInodeOp) error {
   155:         startTime := time.Now()
=> 156:         err := fs.wrapped.LookUpInode(ctx, op)
   157:         recordOp(ctx, "LookUpInode", startTime, err)
   158:         return err
   159: }
   160:
   161: func (fs *monitoring) GetInodeAttributes(
   162:         ctx context.Context,
   163:         op *fuseops.GetInodeAttributesOp) error {
   164:         startTime := time.Now()
   165:         err := fs.wrapped.GetInodeAttributes(ctx, op)
   166:         recordOp(ctx, "GetInodeAttributes", startTime, err)
   167:         return err
   168: }
   169:
   170: func (fs *monitoring) SetInodeAttributes(
   171:         ctx context.Context,
   172:         op *fuseops.SetInodeAttributesOp) error {
   173:         startTime := time.Now()
   174:         err := fs.wrapped.SetInodeAttributes(ctx, op)
   175:         recordOp(ctx, "SetInodeAttributes", startTime, err)
   176:         return err
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:157 (PC: 0x192edb5)
   137: }
   138:
   139: func (fs *monitoring) Destroy() {
   140:         fs.wrapped.Destroy()
   141: }
   142:
   143: func (fs *monitoring) StatFS(
   144:         ctx context.Context,
   145:         op *fuseops.StatFSOp) error {
   146:         startTime := time.Now()
   147:         err := fs.wrapped.StatFS(ctx, op)
   148:         recordOp(ctx, "StatFS", startTime, err)
   149:         return err
   150: }
   151:
   152: func (fs *monitoring) LookUpInode(
   153:         ctx context.Context,
   154:         op *fuseops.LookUpInodeOp) error {
   155:         startTime := time.Now()
   156:         err := fs.wrapped.LookUpInode(ctx, op)
=> 157:         recordOp(ctx, "LookUpInode", startTime, err)
   158:         return err
   159: }
   160:
   161: func (fs *monitoring) GetInodeAttributes(
   162:         ctx context.Context,
   163:         op *fuseops.GetInodeAttributesOp) error {
   164:         startTime := time.Now()
   165:         err := fs.wrapped.GetInodeAttributes(ctx, op)
   166:         recordOp(ctx, "GetInodeAttributes", startTime, err)
   167:         return err
   168: }
   169:
   170: func (fs *monitoring) SetInodeAttributes(
   171:         ctx context.Context,
   172:         op *fuseops.SetInodeAttributesOp) error {
   173:         startTime := time.Now()
   174:         err := fs.wrapped.SetInodeAttributes(ctx, op)
   175:         recordOp(ctx, "SetInodeAttributes", startTime, err)
   176:         return err
   177: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:158 (PC: 0x192edf1)
   138:
   139: func (fs *monitoring) Destroy() {
   140:         fs.wrapped.Destroy()
   141: }
   142:
   143: func (fs *monitoring) StatFS(
   144:         ctx context.Context,
   145:         op *fuseops.StatFSOp) error {
   146:         startTime := time.Now()
   147:         err := fs.wrapped.StatFS(ctx, op)
   148:         recordOp(ctx, "StatFS", startTime, err)
   149:         return err
   150: }
   151:
   152: func (fs *monitoring) LookUpInode(
   153:         ctx context.Context,
   154:         op *fuseops.LookUpInodeOp) error {
   155:         startTime := time.Now()
   156:         err := fs.wrapped.LookUpInode(ctx, op)
   157:         recordOp(ctx, "LookUpInode", startTime, err)
=> 158:         return err
   159: }
   160:
   161: func (fs *monitoring) GetInodeAttributes(
   162:         ctx context.Context,
   163:         op *fuseops.GetInodeAttributesOp) error {
   164:         startTime := time.Now()
   165:         err := fs.wrapped.GetInodeAttributes(ctx, op)
   166:         recordOp(ctx, "GetInodeAttributes", startTime, err)
   167:         return err
   168: }
   169:
   170: func (fs *monitoring) SetInodeAttributes(
   171:         ctx context.Context,
   172:         op *fuseops.SetInodeAttributesOp) error {
   173:         startTime := time.Now()
   174:         err := fs.wrapped.SetInodeAttributes(ctx, op)
   175:         recordOp(ctx, "SetInodeAttributes", startTime, err)
   176:         return err
   177: }
   178:
(dlv) 
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144 (PC: 0x1911d44)
Values returned:
        ~r0: error nil

   124:                 }
   125:         }
   126: }
   127:
   128: func (s *fileSystemServer) handleOp(
   129:         c *fuse.Connection,
   130:         ctx context.Context,
   131:         op interface{}) {
   132:         defer s.opsInFlight.Done()
   133:
   134:         // Dispatch to the appropriate method.
   135:         var err error
   136:         switch typed := op.(type) {
   137:         default:
   138:                 err = fuse.ENOSYS
   139:
   140:         case *fuseops.StatFSOp:
   141:                 err = s.fs.StatFS(ctx, typed)
   142:
   143:         case *fuseops.LookUpInodeOp:
=> 144:                 err = s.fs.LookUpInode(ctx, typed)
   145:
   146:         case *fuseops.GetInodeAttributesOp:
   147:                 err = s.fs.GetInodeAttributes(ctx, typed)
   148:
   149:         case *fuseops.SetInodeAttributesOp:
   150:                 err = s.fs.SetInodeAttributes(ctx, typed)
   151:
   152:         case *fuseops.ForgetInodeOp:
   153:                 err = s.fs.ForgetInode(ctx, typed)
   154:
   155:         case *fuseops.BatchForgetOp:
   156:                 err = s.fs.BatchForget(ctx, typed)
   157:                 if err == fuse.ENOSYS {
   158:                         // Handle as a series of single-inode forget operations
   159:                         for _, entry := range typed.Entries {
   160:                                 err = s.fs.ForgetInode(ctx, &fuseops.ForgetInodeOp{
   161:                                         Inode:     entry.Inode,
   162:                                         N:         entry.N,
   163:                                         OpContext: typed.OpContext,
   164:                                 })
(dlv) 
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:136 (PC: 0x1911d54)
   116:                 if _, ok := op.(*fuseops.ForgetInodeOp); ok {
   117:                         // Special case: call in this goroutine for
   118:                         // forget inode ops, which may come in a
   119:                         // flurry from the kernel and are generally
   120:                         // cheap for the file system to handle
   121:                         s.handleOp(c, ctx, op)
   122:                 } else {
   123:                         go s.handleOp(c, ctx, op)
   124:                 }
   125:         }
   126: }
   127:
   128: func (s *fileSystemServer) handleOp(
   129:         c *fuse.Connection,
   130:         ctx context.Context,
   131:         op interface{}) {
   132:         defer s.opsInFlight.Done()
   133:
   134:         // Dispatch to the appropriate method.
   135:         var err error
=> 136:         switch typed := op.(type) {
   137:         default:
   138:                 err = fuse.ENOSYS
   139:
   140:         case *fuseops.StatFSOp:
   141:                 err = s.fs.StatFS(ctx, typed)
   142:
   143:         case *fuseops.LookUpInodeOp:
   144:                 err = s.fs.LookUpInode(ctx, typed)
   145:
   146:         case *fuseops.GetInodeAttributesOp:
   147:                 err = s.fs.GetInodeAttributes(ctx, typed)
   148:
   149:         case *fuseops.SetInodeAttributesOp:
   150:                 err = s.fs.SetInodeAttributes(ctx, typed)
   151:
   152:         case *fuseops.ForgetInodeOp:
   153:                 err = s.fs.ForgetInode(ctx, typed)
   154:
   155:         case *fuseops.BatchForgetOp:
   156:                 err = s.fs.BatchForget(ctx, typed)
(dlv) 
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:241 (PC: 0x1912ec7)
   221:
   222:         case *fuseops.ReadSymlinkOp:
   223:                 err = s.fs.ReadSymlink(ctx, typed)
   224:
   225:         case *fuseops.RemoveXattrOp:
   226:                 err = s.fs.RemoveXattr(ctx, typed)
   227:
   228:         case *fuseops.GetXattrOp:
   229:                 err = s.fs.GetXattr(ctx, typed)
   230:
   231:         case *fuseops.ListXattrOp:
   232:                 err = s.fs.ListXattr(ctx, typed)
   233:
   234:         case *fuseops.SetXattrOp:
   235:                 err = s.fs.SetXattr(ctx, typed)
   236:
   237:         case *fuseops.FallocateOp:
   238:                 err = s.fs.Fallocate(ctx, typed)
   239:         }
   240:
=> 241:         c.Reply(ctx, err)
   242: }
(dlv) 
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:242 (PC: 0x1912ef4)
   222:         case *fuseops.ReadSymlinkOp:
   223:                 err = s.fs.ReadSymlink(ctx, typed)
   224:
   225:         case *fuseops.RemoveXattrOp:
   226:                 err = s.fs.RemoveXattr(ctx, typed)
   227:
   228:         case *fuseops.GetXattrOp:
   229:                 err = s.fs.GetXattr(ctx, typed)
   230:
   231:         case *fuseops.ListXattrOp:
   232:                 err = s.fs.ListXattr(ctx, typed)
   233:
   234:         case *fuseops.SetXattrOp:
   235:                 err = s.fs.SetXattr(ctx, typed)
   236:
   237:         case *fuseops.FallocateOp:
   238:                 err = s.fs.Fallocate(ctx, typed)
   239:         }
   240:
   241:         c.Reply(ctx, err)
=> 242: }
(dlv) 
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Values returned:

  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
  1695:         BYTE    $0x90   // NOP
=>1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
  1716: #ifndef GOOS_plan9
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(490):1 total:27) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2129 (PC: 0x1944aa0)
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
=>2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.OpenDirOp")(0xc0001c2140)
*github.com/jacobsa/fuse/fuseops.OpenDirOp {
        Inode: 2,
        Handle: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 518, Pid: 3679465, Uid: 1012083},}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2130 (PC: 0x1944abd)
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
=>2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2135 (PC: 0x1944b6a)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
=>2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).dirInodeOrDie() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1217 (PC: 0x193a373)
  1197:         return
  1198: }
  1199:
  1200: // inodeOrDie returns the inode with the given ID, panicking with a helpful
  1201: // error message if it doesn't exist.
  1202: //
  1203: // LOCKS_REQUIRED(fs.mu)
  1204: func (fs *fileSystem) inodeOrDie(id fuseops.InodeID) (in inode.Inode) {
  1205:         in = fs.inodes[id]
  1206:         if in == nil {
  1207:                 panic(fmt.Sprintf("inode %d doesn't exist", id))
  1208:         }
  1209:
  1210:         return
  1211: }
  1212:
  1213: // dirInodeOrDie returns the directory inode with the given ID, panicking with
  1214: // a helpful error message if it doesn't exist or is the wrong type.
  1215: //
  1216: // LOCKS_REQUIRED(fs.mu)
=>1217: func (fs *fileSystem) dirInodeOrDie(id fuseops.InodeID) (in inode.DirInode) {
  1218:         tmp := fs.inodes[id]
  1219:         in, ok := tmp.(inode.DirInode)
  1220:         if !ok {
  1221:                 panic(fmt.Sprintf("inode %d is %T, wanted inode.DirInode", id, tmp))
  1222:         }
  1223:
  1224:         return
  1225: }
  1226:
  1227: // fileInodeOrDie returns the file inode with the given ID, panicking with a
  1228: // helpful error message if it doesn't exist or is the wrong type.
  1229: //
  1230: // LOCKS_REQUIRED(fs.mu)
  1231: func (fs *fileSystem) fileInodeOrDie(id fuseops.InodeID) (in *inode.FileInode) {
  1232:         tmp := fs.inodes[id]
  1233:         in, ok := tmp.(*inode.FileInode)
  1234:         if !ok {
  1235:                 panic(fmt.Sprintf("inode %d is %T, wanted *inode.FileInode", id, tmp))
  1236:         }
  1237:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).dirInodeOrDie() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1218 (PC: 0x193a390)
  1198: }
  1199:
  1200: // inodeOrDie returns the inode with the given ID, panicking with a helpful
  1201: // error message if it doesn't exist.
  1202: //
  1203: // LOCKS_REQUIRED(fs.mu)
  1204: func (fs *fileSystem) inodeOrDie(id fuseops.InodeID) (in inode.Inode) {
  1205:         in = fs.inodes[id]
  1206:         if in == nil {
  1207:                 panic(fmt.Sprintf("inode %d doesn't exist", id))
  1208:         }
  1209:
  1210:         return
  1211: }
  1212:
  1213: // dirInodeOrDie returns the directory inode with the given ID, panicking with
  1214: // a helpful error message if it doesn't exist or is the wrong type.
  1215: //
  1216: // LOCKS_REQUIRED(fs.mu)
  1217: func (fs *fileSystem) dirInodeOrDie(id fuseops.InodeID) (in inode.DirInode) {
=>1218:         tmp := fs.inodes[id]
  1219:         in, ok := tmp.(inode.DirInode)
  1220:         if !ok {
  1221:                 panic(fmt.Sprintf("inode %d is %T, wanted inode.DirInode", id, tmp))
  1222:         }
  1223:
  1224:         return
  1225: }
  1226:
  1227: // fileInodeOrDie returns the file inode with the given ID, panicking with a
  1228: // helpful error message if it doesn't exist or is the wrong type.
  1229: //
  1230: // LOCKS_REQUIRED(fs.mu)
  1231: func (fs *fileSystem) fileInodeOrDie(id fuseops.InodeID) (in *inode.FileInode) {
  1232:         tmp := fs.inodes[id]
  1233:         in, ok := tmp.(*inode.FileInode)
  1234:         if !ok {
  1235:                 panic(fmt.Sprintf("inode %d is %T, wanted *inode.FileInode", id, tmp))
  1236:         }
  1237:
  1238:         return
(dlv) p fs.inodes
map[github.com/jacobsa/fuse/fuseops.InodeID]github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Inode [
        1: (unreadable invalid interface type), 
        2: (unreadable invalid interface type), 
]
(dlv) p id
2
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).dirInodeOrDie() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1219 (PC: 0x193a3ce)
  1199:
  1200: // inodeOrDie returns the inode with the given ID, panicking with a helpful
  1201: // error message if it doesn't exist.
  1202: //
  1203: // LOCKS_REQUIRED(fs.mu)
  1204: func (fs *fileSystem) inodeOrDie(id fuseops.InodeID) (in inode.Inode) {
  1205:         in = fs.inodes[id]
  1206:         if in == nil {
  1207:                 panic(fmt.Sprintf("inode %d doesn't exist", id))
  1208:         }
  1209:
  1210:         return
  1211: }
  1212:
  1213: // dirInodeOrDie returns the directory inode with the given ID, panicking with
  1214: // a helpful error message if it doesn't exist or is the wrong type.
  1215: //
  1216: // LOCKS_REQUIRED(fs.mu)
  1217: func (fs *fileSystem) dirInodeOrDie(id fuseops.InodeID) (in inode.DirInode) {
  1218:         tmp := fs.inodes[id]
=>1219:         in, ok := tmp.(inode.DirInode)
  1220:         if !ok {
  1221:                 panic(fmt.Sprintf("inode %d is %T, wanted inode.DirInode", id, tmp))
  1222:         }
  1223:
  1224:         return
  1225: }
  1226:
  1227: // fileInodeOrDie returns the file inode with the given ID, panicking with a
  1228: // helpful error message if it doesn't exist or is the wrong type.
  1229: //
  1230: // LOCKS_REQUIRED(fs.mu)
  1231: func (fs *fileSystem) fileInodeOrDie(id fuseops.InodeID) (in *inode.FileInode) {
  1232:         tmp := fs.inodes[id]
  1233:         in, ok := tmp.(*inode.FileInode)
  1234:         if !ok {
  1235:                 panic(fmt.Sprintf("inode %d is %T, wanted *inode.FileInode", id, tmp))
  1236:         }
  1237:
  1238:         return
  1239: }
(dlv) p tmp
(unreadable invalid interface type)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).dirInodeOrDie() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1220 (PC: 0x193a468)
  1200: // inodeOrDie returns the inode with the given ID, panicking with a helpful
  1201: // error message if it doesn't exist.
  1202: //
  1203: // LOCKS_REQUIRED(fs.mu)
  1204: func (fs *fileSystem) inodeOrDie(id fuseops.InodeID) (in inode.Inode) {
  1205:         in = fs.inodes[id]
  1206:         if in == nil {
  1207:                 panic(fmt.Sprintf("inode %d doesn't exist", id))
  1208:         }
  1209:
  1210:         return
  1211: }
  1212:
  1213: // dirInodeOrDie returns the directory inode with the given ID, panicking with
  1214: // a helpful error message if it doesn't exist or is the wrong type.
  1215: //
  1216: // LOCKS_REQUIRED(fs.mu)
  1217: func (fs *fileSystem) dirInodeOrDie(id fuseops.InodeID) (in inode.DirInode) {
  1218:         tmp := fs.inodes[id]
  1219:         in, ok := tmp.(inode.DirInode)
=>1220:         if !ok {
  1221:                 panic(fmt.Sprintf("inode %d is %T, wanted inode.DirInode", id, tmp))
  1222:         }
  1223:
  1224:         return
  1225: }
  1226:
  1227: // fileInodeOrDie returns the file inode with the given ID, panicking with a
  1228: // helpful error message if it doesn't exist or is the wrong type.
  1229: //
  1230: // LOCKS_REQUIRED(fs.mu)
  1231: func (fs *fileSystem) fileInodeOrDie(id fuseops.InodeID) (in *inode.FileInode) {
  1232:         tmp := fs.inodes[id]
  1233:         in, ok := tmp.(*inode.FileInode)
  1234:         if !ok {
  1235:                 panic(fmt.Sprintf("inode %d is %T, wanted *inode.FileInode", id, tmp))
  1236:         }
  1237:
  1238:         return
  1239: }
  1240:
(dlv) p in
(unreadable invalid interface type)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).dirInodeOrDie() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1224 (PC: 0x193a46c)
  1204: func (fs *fileSystem) inodeOrDie(id fuseops.InodeID) (in inode.Inode) {
  1205:         in = fs.inodes[id]
  1206:         if in == nil {
  1207:                 panic(fmt.Sprintf("inode %d doesn't exist", id))
  1208:         }
  1209:
  1210:         return
  1211: }
  1212:
  1213: // dirInodeOrDie returns the directory inode with the given ID, panicking with
  1214: // a helpful error message if it doesn't exist or is the wrong type.
  1215: //
  1216: // LOCKS_REQUIRED(fs.mu)
  1217: func (fs *fileSystem) dirInodeOrDie(id fuseops.InodeID) (in inode.DirInode) {
  1218:         tmp := fs.inodes[id]
  1219:         in, ok := tmp.(inode.DirInode)
  1220:         if !ok {
  1221:                 panic(fmt.Sprintf("inode %d is %T, wanted inode.DirInode", id, tmp))
  1222:         }
  1223:
=>1224:         return
  1225: }
  1226:
  1227: // fileInodeOrDie returns the file inode with the given ID, panicking with a
  1228: // helpful error message if it doesn't exist or is the wrong type.
  1229: //
  1230: // LOCKS_REQUIRED(fs.mu)
  1231: func (fs *fileSystem) fileInodeOrDie(id fuseops.InodeID) (in *inode.FileInode) {
  1232:         tmp := fs.inodes[id]
  1233:         in, ok := tmp.(*inode.FileInode)
  1234:         if !ok {
  1235:                 panic(fmt.Sprintf("inode %d is %T, wanted *inode.FileInode", id, tmp))
  1236:         }
  1237:
  1238:         return
  1239: }
  1240:
  1241: // symlinkInodeOrDie returns the symlink inode with the given ID, panicking
  1242: // with a helpful error message if it doesn't exist or is the wrong type.
  1243: //
  1244: // LOCKS_REQUIRED(fs.mu)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2135 (PC: 0x1944b89)
Values returned:
        in: (unreadable invalid interface type)

  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
=>2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2138 (PC: 0x1944b93)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
=>2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2139 (PC: 0x1944ba9)
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
=>2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2141 (PC: 0x1944bce)
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
=>2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
(dlv) p fs.implicitDirs
true
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:60 (PC: 0x1926633)
    40:         /////////////////////////
    41:
    42:         Mu locker.Locker
    43:
    44:         // All entries in the directory. Populated the first time we need one.
    45:         //
    46:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    47:         //
    48:         // GUARDED_BY(Mu)
    49:         entries []fuseutil.Dirent
    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
=>  60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
    64:         dh = &DirHandle{
    65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
    70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:64 (PC: 0x192665a)
    44:         // All entries in the directory. Populated the first time we need one.
    45:         //
    46:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    47:         //
    48:         // GUARDED_BY(Mu)
    49:         entries []fuseutil.Dirent
    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
=>  64:         dh = &DirHandle{
    65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
    70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
(dlv) p in
(unreadable invalid interface type)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:65 (PC: 0x19266b2)
    45:         //
    46:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    47:         //
    48:         // GUARDED_BY(Mu)
    49:         entries []fuseutil.Dirent
    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
    64:         dh = &DirHandle{
=>  65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
    70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
    85:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:64 (PC: 0x19266e8)
    44:         // All entries in the directory. Populated the first time we need one.
    45:         //
    46:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    47:         //
    48:         // GUARDED_BY(Mu)
    49:         entries []fuseutil.Dirent
    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
=>  64:         dh = &DirHandle{
    65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
    70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:66 (PC: 0x19266ef)
    46:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    47:         //
    48:         // GUARDED_BY(Mu)
    49:         entries []fuseutil.Dirent
    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
    64:         dh = &DirHandle{
    65:                 in:           in,
=>  66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
    70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
    85:
    86: func (dh *DirHandle) checkInvariants() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:64 (PC: 0x19266fa)
    44:         // All entries in the directory. Populated the first time we need one.
    45:         //
    46:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    47:         //
    48:         // GUARDED_BY(Mu)
    49:         entries []fuseutil.Dirent
    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
=>  64:         dh = &DirHandle{
    65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
    70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:70 (PC: 0x1926704)
    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
    64:         dh = &DirHandle{
    65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
=>  70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
    85:
    86: func (dh *DirHandle) checkInvariants() {
    87:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    88:         for i := 0; i < len(dh.entries)-1; i++ {
    89:                 if !(dh.entries[i+1].Offset == dh.entries[i].Offset+1) {
    90:                         panic(
(dlv) p in
(unreadable invalid interface type)
(dlv) p in.Name()
Command failed: invalid interface type
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).Name() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:393 (PC: 0x1917384)
   373:
   374:         return
   375: }
   376:
   377: ////////////////////////////////////////////////////////////////////////
   378: // Public interface
   379: ////////////////////////////////////////////////////////////////////////
   380:
   381: func (d *dirInode) Lock() {
   382:         d.mu.Lock()
   383: }
   384:
   385: func (d *dirInode) Unlock() {
   386:         d.mu.Unlock()
   387: }
   388:
   389: func (d *dirInode) ID() fuseops.InodeID {
   390:         return d.id
   391: }
   392:
=> 393: func (d *dirInode) Name() Name {
   394:         return d.name
   395: }
   396:
   397: // LOCKS_REQUIRED(d)
   398: func (d *dirInode) IncrementLookupCount() {
   399:         d.lc.Inc()
   400: }
   401:
   402: // LOCKS_REQUIRED(d)
   403: func (d *dirInode) DecrementLookupCount(n uint64) (destroy bool) {
   404:         destroy = d.lc.Dec(n)
   405:         return
   406: }
   407:
   408: // LOCKS_REQUIRED(d)
   409: func (d *dirInode) Destroy() (err error) {
   410:         // Nothing interesting to do.
   411:         return
   412: }
   413:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).Name() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:394 (PC: 0x19173a4)
   374:         return
   375: }
   376:
   377: ////////////////////////////////////////////////////////////////////////
   378: // Public interface
   379: ////////////////////////////////////////////////////////////////////////
   380:
   381: func (d *dirInode) Lock() {
   382:         d.mu.Lock()
   383: }
   384:
   385: func (d *dirInode) Unlock() {
   386:         d.mu.Unlock()
   387: }
   388:
   389: func (d *dirInode) ID() fuseops.InodeID {
   390:         return d.id
   391: }
   392:
   393: func (d *dirInode) Name() Name {
=> 394:         return d.name
   395: }
   396:
   397: // LOCKS_REQUIRED(d)
   398: func (d *dirInode) IncrementLookupCount() {
   399:         d.lc.Inc()
   400: }
   401:
   402: // LOCKS_REQUIRED(d)
   403: func (d *dirInode) DecrementLookupCount(n uint64) (destroy bool) {
   404:         destroy = d.lc.Dec(n)
   405:         return
   406: }
   407:
   408: // LOCKS_REQUIRED(d)
   409: func (d *dirInode) Destroy() (err error) {
   410:         // Nothing interesting to do.
   411:         return
   412: }
   413:
   414: // LOCKS_REQUIRED(d)
(dlv) p d.name
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"}
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:70 (PC: 0x192671f)
Values returned:
        ~r0: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"}

    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
    64:         dh = &DirHandle{
    65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
=>  70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
    85:
    86: func (dh *DirHandle) checkInvariants() {
    87:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    88:         for i := 0; i < len(dh.entries)-1; i++ {
    89:                 if !(dh.entries[i+1].Offset == dh.entries[i].Offset+1) {
    90:                         panic(
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name.GcsObjectName() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/name.go:90 (PC: 0x1921ca4)
    70: }
    71:
    72: // IsBucketRoot returns true if the name represents of a root directory
    73: // of a GCS bucket.
    74: func (name Name) IsBucketRoot() bool {
    75:         return name.objectName == ""
    76: }
    77:
    78: // IsDir returns true if the name represents a directory.
    79: func (name Name) IsDir() bool {
    80:         return name.IsBucketRoot() ||
    81:                 name.objectName[len(name.objectName)-1] == '/'
    82: }
    83:
    84: // IsFile returns true if the name represents a file.
    85: func (name Name) IsFile() bool {
    86:         return !name.IsDir()
    87: }
    88:
    89: // GcsObjectName returns the name of the gcs object backed by the inode.
=>  90: func (name Name) GcsObjectName() string {
    91:         return name.objectName
    92: }
    93:
    94: // LocalName returns the name of the directory or file in the local file system.
    95: func (name Name) LocalName() string {
    96:         if name.bucketName == "" {
    97:                 return name.objectName
    98:         }
    99:         return name.bucketName + "/" + name.objectName
   100: }
   101:
   102: // String returns LocalName.
   103: func (name Name) String() string {
   104:         return name.LocalName()
   105: }
   106:
   107: // IsDirectChildOf returns true if the name is a direct child file or directory
   108: // of another directory.
   109: func (name Name) IsDirectChildOf(parent Name) bool {
   110:         if !parent.IsDir() && name.IsBucketRoot() {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name.GcsObjectName() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/name.go:91 (PC: 0x1921cc1)
    71:
    72: // IsBucketRoot returns true if the name represents of a root directory
    73: // of a GCS bucket.
    74: func (name Name) IsBucketRoot() bool {
    75:         return name.objectName == ""
    76: }
    77:
    78: // IsDir returns true if the name represents a directory.
    79: func (name Name) IsDir() bool {
    80:         return name.IsBucketRoot() ||
    81:                 name.objectName[len(name.objectName)-1] == '/'
    82: }
    83:
    84: // IsFile returns true if the name represents a file.
    85: func (name Name) IsFile() bool {
    86:         return !name.IsDir()
    87: }
    88:
    89: // GcsObjectName returns the name of the gcs object backed by the inode.
    90: func (name Name) GcsObjectName() string {
=>  91:         return name.objectName
    92: }
    93:
    94: // LocalName returns the name of the directory or file in the local file system.
    95: func (name Name) LocalName() string {
    96:         if name.bucketName == "" {
    97:                 return name.objectName
    98:         }
    99:         return name.bucketName + "/" + name.objectName
   100: }
   101:
   102: // String returns LocalName.
   103: func (name Name) String() string {
   104:         return name.LocalName()
   105: }
   106:
   107: // IsDirectChildOf returns true if the name is a direct child file or directory
   108: // of another directory.
   109: func (name Name) IsDirectChildOf(parent Name) bool {
   110:         if !parent.IsDir() && name.IsBucketRoot() {
   111:                 return false
(dlv) p name.objectName
"a/"
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:70 (PC: 0x1926745)
Values returned:
        ~r0: "a/"

    50:
    51:         // Has entries yet been populated?
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
    64:         dh = &DirHandle{
    65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
=>  70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
    72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
    85:
    86: func (dh *DirHandle) checkInvariants() {
    87:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    88:         for i := 0; i < len(dh.entries)-1; i++ {
    89:                 if !(dh.entries[i+1].Offset == dh.entries[i].Offset+1) {
    90:                         panic(
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.NewDirHandle() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:72 (PC: 0x1926803)
    52:         //
    53:         // INVARIANT: If !entriesValid, then len(entries) == 0
    54:         //
    55:         // GUARDED_BY(Mu)
    56:         entriesValid bool
    57: }
    58:
    59: // NewDirHandle creates a directory handle that obtains listings from the supplied inode.
    60: func NewDirHandle(
    61:         in inode.DirInode,
    62:         implicitDirs bool) (dh *DirHandle) {
    63:         // Set up the basic struct.
    64:         dh = &DirHandle{
    65:                 in:           in,
    66:                 implicitDirs: implicitDirs,
    67:         }
    68:
    69:         // Set up invariant checking.
    70:         dh.Mu = locker.New("DH."+in.Name().GcsObjectName(), dh.checkInvariants)
    71:
=>  72:         return
    73: }
    74:
    75: ////////////////////////////////////////////////////////////////////////
    76: // Helpers
    77: ////////////////////////////////////////////////////////////////////////
    78:
    79: // Directory entries, sorted by name.
    80: type sortedDirents []fuseutil.Dirent
    81:
    82: func (p sortedDirents) Len() int           { return len(p) }
    83: func (p sortedDirents) Less(i, j int) bool { return p[i].Name < p[j].Name }
    84: func (p sortedDirents) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
    85:
    86: func (dh *DirHandle) checkInvariants() {
    87:         // INVARIANT: For each i, entries[i+1].Offset == entries[i].Offset + 1
    88:         for i := 0; i < len(dh.entries)-1; i++ {
    89:                 if !(dh.entries[i+1].Offset == dh.entries[i].Offset+1) {
    90:                         panic(
    91:                                 fmt.Sprintf(
    92:                                         "Unexpected offset sequence: %v, %v",
(dlv) p dh.Mu
(unreadable invalid interface type)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2141 (PC: 0x1944bef)
Values returned:
        dh: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc00073c000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle {
                in: (unreadable invalid interface type),
                implicitDirs: true,
                Mu: (unreadable invalid interface type),
                entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil,
                entriesValid: false,}

  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
=>2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2142 (PC: 0x1944c86)
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
=>2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2144 (PC: 0x1944c99)
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
=>2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:243 (PC: 0x192bba9)
Values returned:
        err: error nil

   223:         defer em.handlePanic()
   224:
   225:         err := em.wrapped.RmDir(ctx, op)
   226:         return em.mapError("RmDir", err)
   227: }
   228:
   229: func (em *errorMapping) Unlink(
   230:         ctx context.Context,
   231:         op *fuseops.UnlinkOp) error {
   232:         defer em.handlePanic()
   233:
   234:         err := em.wrapped.Unlink(ctx, op)
   235:         return em.mapError("Unlink", err)
   236: }
   237:
   238: func (em *errorMapping) OpenDir(
   239:         ctx context.Context,
   240:         op *fuseops.OpenDirOp) error {
   241:         defer em.handlePanic()
   242:
=> 243:         err := em.wrapped.OpenDir(ctx, op)
   244:         return em.mapError("OpenDir", err)
   245: }
   246:
   247: func (em *errorMapping) ReadDir(
   248:         ctx context.Context,
   249:         op *fuseops.ReadDirOp) error {
   250:         defer em.handlePanic()
   251:
   252:         err := em.wrapped.ReadDir(ctx, op)
   253:         return em.mapError("ReadDir", err)
   254: }
   255:
   256: func (em *errorMapping) ReleaseDirHandle(
   257:         ctx context.Context,
   258:         op *fuseops.ReleaseDirHandleOp) error {
   259:         defer em.handlePanic()
   260:
   261:         err := em.wrapped.ReleaseDirHandle(ctx, op)
   262:         return em.mapError("ReleaseDirHandle", err)
   263: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:273 (PC: 0x192fcee)
Values returned:
        ~r0: error nil

   253:         op *fuseops.RmDirOp) error {
   254:         startTime := time.Now()
   255:         err := fs.wrapped.RmDir(ctx, op)
   256:         recordOp(ctx, "RmDir", startTime, err)
   257:         return err
   258: }
   259:
   260: func (fs *monitoring) Unlink(
   261:         ctx context.Context,
   262:         op *fuseops.UnlinkOp) error {
   263:         startTime := time.Now()
   264:         err := fs.wrapped.Unlink(ctx, op)
   265:         recordOp(ctx, "Unlink", startTime, err)
   266:         return err
   267: }
   268:
   269: func (fs *monitoring) OpenDir(
   270:         ctx context.Context,
   271:         op *fuseops.OpenDirOp) error {
   272:         startTime := time.Now()
=> 273:         err := fs.wrapped.OpenDir(ctx, op)
   274:         recordOp(ctx, "OpenDir", startTime, err)
   275:         return err
   276: }
   277:
   278: func (fs *monitoring) ReadDir(
   279:         ctx context.Context,
   280:         op *fuseops.ReadDirOp) error {
   281:         startTime := time.Now()
   282:         err := fs.wrapped.ReadDir(ctx, op)
   283:         recordOp(ctx, "ReadDir", startTime, err)
   284:         return err
   285: }
   286:
   287: func (fs *monitoring) ReleaseDirHandle(
   288:         ctx context.Context,
   289:         op *fuseops.ReleaseDirHandleOp) error {
   290:         startTime := time.Now()
   291:         err := fs.wrapped.ReleaseDirHandle(ctx, op)
   292:         recordOp(ctx, "ReleaseDirHandle", startTime, err)
   293:         return err
(dlv) 
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:196 (PC: 0x1912984)
Values returned:
        ~r0: error nil

   176:
   177:         case *fuseops.CreateFileOp:
   178:                 err = s.fs.CreateFile(ctx, typed)
   179:
   180:         case *fuseops.CreateLinkOp:
   181:                 err = s.fs.CreateLink(ctx, typed)
   182:
   183:         case *fuseops.CreateSymlinkOp:
   184:                 err = s.fs.CreateSymlink(ctx, typed)
   185:
   186:         case *fuseops.RenameOp:
   187:                 err = s.fs.Rename(ctx, typed)
   188:
   189:         case *fuseops.RmDirOp:
   190:                 err = s.fs.RmDir(ctx, typed)
   191:
   192:         case *fuseops.UnlinkOp:
   193:                 err = s.fs.Unlink(ctx, typed)
   194:
   195:         case *fuseops.OpenDirOp:
=> 196:                 err = s.fs.OpenDir(ctx, typed)
   197:
   198:         case *fuseops.ReadDirOp:
   199:                 err = s.fs.ReadDir(ctx, typed)
   200:
   201:         case *fuseops.ReleaseDirHandleOp:
   202:                 err = s.fs.ReleaseDirHandle(ctx, typed)
   203:
   204:         case *fuseops.OpenFileOp:
   205:                 err = s.fs.OpenFile(ctx, typed)
   206:
   207:         case *fuseops.ReadFileOp:
   208:                 err = s.fs.ReadFile(ctx, typed)
   209:
   210:         case *fuseops.WriteFileOp:
   211:                 err = s.fs.WriteFile(ctx, typed)
   212:
   213:         case *fuseops.SyncFileOp:
   214:                 err = s.fs.SyncFile(ctx, typed)
   215:
   216:         case *fuseops.FlushFileOp:
(dlv) 
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Values returned:

  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
  1695:         BYTE    $0x90   // NOP
=>1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
  1716: #ifndef GOOS_plan9
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(529):1 total:53) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2151 (PC: 0x1944da6)
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
=>2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2159 (PC: 0x1944eaf)
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
=>2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2160 (PC: 0x1944ecc)
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
=>2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2161 (PC: 0x1944f27)
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
=>2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2164 (PC: 0x1944f59)
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
=>2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
(dlv) p dh
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc00073c000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle {
        in: (unreadable invalid interface type),
        implicitDirs: true,
        Mu: (unreadable invalid interface type),
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil,
        entriesValid: false,}
(dlv) p in
(unreadable invalid interface type)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2165 (PC: 0x1944fa2)
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
=>2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
(dlv) p localFileEntries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2167 (PC: 0x1944fbf)
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
=>2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2168 (PC: 0x1944fd9)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
=>2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170 (PC: 0x1945082)
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
=>2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:270 (PC: 0x1928073)
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
=> 270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:276 (PC: 0x19280b8)
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
=> 276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
(dlv) p dh
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc00073c000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle {
        in: (unreadable invalid interface type),
        implicitDirs: true,
        Mu: (unreadable invalid interface type),
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil,
        entriesValid: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:277 (PC: 0x19280cb)
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
=> 277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:278 (PC: 0x1928100)
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
=> 278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:282 (PC: 0x1928112)
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
=> 282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
(dlv) p dh
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc00073c000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle {
        in: (unreadable invalid interface type),
        implicitDirs: true,
        Mu: (unreadable invalid interface type),
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil,
        entriesValid: false,}
(dlv) n 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283 (PC: 0x1928126)
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
=> 283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:239 (PC: 0x1927bd6)
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
=> 239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:240 (PC: 0x1927c13)
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
=> 240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:241 (PC: 0x1927c2f)
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
=> 241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:244 (PC: 0x1927cd5)
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
=> 244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245 (PC: 0x1927ce7)
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
=> 245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
(dlv) bt
0  0x0000000001927ce7 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
1  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
2  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
3  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
4  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
5  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
6  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
7  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) frame 2
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245 (PC: 0x1927ce7)
Frame 2: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170 (PC: 19450bf)
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
=>2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
(dlv) frame 1
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245 (PC: 0x1927ce7)
Frame 1: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283 (PC: 192815b)
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
=> 283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
(dlv) frame 0
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245 (PC: 0x1927ce7)
Frame 0: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245 (PC: 1927ce7)
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
=> 245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:161 (PC: 0x1927396)
   141:                                 prev.Type)
   142:
   143:                         return
   144:                 }
   145:
   146:                 // Repair whichever is not the directory.
   147:                 if eIsDir {
   148:                         prev.Name += inode.ConflictingFileNameSuffix
   149:                 } else {
   150:                         e.Name += inode.ConflictingFileNameSuffix
   151:                 }
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
=> 161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:167 (PC: 0x19273f0)
   147:                 if eIsDir {
   148:                         prev.Name += inode.ConflictingFileNameSuffix
   149:                 } else {
   150:                         e.Name += inode.ConflictingFileNameSuffix
   151:                 }
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
=> 167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:168 (PC: 0x19273f6)
   148:                         prev.Name += inode.ConflictingFileNameSuffix
   149:                 } else {
   150:                         e.Name += inode.ConflictingFileNameSuffix
   151:                 }
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
=> 168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:170 (PC: 0x19273f8)
   150:                         e.Name += inode.ConflictingFileNameSuffix
   151:                 }
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
=> 170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172 (PC: 0x192740f)
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
=> 172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
(dlv) p tok
""
(dlv) p in
(unreadable invalid interface type)
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:628 (PC: 0x1919ed6)
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
=> 628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:631 (PC: 0x1919f29)
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
=> 631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
(dlv) p dirInode
Command failed: could not find symbol value for dirInode
(dlv) p d       
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0003067e0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode {
        bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        mtimeClock: (unreadable invalid interface type),
        cacheClock: (unreadable invalid interface type),
        id: 2,
        implicitDirs: true,
        enableManagedFoldersListing: false,
        enableNonexistentTypeCache: false,
        name: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        attrs: github.com/jacobsa/fuse/fuseops.InodeAttributes {
                Size: 0,
                Nlink: 0,
                Mode: 2147484141,
                Rdev: 0,
                Atime: (*time.Time)(0xc000306850),
                Mtime: (*time.Time)(0xc000306868),
                Ctime: (*time.Time)(0xc000306880),
                Crtime: (*time.Time)(0xc000306898),
                Uid: 1012083,
                Gid: 89939,},
        mu: (unreadable invalid interface type),
        lc: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.lookupCount {id: 2, count: 2, destroyed: false},
        cache: (unreadable invalid interface type),}
(dlv) bt
0  0x0000000001919f29 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:631
1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
9  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) 
0  0x0000000001919f29 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:631
1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
9  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:631 (PC: 0x1919f29)
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
=> 631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
(dlv) bt
0  0x0000000001919f29 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:631
1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
9  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:631 (PC: 0x1919f29)
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
=> 631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
(dlv) p d
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0003067e0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode {
        bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        mtimeClock: (unreadable invalid interface type),
        cacheClock: (unreadable invalid interface type),
        id: 2,
        implicitDirs: true,
        enableManagedFoldersListing: false,
        enableNonexistentTypeCache: false,
        name: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        attrs: github.com/jacobsa/fuse/fuseops.InodeAttributes {
                Size: 0,
                Nlink: 0,
                Mode: 2147484141,
                Rdev: 0,
                Atime: (*time.Time)(0xc000306850),
                Mtime: (*time.Time)(0xc000306868),
                Ctime: (*time.Time)(0xc000306880),
                Crtime: (*time.Time)(0xc000306898),
                Uid: 1012083,
                Gid: 89939,},
        mu: (unreadable invalid interface type),
        lc: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.lookupCount {id: 2, count: 2, destroyed: false},
        cache: (unreadable invalid interface type),}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632 (PC: 0x1919f35)
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
=> 632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
(dlv) p tok
""
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(476):1 total:36) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:543 (PC: 0x1918d16)
   523:                         if o.Name == d.Name().GcsObjectName() {
   524:                                 continue
   525:                         }
   526:                         name := NewDescendantName(d.Name(), o.Name)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
=> 543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:550 (PC: 0x1918d63)
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
=> 550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:547 (PC: 0x1918da5)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
=> 547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:548 (PC: 0x1918db9)
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
=> 548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:547 (PC: 0x1918de7)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
=> 547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:549 (PC: 0x1918df1)
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
=> 549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:547 (PC: 0x1918df5)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
=> 547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:550 (PC: 0x1918dff)
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
=> 550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:547 (PC: 0x1918e36)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
=> 547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:551 (PC: 0x1918e40)
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
=> 551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:547 (PC: 0x1918e78)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
=> 547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:552 (PC: 0x1918e82)
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
=> 552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:547 (PC: 0x1918e8a)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
=> 547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:555 (PC: 0x1918e94)
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
=> 555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:547 (PC: 0x1918e9c)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
=> 547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:556 (PC: 0x1918ea6)
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
=> 556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:547 (PC: 0x1918eb8)
   527:                         descendants[name] = &Core{
   528:                                 Bucket:    d.Bucket(),
   529:                                 FullName:  name,
   530:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   531:                         }
   532:                 }
   533:
   534:                 // Are we done listing?
   535:                 if tok = listing.ContinuationToken; tok == "" {
   536:                         return descendants, nil
   537:                 }
   538:         }
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
=> 547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:559 (PC: 0x1918ec8)
   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
=> 559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(529):1 total:37) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000988500)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "a/", Delimiter: "/", IncludeTrailingDelimiter: true, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 5000, ProjectionVal: NoAcl (1)}
(dlv) p itr
("*cloud.google.com/go/storage.ObjectIterator")(0xc000a9a000)
*cloud.google.com/go/storage.ObjectIterator {
        ctx: (unreadable invalid interface type),
        query: cloud.google.com/go/storage.Query {
                Delimiter: "/",
                Prefix: "a/",
                Versions: false,
                attrSelection: []string len: 0, cap: 0, nil,
                StartOffset: "",
                EndOffset: "",
                Projection: ProjectionNoACL (2),
                IncludeTrailingDelimiter: true,
                MatchGlob: "",
                IncludeFoldersAsPrefixes: false,},
        pageInfo: *google.golang.org/api/iterator.PageInfo {
                Token: "",
                MaxSize: 5000,
                err: error nil,
                atEnd: false,
                fetch: cloud.google.com/go/storage.(*httpStorageClient).ListObjects.func1,
                bufLen: cloud.google.com/go/storage.(*httpStorageClient).ListObjects.func2,
                takeBuf: cloud.google.com/go/storage.(*httpStorageClient).ListObjects.func3,
                nextCalled: false,
                nextPageCalled: false,},
        nextFunc: google.golang.org/api/iterator.(*PageInfo).next-fm,
        items: []*cloud.google.com/go/storage.ObjectAttrs len: 0, cap: 0, nil,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:261 (PC: 0x18c1f86)
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
=> 261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:264 (PC: 0x18c1fdb)
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
=> 264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c1fdd)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) p attrs
("*cloud.google.com/go/storage.ObjectAttrs")(0xc0001f6000)
*cloud.google.com/go/storage.ObjectAttrs {
        Bucket: "gargnitin-test-empty-dirname-asia-se1",
        Name: "a/13",
        ContentType: "text/plain",
        ContentLanguage: "",
        CacheControl: "",
        EventBasedHold: false,
        TemporaryHold: false,
        RetentionExpirationTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ACL: []cloud.google.com/go/storage.ACLRule len: 0, cap: 0, nil,
        PredefinedACL: "",
        Owner: "",
        Size: 6,
        ContentEncoding: "",
        ContentDisposition: "",
        MD5: []uint8 len: 16, cap: 18, [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
        CRC32C: 893245630,
        MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+73 more",
        Metadata: map[string]string nil,
        Generation: 1714642903780300,
        Metageneration: 1,
        StorageClass: "STANDARD",
        Created: time.Time(2024-05-02T09:41:43Z){
                wall: 781000000,
                ext: 63850239703,
                loc: *time.Location nil,},
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(2024-05-02T09:41:43Z){
                wall: 781000000,
                ext: 63850239703,
                loc: *time.Location nil,},
        CustomerKeySHA256: "",
        KMSKeyName: "",
        Prefix: "",
        Etag: "CMyXycnW7oUDEAE=",
        CustomTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ComponentCount: 0,
        Retention: *cloud.google.com/go/storage.ObjectRetention nil,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(529):1 total:30) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:285 (PC: 0x18c22e1)
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
=> 285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
(dlv) p currObject
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object {
        Name: "a/13",
        ContentType: "text/plain",
        ContentLanguage: "",
        CacheControl: "",
        Owner: "",
        Size: 6,
        ContentEncoding: "",
        MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
        CRC32C: *893245630,
        MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+73 more",
        Metadata: map[string]string nil,
        Generation: 1714642903780300,
        MetaGeneration: 1,
        StorageClass: "STANDARD",
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(2024-05-02T09:41:43Z){
                wall: 781000000,
                ext: 63850239703,
                loc: *time.Location nil,},
        ComponentCount: 0,
        ContentDisposition: "",
        CustomTime: "0001-01-01T00:00:00Z",
        EventBasedHold: false,
        Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c2432)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) p attrs     
("*cloud.google.com/go/storage.ObjectAttrs")(0xc0001f65a0)
*cloud.google.com/go/storage.ObjectAttrs {
        Bucket: "",
        Name: "",
        ContentType: "",
        ContentLanguage: "",
        CacheControl: "",
        EventBasedHold: false,
        TemporaryHold: false,
        RetentionExpirationTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ACL: []cloud.google.com/go/storage.ACLRule len: 0, cap: 0, nil,
        PredefinedACL: "",
        Owner: "",
        Size: 0,
        ContentEncoding: "",
        ContentDisposition: "",
        MD5: []uint8 len: 0, cap: 0, nil,
        CRC32C: 0,
        MediaLink: "",
        Metadata: map[string]string nil,
        Generation: 0,
        Metageneration: 0,
        StorageClass: "",
        Created: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        CustomerKeySHA256: "",
        KMSKeyName: "",
        Prefix: "a/../",
        Etag: "",
        CustomTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ComponentCount: 0,
        Retention: *cloud.google.com/go/storage.ObjectRetention nil,}
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000988500)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "a/", Delimiter: "/", IncludeTrailingDelimiter: true, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 5000, ProjectionVal: NoAcl (1)}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(529):1 total:105) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) p req.MaxRe
Command failed: req has no member MaxRe
(dlv) p req.MaxResults
5000
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c2432)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(529):2 total:106) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) p attrs         
("*cloud.google.com/go/storage.ObjectAttrs")(0xc0001f6780)
*cloud.google.com/go/storage.ObjectAttrs {
        Bucket: "",
        Name: "",
        ContentType: "",
        ContentLanguage: "",
        CacheControl: "",
        EventBasedHold: false,
        TemporaryHold: false,
        RetentionExpirationTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ACL: []cloud.google.com/go/storage.ACLRule len: 0, cap: 0, nil,
        PredefinedACL: "",
        Owner: "",
        Size: 0,
        ContentEncoding: "",
        ContentDisposition: "",
        MD5: []uint8 len: 0, cap: 0, nil,
        CRC32C: 0,
        MediaLink: "",
        Metadata: map[string]string nil,
        Generation: 0,
        Metageneration: 0,
        StorageClass: "",
        Created: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        CustomerKeySHA256: "",
        KMSKeyName: "",
        Prefix: "a/./",
        Etag: "",
        CustomTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ComponentCount: 0,
        Retention: *cloud.google.com/go/storage.ObjectRetention nil,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c2432)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(529):3 total:107) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) p attrs
("*cloud.google.com/go/storage.ObjectAttrs")(0xc0001f6960)
*cloud.google.com/go/storage.ObjectAttrs {
        Bucket: "",
        Name: "",
        ContentType: "",
        ContentLanguage: "",
        CacheControl: "",
        EventBasedHold: false,
        TemporaryHold: false,
        RetentionExpirationTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ACL: []cloud.google.com/go/storage.ACLRule len: 0, cap: 0, nil,
        PredefinedACL: "",
        Owner: "",
        Size: 0,
        ContentEncoding: "",
        ContentDisposition: "",
        MD5: []uint8 len: 0, cap: 0, nil,
        CRC32C: 0,
        MediaLink: "",
        Metadata: map[string]string nil,
        Generation: 0,
        Metageneration: 0,
        StorageClass: "",
        Created: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        CustomerKeySHA256: "",
        KMSKeyName: "",
        Prefix: "a//",
        Etag: "",
        CustomTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ComponentCount: 0,
        Retention: *cloud.google.com/go/storage.ObjectRetention nil,}
(dlv) p list
github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e000),
        ],
        CollapsedRuns: []string len: 2, cap: 2, ["a/../","a/./"],
        ContinuationToken: "",}
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(529):3 total:107) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:296 (PC: 0x18c23c0)
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
=> 296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
(dlv) p list
github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e000),
        ],
        CollapsedRuns: []string len: 3, cap: 4, ["a/../","a/./","a//"],
        ContinuationToken: "",}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:300 (PC: 0x18c23c2)
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
=> 300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:301 (PC: 0x18c240c)
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
=> 301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
   321:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:302 (PC: 0x18c2419)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
=> 302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
   321:
   322:         if req.ContentEncoding != nil {
(dlv) p listing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000701a80)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e000),
        ],
        CollapsedRuns: []string len: 3, cap: 4, ["a/../","a/./","a//"],
        ContinuationToken: "",}
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
Values returned:
        listing: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000701a80)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e000),
                ],
                CollapsedRuns: []string len: 3, cap: 4, ["a/../","a/./","a//"],
                ContinuationToken: "",}
        err: error nil

   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) l 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(572):1 total:38) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:559 (PC: 0x1918f13)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000701a80)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e000),
                ],
                CollapsedRuns: []string len: 3, cap: 4, ["a/../","a/./","a//"],
                ContinuationToken: "",}
        ~r1: error nil

   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
=> 559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:560 (PC: 0x1918f8b)
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
=> 560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:565 (PC: 0x19190cb)
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
=> 565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:566 (PC: 0x19190d8)
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
=> 566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
(dlv) b 568
Breakpoint 18 set at 0x1919d38 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:573 (PC: 0x1919186)
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
=> 573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:575 (PC: 0x1919235)
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
=> 575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000988500)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "a/", Delimiter: "/", IncludeTrailingDelimiter: true, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 5000, ProjectionVal: NoAcl (1)}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:579 (PC: 0x19192f2)
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
=> 579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:584 (PC: 0x1919328)
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
=> 584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
(dlv) p nameBase
"13"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:593 (PC: 0x19195c5)
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
=> 593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:595 (PC: 0x1919627)
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
=> 595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
(dlv) p fileName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/13"}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:597 (PC: 0x191963c)
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
=> 597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/object_attrs.go:137 (PC: 0x100112e)
   117:
   118:         // Converting []*storagev1.ObjectAccessControl to []ACLRule for writer object.
   119:         var aclRules []storage.ACLRule
   120:         for _, element := range req.Acl {
   121:                 aclRules = append(aclRules, convertObjectAccessControlToACLRule(element))
   122:         }
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
=> 137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
   138:         if o == nil {
   139:                 return nil
   140:         }
   141:
   142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/object_attrs.go:138 (PC: 0x1001140)
   118:         // Converting []*storagev1.ObjectAccessControl to []ACLRule for writer object.
   119:         var aclRules []storage.ACLRule
   120:         for _, element := range req.Acl {
   121:                 aclRules = append(aclRules, convertObjectAccessControlToACLRule(element))
   122:         }
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
   137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
=> 138:         if o == nil {
   139:                 return nil
   140:         }
   141:
   142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/object_attrs.go:142 (PC: 0x100114d)
   122:         }
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
   137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
   138:         if o == nil {
   139:                 return nil
   140:         }
   141:
=> 142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
   159:                 ContentType:        o.ContentType,
   160:                 ContentLanguage:    o.ContentLanguage,
   161:                 CacheControl:       o.CacheControl,
   162:                 Owner:              o.Owner,
(dlv) p o
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object {
        Name: "a/13",
        ContentType: "text/plain",
        ContentLanguage: "",
        CacheControl: "",
        Owner: "",
        Size: 6,
        ContentEncoding: "",
        MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
        CRC32C: *893245630,
        MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+73 more",
        Metadata: map[string]string nil,
        Generation: 1714642903780300,
        MetaGeneration: 1,
        StorageClass: "STANDARD",
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(2024-05-02T09:41:43Z){
                wall: 781000000,
                ext: 63850239703,
                loc: *time.Location nil,},
        ComponentCount: 0,
        ContentDisposition: "",
        CustomTime: "0001-01-01T00:00:00Z",
        EventBasedHold: false,
        Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/object_attrs.go:143 (PC: 0x100115e)
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
   137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
   138:         if o == nil {
   139:                 return nil
   140:         }
   141:
   142:         return &gcs.MinObject{
=> 143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
   159:                 ContentType:        o.ContentType,
   160:                 ContentLanguage:    o.ContentLanguage,
   161:                 CacheControl:       o.CacheControl,
   162:                 Owner:              o.Owner,
   163:                 MD5:                o.MD5,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/object_attrs.go:142 (PC: 0x1001194)
   122:         }
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
   137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
   138:         if o == nil {
   139:                 return nil
   140:         }
   141:
=> 142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
   159:                 ContentType:        o.ContentType,
   160:                 ContentLanguage:    o.ContentLanguage,
   161:                 CacheControl:       o.CacheControl,
   162:                 Owner:              o.Owner,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/object_attrs.go:144 (PC: 0x100119b)
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
   137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
   138:         if o == nil {
   139:                 return nil
   140:         }
   141:
   142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
=> 144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
   159:                 ContentType:        o.ContentType,
   160:                 ContentLanguage:    o.ContentLanguage,
   161:                 CacheControl:       o.CacheControl,
   162:                 Owner:              o.Owner,
   163:                 MD5:                o.MD5,
   164:                 CRC32C:             o.CRC32C,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/object_attrs.go:142 (PC: 0x10011aa)
   122:         }
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
   137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
   138:         if o == nil {
   139:                 return nil
   140:         }
   141:
=> 142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
   159:                 ContentType:        o.ContentType,
   160:                 ContentLanguage:    o.ContentLanguage,
   161:                 CacheControl:       o.CacheControl,
   162:                 Owner:              o.Owner,
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:597 (PC: 0x1919649)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc000529140)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject {
                Name: "a/13",
                Size: 6,
                Generation: 1714642903780300,
                MetaGeneration: 1,
                Updated: time.Time(2024-05-02T09:41:43Z){
                        wall: 781000000,
                        ext: 63850239703,
                        loc: *time.Location nil,},
                Metadata: map[string]string nil,
                ContentEncoding: "",}

   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
=> 597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x1919651)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:595 (PC: 0x19196b0)
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
=> 595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x19196dc)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:596 (PC: 0x19196e6)
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
=> 596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x1919744)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:597 (PC: 0x191974e)
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
=> 597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x191977a)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:599 (PC: 0x191978a)
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
=> 599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
(dlv) p file
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc0009da000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/13"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject {
                Name: "a/13",
                Size: 6,
                Generation: 1714642903780300,
                MetaGeneration: 1,
                Updated: (*time.Time)(0xc000529168),
                Metadata: map[string]string nil,
                ContentEncoding: "",},
        Local: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:573 (PC: 0x191981e)
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
=> 573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:604 (PC: 0x191982b)
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
=> 604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core [
        {bucketName: "", objectName: "a/13"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0009da000),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc000529140),
                Local: false,}, 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:606 (PC: 0x191984d)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
=> 606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
(dlv) p newTok
""
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x191985f)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (PC: 0x1919920)
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
=> 612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:613 (PC: 0x1919935)
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
=> 613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:614 (PC: 0x191999a)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
=> 614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919a69)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919a7e)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919adf)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b0a)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:620 (PC: 0x1919b14)
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
=> 620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b6d)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:621 (PC: 0x1919b77)
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
=> 621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b9c)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1919bac)
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
=> 623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x1919c3d)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (PC: 0x1919920)
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
=> 612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:613 (PC: 0x1919935)
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
=> 613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:614 (PC: 0x191999a)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
=> 614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919a69)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919a7e)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919adf)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b0a)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:620 (PC: 0x1919b14)
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
=> 620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b6d)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:621 (PC: 0x1919b77)
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
=> 621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b9c)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1919bac)
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
=> 623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x1919c3d)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (PC: 0x1919920)
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
=> 612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:613 (PC: 0x1919935)
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
=> 613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:614 (PC: 0x191999a)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
=> 614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919a69)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core [
        {bucketName: "", objectName: "a/13"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0009da000),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc000529140),
                Local: false,}, 
        {bucketName: "", objectName: "a/../"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000873440),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
        {bucketName: "", objectName: "a/./"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000d1e500),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919a7e)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919adf)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b0a)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:620 (PC: 0x1919b14)
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
=> 620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b6d)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:621 (PC: 0x1919b77)
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
=> 621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b9c)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1919bac)
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
=> 623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x1919c3d)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:625 (PC: 0x1919c58)
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
=> 625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core [
        {bucketName: "", objectName: "a/13"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0009da000),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc000529140),
                Local: false,}, 
        {bucketName: "", objectName: "a/../"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000873440),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
        {bucketName: "", objectName: "a/./"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000d1e500),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
        {bucketName: "", objectName: "a/a/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc00025d980),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
]
(dlv) p listing.CollapsedRuns
[]string len: 3, cap: 4, ["a/../","a/./","a//"]
(dlv) b 612 cond p == "a//"
Command failed: location "612 cond p == \"a//\"" not found
(dlv) b 612                
Breakpoint 19 set at 0x1919920 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x45f40e,0x446804,0x446724 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (6)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (53)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (27)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (38)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (107)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (30)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (6)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (6)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (6)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (6)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (6)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (6)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (6)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (2)
Breakpoint 17 (enabled) at 0x1917dea for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (1)
Breakpoint 18 (enabled) at 0x1919d38 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (0)
Breakpoint 19 (enabled) at 0x1919920 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (0)
(dlv) cond 19 p=="a//"     
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446724,0x45f40e,0x446804 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (6)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (53)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (27)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (38)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (107)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (30)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (6)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (6)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (6)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (6)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (6)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (6)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (6)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (2)
Breakpoint 17 (enabled) at 0x1917dea for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (1)
Breakpoint 18 (enabled) at 0x1919d38 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (0)
Breakpoint 19 (enabled) at 0x1919920 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (0)
        cond p == "a//"
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:625 (PC: 0x1919c58)
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
=> 625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(529):1 total:1) (PC: 0x1919d38)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2030):1 total:39) (PC: 0x18c1f48)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? s
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) bt
0  0x00000000018c1f48 in github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260
1  0x00000000018c66dd in github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205
2  0x000000000190ce68 in github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.(*contentTypeBucket).ListObjects
   at <autogenerated>:1
3  0x000000000190b748 in github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.(*SyncerBucket).ListObjects
   at <autogenerated>:1
4  0x0000000000fff892 in github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ListPrefix
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/list_prefix.go:39
5  0x00000000018fed76 in github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.garbageCollectOnce.func1
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/gcsx/garbage_collect.go:41
6  0x0000000000ed4a31 in github.com/jacobsa/syncutil.(*Bundle).Add.func1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89
7  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) frame 5
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(529):1 total:1) (PC: 0x1919d38)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2030):1 total:39) (PC: 0x18c1f48)
Frame 5: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/gcsx/garbage_collect.go:41 (PC: 18fed76)
    21:
    22:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs"
    23:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil"
    24:         "golang.org/x/net/context"
    25:
    26:         "github.com/googlecloudplatform/gcsfuse/v2/internal/logger"
    27:         "github.com/jacobsa/syncutil"
    28: )
    29:
    30: func garbageCollectOnce(
    31:         ctx context.Context,
    32:         tmpObjectPrefix string,
    33:         bucket gcs.Bucket) (objectsDeleted uint64, err error) {
    34:         const stalenessThreshold = 30 * time.Minute
    35:         b := syncutil.NewBundle(ctx)
    36:
    37:         // List all objects with the temporary prefix.
    38:         objects := make(chan *gcs.Object, 100)
    39:         b.Add(func(ctx context.Context) (err error) {
    40:                 defer close(objects)
=>  41:                 err = storageutil.ListPrefix(ctx, bucket, tmpObjectPrefix, objects)
    42:                 if err != nil {
    43:                         err = fmt.Errorf("ListPrefix: %w", err)
    44:                         return
    45:                 }
    46:
    47:                 return
    48:         })
    49:
    50:         // Filter to the names of objects that are stale.
    51:         now := time.Now()
    52:         staleNames := make(chan string, 100)
    53:         b.Add(func(ctx context.Context) (err error) {
    54:                 defer close(staleNames)
    55:                 for o := range objects {
    56:                         if now.Sub(o.Updated) < stalenessThreshold {
    57:                                 continue
    58:                         }
    59:
    60:                         select {
    61:                         case <-ctx.Done():
(dlv) frame 6
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(529):1 total:1) (PC: 0x1919d38)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2030):1 total:39) (PC: 0x18c1f48)
Frame 6: /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89 (PC: ed4a31)
    69: type Bundle struct {
    70:         context context.Context
    71:         cancel  context.CancelFunc
    72:
    73:         waitGroup sync.WaitGroup
    74:
    75:         errorOnce  sync.Once
    76:         firstError error
    77: }
    78:
    79: // Add a new operation to the bundle. The operation will be invoked with a
    80: // context that will be cancelled if any other operation fails or has already
    81: // failed.
    82: func (b *Bundle) Add(f func(context.Context) error) {
    83:         b.waitGroup.Add(1)
    84:
    85:         // Run the function in the background.
    86:         go func() {
    87:                 defer b.waitGroup.Done()
    88:
=>  89:                 err := f(b.context)
    90:                 if err == nil {
    91:                         return
    92:                 }
    93:
    94:                 // On first error, cancel the context and save the error.
    95:                 b.errorOnce.Do(func() {
    96:                         b.firstError = err
    97:                         b.cancel()
    98:                 })
    99:         }()
   100: }
   101:
   102: // Wait for all previously-added operations to complete. Return nil if all
   103: // operations succeeded. Otherwise return the first error.
   104: //
   105: // Add must not be called concurrently with or after Join.
   106: func (b *Bundle) Join() error {
   107:         b.waitGroup.Wait()
   108:
   109:         // context.WithCancel requires that we arrange for this to be called
(dlv) frame 7
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(529):1 total:1) (PC: 0x1919d38)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2030):1 total:39) (PC: 0x18c1f48)
Frame 7: /usr/lib/google-golang/src/runtime/asm_amd64.s:1695 (PC: 4817c1)
  1675: GLOBL shifts<>(SB),RODATA,$256
  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
=>1695:         BYTE    $0x90   // NOP
  1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
(dlv) frame 5
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(529):1 total:1) (PC: 0x1919d38)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2030):1 total:39) (PC: 0x18c1f48)
Frame 5: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/gcsx/garbage_collect.go:41 (PC: 18fed76)
    21:
    22:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs"
    23:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil"
    24:         "golang.org/x/net/context"
    25:
    26:         "github.com/googlecloudplatform/gcsfuse/v2/internal/logger"
    27:         "github.com/jacobsa/syncutil"
    28: )
    29:
    30: func garbageCollectOnce(
    31:         ctx context.Context,
    32:         tmpObjectPrefix string,
    33:         bucket gcs.Bucket) (objectsDeleted uint64, err error) {
    34:         const stalenessThreshold = 30 * time.Minute
    35:         b := syncutil.NewBundle(ctx)
    36:
    37:         // List all objects with the temporary prefix.
    38:         objects := make(chan *gcs.Object, 100)
    39:         b.Add(func(ctx context.Context) (err error) {
    40:                 defer close(objects)
=>  41:                 err = storageutil.ListPrefix(ctx, bucket, tmpObjectPrefix, objects)
    42:                 if err != nil {
    43:                         err = fmt.Errorf("ListPrefix: %w", err)
    44:                         return
    45:                 }
    46:
    47:                 return
    48:         })
    49:
    50:         // Filter to the names of objects that are stale.
    51:         now := time.Now()
    52:         staleNames := make(chan string, 100)
    53:         b.Add(func(ctx context.Context) (err error) {
    54:                 defer close(staleNames)
    55:                 for o := range objects {
    56:                         if now.Sub(o.Updated) < stalenessThreshold {
    57:                                 continue
    58:                         }
    59:
    60:                         select {
    61:                         case <-ctx.Done():
(dlv) frame 0
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(529):1 total:1) (PC: 0x1919d38)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2030):1 total:39) (PC: 0x18c1f48)
Frame 0: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (PC: 18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000b503c0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {
        Prefix: ".gcsfuse_tmp/",
        Delimiter: "",
        IncludeTrailingDelimiter: false,
        IncludeFoldersAsPrefixes: false,
        ContinuationToken: "",
        MaxResults: 0,
        ProjectionVal: Full (0),}
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(2688):1 total:7) (PC: 0x193b036)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? s
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446804,0x446724,0x45f40e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (7)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (53)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (27)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (39)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (107)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (30)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (6)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (6)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (6)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (6)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (6)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (6)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (6)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (2)
Breakpoint 17 (enabled) at 0x1917dea for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (1)
Breakpoint 18 (enabled) at 0x1919d38 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (1)
Breakpoint 19 (enabled) at 0x1919920 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (0)
        cond p == "a//"
(dlv) {nt 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/sto^C
(dlv) bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel "xclip -selection clipboard -i"
Command failed: command not available
(dlv) bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel "xclip -selection clipboard -i"^C
(dlv) buffer38: 122 bytes: "/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314"^C
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446724,0x45f40e,0x446804 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (7)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (53)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (27)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (39)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (107)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (30)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (6)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (6)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (6)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (6)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (6)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (6)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (6)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (2)
Breakpoint 17 (enabled) at 0x1917dea for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (1)
Breakpoint 18 (enabled) at 0x1919d38 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (1)
Breakpoint 19 (enabled) at 0x1919920 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (0)
        cond p == "a//"
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(2688):1 total:7) (PC: 0x193b036)
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1317 (PC: 0x193b066)
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
=>1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1325 (PC: 0x193b172)
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
=>1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2721):1 total:40) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1326 (PC: 0x193b18f)
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
=>1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1327 (PC: 0x193b1c1)
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
=>1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
(dlv) bt
0  0x000000000193b1c1 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1327
1  0x000000000192a1a6 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126
2  0x000000000192edab in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156
3  0x0000000001911d44 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144
4  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
5  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330 (PC: 0x193b1de)
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
=>1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.LookUpInodeOp")(0xc00091c5a0)
*github.com/jacobsa/fuse/fuseops.LookUpInodeOp {
        Parent: 1,
        Name: "a",
        Entry: github.com/jacobsa/fuse/fuseops.ChildInodeEntry {
                Child: 0,
                Generation: 0,
                Attributes: (*"github.com/jacobsa/fuse/fuseops.InodeAttributes")(0xc00091c5c8),
                AttributesExpiration: (*time.Time)(0xc00091c648),
                EntryExpiration: (*time.Time)(0xc00091c660),},
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 4656, Pid: 3679465, Uid: 1012083},}
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(2213):1 total:28) (PC: 0x1944a73)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:911 (PC: 0x1937f76)
   891:                 // Replace it with a newly-mintend inode and then go around, acquiring its
   892:                 // lock in accordance with our lock ordering rules.
   893:                 existingInode.Unlock()
   894:
   895:                 in = fs.mintInode(ic)
   896:                 fs.generationBackedInodes[in.Name()] = in.(inode.GenerationBackedInode)
   897:
   898:                 continue
   899:         }
   900: }
   901:
   902: // Look up the child with the given name within the parent, then return an
   903: // existing inode for that child or create a new one if necessary. Return
   904: // ENOENT if the child doesn't exist.
   905: //
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
=> 911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
(dlv) n 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:916 (PC: 0x1937fc1)
   896:                 fs.generationBackedInodes[in.Name()] = in.(inode.GenerationBackedInode)
   897:
   898:                 continue
   899:         }
   900: }
   901:
   902: // Look up the child with the given name within the parent, then return an
   903: // existing inode for that child or create a new one if necessary. Return
   904: // ENOENT if the child doesn't exist.
   905: //
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
=> 916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
(dlv) bt
0  0x0000000001937fc1 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:916
1  0x000000000193b23f in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330
2  0x000000000192a1a6 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126
3  0x000000000192edab in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156
4  0x0000000001911d44 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144
5  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
6  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:917 (PC: 0x1937ff8)
   897:
   898:                 continue
   899:         }
   900: }
   901:
   902: // Look up the child with the given name within the parent, then return an
   903: // existing inode for that child or create a new one if necessary. Return
   904: // ENOENT if the child doesn't exist.
   905: //
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
=> 917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:926 (PC: 0x1938012)
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
=> 926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
(dlv) p child
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Inode nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:934 (PC: 0x1938114)
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
=> 934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:936 (PC: 0x193812c)
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
=> 936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:937 (PC: 0x1938135)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
=> 937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:926 (PC: 0x1938556)
   906: // Return the child locked, incrementing its lookup count.
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
=> 926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:927 (PC: 0x19385ae)
   907: //
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
=> 927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:928 (PC: 0x19385c3)
   908: // LOCKS_EXCLUDED(fs.mu)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
=> 928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(2688):1 total:7) (PC: 0x193866a)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(2688):1 total:7) (PC: 0x1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:439 (PC: 0x19175d4)
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
=> 439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:443 (PC: 0x19176c4)
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
=> 443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:444 (PC: 0x19176fa)
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
=> 444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:445 (PC: 0x1917731)
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
=> 445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:449 (PC: 0x191780d)
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
=> 449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:453 (PC: 0x19178e8)
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
   437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
=> 453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:458 (PC: 0x19179c5)
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
=> 458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:460 (PC: 0x19179e2)
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
=> 460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:461 (PC: 0x1917a68)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
=> 461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:470 (PC: 0x1917a71)
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
=> 470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:474 (PC: 0x1917a78)
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
=> 474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:475 (PC: 0x1917a82)
   455:                 return
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
=> 475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(2700):1 total:7) (PC: 0x1918397)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:476 (PC: 0x1917a97)
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
=> 476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:477 (PC: 0x1917aa9)
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
=> 477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(2701):1 total:7) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:476 (PC: 0x1917ad4)
   456:         }
   457:
   458:         b := syncutil.NewBundle(ctx)
   459:
   460:         cachedType := d.cache.Get(d.cacheClock.Now(), name)
   461:         switch cachedType {
   462:         case metadata.ImplicitDirType:
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
=> 476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(2701):1 total:7) (PC: 0x1916836)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:483 (PC: 0x1917d44)
   463:                 dirResult = &Core{
   464:                         Bucket:    d.Bucket(),
   465:                         FullName:  NewDirName(d.Name(), name),
   466:                         MinObject: nil,
   467:                 }
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
=> 483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(2701):1 total:7) (PC: 0x19169a5)
        breakpoint hit during next
[c] continue [s] stop here and cancel next, [f] finish next skipping all breakpoints? c
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2701):1 total:42) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2777):1 total:42) (PC: 0x18c1f48)
        breakpoint hit during next
[c] continue [s] stop here and cancel next, [f] finish next skipping all breakpoints? s
   315:         }
   316:
   317:         return &Core{
   318:                 Bucket:    bucket,
   319:                 FullName:  name,
   320:                 MinObject: m,
   321:         }, nil
   322: }
   323:
   324: // findDirInode finds the dir inode core where the directory is either explicit
   325: // or implicit. Returns nil if no such directory exists.
   326: func findDirInode(ctx context.Context, bucket *gcsx.SyncerBucket, name Name) (*Core, error) {
   327:         if !name.IsDir() {
   328:                 return nil, fmt.Errorf("%q is not directory", name)
   329:         }
   330:
   331:         req := &gcs.ListObjectsRequest{
   332:                 Prefix:     name.GcsObjectName(),
   333:                 MaxResults: 1,
   334:         }
=> 335:         listing, err := bucket.ListObjects(ctx, req)
   336:         if err != nil {
   337:                 return nil, fmt.Errorf("list objects: %w", err)
   338:         }
   339:
   340:         if len(listing.Objects) == 0 {
   341:                 return nil, nil
   342:         }
   343:
   344:         result := &Core{
   345:                 Bucket:   bucket,
   346:                 FullName: name,
   347:         }
   348:         if o := listing.Objects[0]; o.Name == name.GcsObjectName() {
   349:                 result.MinObject = storageutil.ConvertObjToMinObject(o)
   350:         }
   351:         return result, nil
   352: }
   353:
   354: // Fail if the name already exists. Pass on errors directly.
   355: func (d *dirInode) createNewObject(
(dlv) p name
Command failed: could not find symbol value for name
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc002086e60)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {
        Prefix: ".gcsfuse_tmp/",
        Delimiter: "",
        IncludeTrailingDelimiter: false,
        IncludeFoldersAsPrefixes: false,
        ContinuationToken: "",
        MaxResults: 0,
        ProjectionVal: Full (0),}
(dlv) so   
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(1824):1 total:8) (PC: 0x193b036)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? f
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(1824):1 total:8) (PC: 0x193866a)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(1824):1 total:8) (PC: 0x1917596)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(2914):1 total:8) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(2913):1 total:8) (PC: 0x1918397)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(2914):1 total:8) (PC: 0x1916836)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(2914):1 total:8) (PC: 0x19169a5)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2914):1 total:43) (PC: 0x18c1f48)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(2914):1 total:31) (PC: 0x18c22cc)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
Values returned:
        listing: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000d8eec0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 0, cap: 0, nil,
                CollapsedRuns: []string len: 0, cap: 0, nil,
                ContinuationToken: "",}
        err: error nil

   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc002086e60)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {
        Prefix: ".gcsfuse_tmp/",
        Delimiter: "",
        IncludeTrailingDelimiter: false,
        IncludeFoldersAsPrefixes: false,
        ContinuationToken: "",
        MaxResults: 0,
        ProjectionVal: Full (0),}
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(1824):1 total:7) (PC: 0x1917da2)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ListPrefix() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/storageutil/list_prefix.go:39 (PC: 0xfff892)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000d8eec0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 0, cap: 0, nil,
                CollapsedRuns: []string len: 0, cap: 0, nil,
                ContinuationToken: "",}
        ~r1: error nil

    19:
    20:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs"
    21:         "golang.org/x/net/context"
    22: )
    23:
    24: // List objects in the supplied bucket whose name starts with the given prefix.
    25: // Write them into the supplied channel in an undefined order.
    26: func ListPrefix(
    27:         ctx context.Context,
    28:         bucket gcs.Bucket,
    29:         prefix string,
    30:         objects chan<- *gcs.Object) (err error) {
    31:         req := &gcs.ListObjectsRequest{
    32:                 Prefix: prefix,
    33:         }
    34:
    35:         // List until we run out.
    36:         for {
    37:                 // Fetch the next batch.
    38:                 var listing *gcs.Listing
=>  39:                 listing, err = bucket.ListObjects(ctx, req)
    40:                 if err != nil {
    41:                         err = fmt.Errorf("ListObjects: %v", err)
    42:                         return
    43:                 }
    44:
    45:                 // Pass on each object.
    46:                 for _, o := range listing.Objects {
    47:                         select {
    48:                         case objects <- o:
    49:
    50:                                 // Cancelled?
    51:                         case <-ctx.Done():
    52:                                 err = ctx.Err()
    53:                                 return
    54:                         }
    55:                 }
    56:
    57:                 // Are we done?
    58:                 if listing.ContinuationToken == "" {
    59:                         break
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (hits goroutine(1824):1 total:2) (PC: 0x1917dea)
> github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.garbageCollectOnce.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/gcsx/garbage_collect.go:41 (PC: 0x18fed76)
Values returned:
        err: error nil

    21:
    22:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs"
    23:         "github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil"
    24:         "golang.org/x/net/context"
    25:
    26:         "github.com/googlecloudplatform/gcsfuse/v2/internal/logger"
    27:         "github.com/jacobsa/syncutil"
    28: )
    29:
    30: func garbageCollectOnce(
    31:         ctx context.Context,
    32:         tmpObjectPrefix string,
    33:         bucket gcs.Bucket) (objectsDeleted uint64, err error) {
    34:         const stalenessThreshold = 30 * time.Minute
    35:         b := syncutil.NewBundle(ctx)
    36:
    37:         // List all objects with the temporary prefix.
    38:         objects := make(chan *gcs.Object, 100)
    39:         b.Add(func(ctx context.Context) (err error) {
    40:                 defer close(objects)
=>  41:                 err = storageutil.ListPrefix(ctx, bucket, tmpObjectPrefix, objects)
    42:                 if err != nil {
    43:                         err = fmt.Errorf("ListPrefix: %w", err)
    44:                         return
    45:                 }
    46:
    47:                 return
    48:         })
    49:
    50:         // Filter to the names of objects that are stale.
    51:         now := time.Now()
    52:         staleNames := make(chan string, 100)
    53:         b.Add(func(ctx context.Context) (err error) {
    54:                 defer close(staleNames)
    55:                 for o := range objects {
    56:                         if now.Sub(o.Updated) < stalenessThreshold {
    57:                                 continue
    58:                         }
    59:
    60:                         select {
    61:                         case <-ctx.Done():
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (hits goroutine(1824):1 total:3) (PC: 0x193b43f)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? f
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(2966):1 total:54) (PC: 0x1944d76)
> github.com/jacobsa/syncutil.(*Bundle).Add.func1() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89 (PC: 0xed4a31)
Values returned:
        err: error nil

    69: type Bundle struct {
    70:         context context.Context
    71:         cancel  context.CancelFunc
    72:
    73:         waitGroup sync.WaitGroup
    74:
    75:         errorOnce  sync.Once
    76:         firstError error
    77: }
    78:
    79: // Add a new operation to the bundle. The operation will be invoked with a
    80: // context that will be cancelled if any other operation fails or has already
    81: // failed.
    82: func (b *Bundle) Add(f func(context.Context) error) {
    83:         b.waitGroup.Add(1)
    84:
    85:         // Run the function in the background.
    86:         go func() {
    87:                 defer b.waitGroup.Done()
    88:
=>  89:                 err := f(b.context)
    90:                 if err == nil {
    91:                         return
    92:                 }
    93:
    94:                 // On first error, cancel the context and save the error.
    95:                 b.errorOnce.Do(func() {
    96:                         b.firstError = err
    97:                         b.cancel()
    98:                 })
    99:         }()
   100: }
   101:
   102: // Wait for all previously-added operations to complete. Return nil if all
   103: // operations succeeded. Otherwise return the first error.
   104: //
   105: // Add must not be called concurrently with or after Join.
   106: func (b *Bundle) Join() error {
   107:         b.waitGroup.Wait()
   108:
   109:         // context.WithCancel requires that we arrange for this to be called
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2966):1 total:44) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(2967):1 total:9) (PC: 0x193b036)
  1294:         // Simulate a large amount of free space so that the Finder doesn't refuse to
  1295:         // copy in files. (See issue #125.) Use 2^17 as the block size because that
  1296:         // is the largest that OS X will pass on.
  1297:         op.BlockSize = 1 << 17
  1298:         op.Blocks = 1 << 33
  1299:         op.BlocksFree = op.Blocks
  1300:         op.BlocksAvailable = op.Blocks
  1301:
  1302:         // Similarly with inodes.
  1303:         op.Inodes = 1 << 50
  1304:         op.InodesFree = op.Inodes
  1305:
  1306:         // Prefer large transfers. This is the largest value that OS X will
  1307:         // faithfully pass on, according to fuseops/ops.go.
  1308:         op.IoSize = 1 << 20
  1309:
  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
=>1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.LookUpInodeOp")(0xc007bee1e0)
*github.com/jacobsa/fuse/fuseops.LookUpInodeOp {
        Parent: 2,
        Name: "13",
        Entry: github.com/jacobsa/fuse/fuseops.ChildInodeEntry {
                Child: 0,
                Generation: 0,
                Attributes: (*"github.com/jacobsa/fuse/fuseops.InodeAttributes")(0xc007bee208),
                AttributesExpiration: (*time.Time)(0xc007bee288),
                EntryExpiration: (*time.Time)(0xc007bee2a0),},
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 4910, Pid: 3679465, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(2967):1 total:9) (PC: 0x193866a)
   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(2967):1 total:9) (PC: 0x1917596)
   417:         // Set up basic attributes.
   418:         attrs = d.attrs
   419:         attrs.Nlink = 1
   420:
   421:         return
   422: }
   423:
   424: func (d *dirInode) Bucket() *gcsx.SyncerBucket {
   425:         return d.bucket
   426: }
   427:
   428: // A suffix that can be used to unambiguously tag a file system name.
   429: // (Unambiguous because U+000A is not allowed in GCS object names.) This is
   430: // used to refer to the file/symlink in a (file/symlink, directory) pair with
   431: // conflicting object names.
   432: //
   433: // See also the notes on DirInode.LookUpChild.
   434: const ConflictingFileNameSuffix = "\n"
   435:
   436: // LOCKS_REQUIRED(d)
=> 437: func (d *dirInode) LookUpChild(ctx context.Context, name string) (*Core, error) {
   438:         // Is this a conflict marker name?
   439:         if strings.HasSuffix(name, ConflictingFileNameSuffix) {
   440:                 return d.lookUpConflicting(ctx, name)
   441:         }
   442:
   443:         var fileResult *Core
   444:         var dirResult *Core
   445:         lookUpFile := func(ctx context.Context) (err error) {
   446:                 fileResult, err = findExplicitInode(ctx, d.Bucket(), NewFileName(d.Name(), name))
   447:                 return
   448:         }
   449:         lookUpExplicitDir := func(ctx context.Context) (err error) {
   450:                 dirResult, err = findExplicitInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   451:                 return
   452:         }
   453:         lookUpImplicitOrExplicitDir := func(ctx context.Context) (err error) {
   454:                 dirResult, err = findDirInode(ctx, d.Bucket(), NewDirName(d.Name(), name))
   455:                 return
   456:         }
   457:
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(1943):1 total:9) (PC: 0x1918397)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(1944):1 total:9) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(2966):1 total:32) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) p attr
Command failed: could not find symbol value for attr
(dlv) p attrs
("*cloud.google.com/go/storage.ObjectAttrs")(0xc007bfc000)
*cloud.google.com/go/storage.ObjectAttrs {
        Bucket: "gargnitin-test-empty-dirname-asia-se1",
        Name: "14",
        ContentType: "text/plain",
        ContentLanguage: "",
        CacheControl: "",
        EventBasedHold: false,
        TemporaryHold: false,
        RetentionExpirationTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ACL: []cloud.google.com/go/storage.ACLRule len: 0, cap: 0, nil,
        PredefinedACL: "",
        Owner: "",
        Size: 6,
        ContentEncoding: "",
        ContentDisposition: "",
        MD5: []uint8 len: 16, cap: 18, [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
        CRC32C: 893245630,
        MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+69 more",
        Metadata: map[string]string nil,
        Generation: 1714642904966145,
        Metageneration: 1,
        StorageClass: "STANDARD",
        Created: time.Time(2024-05-02T09:41:44Z){
                wall: 980000000,
                ext: 63850239704,
                loc: *time.Location nil,},
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(2024-05-02T09:41:44Z){
                wall: 980000000,
                ext: 63850239704,
                loc: *time.Location nil,},
        CustomerKeySHA256: "",
        KMSKeyName: "",
        Prefix: "",
        Etag: "CIHIkcrW7oUDEAE=",
        CustomTime: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        ComponentCount: 0,
        Retention: *cloud.google.com/go/storage.ObjectRetention nil,}
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc00758c1e0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "", Delimiter: "/", IncludeTrailingDelimiter: true, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 5000, ProjectionVal: NoAcl (1)}
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(1944):1 total:9) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(1943):1 total:9) (PC: 0x1918397)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(2966):1 total:32) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(1944):1 total:9) (PC: 0x1916836)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:285 (PC: 0x18c22e1)
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
=> 285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(1944):1 total:9) (PC: 0x19169a5)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c2432)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2966):1 total:108) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c2432)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2966):2 total:109) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c2432)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2966):3 total:110) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:265 (PC: 0x18c2432)
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
=> 265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:267 (PC: 0x18c1feb)
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
=> 267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:268 (PC: 0x18c2082)
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
=> 268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:272 (PC: 0x18c20b1)
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
=> 272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:280 (PC: 0x18c21d7)
   260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
=> 280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2966):4 total:111) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:295 (PC: 0x18c237f)
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
=> 295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
(dlv) p list
github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0),
        ],
        CollapsedRuns: []string len: 4, cap: 4, ["../","./","/","a/"],
        ContinuationToken: "",}
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc00758c1e0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "", Delimiter: "/", IncludeTrailingDelimiter: true, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 5000, ProjectionVal: NoAcl (1)}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:296 (PC: 0x18c23c0)
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
=> 296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:300 (PC: 0x18c23c2)
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
=> 300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:301 (PC: 0x18c240c)
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
=> 301:         listing = &list
   302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
   321:
(dlv) so  
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(1944):1 total:45) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
Values returned:
        listing: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc00025c7c0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0),
                ],
                CollapsedRuns: []string len: 4, cap: 4, ["../","./","/","a/"],
                ContinuationToken: "",}
        err: error nil

   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(1944):1 total:45) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:559 (PC: 0x1918f13)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc00025c7c0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0),
                ],
                CollapsedRuns: []string len: 4, cap: 4, ["../","./","/","a/"],
                ContinuationToken: "",}
        ~r1: error nil

   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
=> 559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(2967):1 total:8) (PC: 0x1917da2)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:560 (PC: 0x1918f8b)
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
=> 560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (hits goroutine(2967):1 total:3) (PC: 0x1917dea)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:565 (PC: 0x19190cb)
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
=> 565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (hits goroutine(2967):1 total:4) (PC: 0x193b43f)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:566 (PC: 0x19190d8)
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
=> 566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:573 (PC: 0x1919186)
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
=> 573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:575 (PC: 0x1919235)
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
=> 575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:579 (PC: 0x19192f2)
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
=> 579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:584 (PC: 0x1919328)
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
=> 584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:593 (PC: 0x19195c5)
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
=> 593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:595 (PC: 0x1919627)
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
=> 595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
(dlv) n 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:597 (PC: 0x191963c)
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
=> 597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x1919651)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:595 (PC: 0x19196b0)
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
=> 595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x19196dc)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) stack -full
 0  0x00000000019196dc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core []
        newTok = ""
        err = error nil
        req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc00758c1e0)
        listing = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc00025c7c0)
        o = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0)
        nameBase = "14"
        fileName = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "14"}

 1  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        newTok = ""
        err = error nil
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

 2  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
        ctx = (unreadable invalid interface type)
        in = (unreadable invalid interface type)
        localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        tok = ""
        batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 3  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 4  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil

 5  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        err = error nil
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        in = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 6  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
        em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil

 7  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil
        startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}
Sending output to pager...
 0  0x00000000019196dc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core []
        newTok = ""
        err = error nil
        req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc00758c1e0)
        listing = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc00025c7c0)
        o = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0)
        nameBase = "14"
        fileName = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "14"}

 1  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        newTok = ""
        err = error nil
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

 2  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
        ctx = (unreadable invalid interface type)
        in = (unreadable invalid interface type)
        localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        tok = ""
        batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 3  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 4  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil

 5  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        err = error nil
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        in = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 6  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
        em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil

 7  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil
(dlv) stack -offsets
 0  0x00000000019196dc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594
    frame: -0xbd8 frame pointer -0xbe8

 1  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
    frame: -0x9b8 frame pointer -0x9c8

 2  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
    frame: -0x7a0 frame pointer -0x7b0

 3  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
    frame: -0x628 frame pointer -0x638

 4  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
    frame: -0x560 frame pointer -0x570

 5  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
    frame: -0x3e0 frame pointer -0x3f0

 6  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
    frame: -0x328 frame pointer -0x338

 7  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
    frame: -0x298 frame pointer -0x2a8

 8  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
    frame: -0x90 frame pointer -0xa0

 9  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
    frame: -0x20 frame pointer -0x30

10  0x00000000004817c1 in runtime.goexit
    at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
    frame: -0x18 frame pointer -0xc007b90000

(dlv) stack -defer  
 0  0x00000000019196dc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594
        defer 1: 0x0000000001919ce0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:566
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:566

 1  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632

 2  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172

 3  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
        defer 1: 0x0000000001928000 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:241
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:241

 4  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283

 5  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
        defer 1: 0x00000000019451a0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir.deferwrap1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2168
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2168

 6  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
        defer 1: 0x00000000019299a0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).handlePanic
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:90
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:250

 7  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282

 8  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
        defer 1: 0x00000000004bc0e0 in sync.(*WaitGroup).Done
                 at /usr/lib/google-golang/src/sync/waitgroup.go:86
                 deferred by github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:132

 9  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

10  0x00000000004817c1 in runtime.goexit
    at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695

(dlv) stack -defer -full
 0  0x00000000019196dc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594
        defer 1: 0x0000000001919ce0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:566
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:566
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core []
        newTok = ""
        err = error nil
        req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc00758c1e0)
        listing = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc00025c7c0)
        o = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0)
        nameBase = "14"
        fileName = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "14"}

 1  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        newTok = ""
        err = error nil
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

 2  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
        ctx = (unreadable invalid interface type)
        in = (unreadable invalid interface type)
        localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        tok = ""
        batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 3  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
        defer 1: 0x0000000001928000 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:241
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:241
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 4  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil

 5  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
        defer 1: 0x00000000019451a0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir.deferwrap1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2168
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2168
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        err = error nil
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        in = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 6  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
Sending output to pager...
 0  0x00000000019196dc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594
        defer 1: 0x0000000001919ce0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:566
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects at /usr/local/google/home/gargnitin/work/cloud/st
orage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:566
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core []
        newTok = ""
        err = error nil
        req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc00758c1e0)
        listing = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc00025c7c0)
        o = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0)
        nameBase = "14"
        fileName = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "14"}

 1  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        newTok = ""
        err = error nil
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

 2  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
        ctx = (unreadable invalid interface type)
        in = (unreadable invalid interface type)
        localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        tok = ""
        batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 3  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
        defer 1: 0x0000000001928000 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:241
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries at /usr/local/google/home/gargnitin/work/clou
d/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:241
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 4  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil

 5  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
        defer 1: 0x00000000019451a0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir.deferwrap1
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2168
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir at /usr/local/google/home/gargnitin/work/cloud/storage/cl
ient/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2168
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        err = error nil
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        in = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 6  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
        defer 1: 0x00000000019299a0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).handlePanic
                 at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:90
                 deferred by github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir at /usr/local/google/home/gargnitin/work/cloud
/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:250
        em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil

 7  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil
        startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}

 8  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
        defer 1: 0x00000000004bc0e0 in sync.(*WaitGroup).Done
                 at /usr/lib/google-golang/src/sync/waitgroup.go:86
                 deferred by github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@
v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:132
        s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
        c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
        ctx = (unreadable invalid interface type)
        op = interface {}(*github.com/jacobsa/fuse/fuseops.ReadDirOp) 0xc007b8ff98
        err = error nil
        typed = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)

 9  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

10  0x00000000004817c1 in runtime.goexit
    at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695

(dlv) stack -adepth 1 -full
 0  0x00000000019196dc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core []
        newTok = ""
        err = error nil
        req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc00758c1e0)
        listing = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc00025c7c0)
        o = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0)
        nameBase = "14"
        fileName = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "14"}

 1  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        newTok = ""
        err = error nil
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

 2  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
        ctx = (unreadable invalid interface type)
        in = (unreadable invalid interface type)
        localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        tok = ""
        batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 3  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 4  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil

 5  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        err = error nil
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        in = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 6  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
        em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil

 7  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil
        startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}
Sending output to pager...
 0  0x00000000019196dc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core []
        newTok = ""
        err = error nil
        req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc00758c1e0)
        listing = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc00025c7c0)
        o = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0)
        nameBase = "14"
        fileName = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "14"}

 1  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
        d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
        ctx = (unreadable invalid interface type)
        tok = ""
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        newTok = ""
        err = error nil
        cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

 2  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
        ctx = (unreadable invalid interface type)
        in = (unreadable invalid interface type)
        localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        tok = ""
        batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 3  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil
        entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 4  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err = error nil

 5  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        err = error nil
        dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
        in = (unreadable invalid interface type)
        localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

 6  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
        em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil

 7  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
        fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
        ctx = (unreadable invalid interface type)
        op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
        ~r0 = error nil
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x19196dc)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) p o
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00023a8c0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object {
        Name: "14",
        ContentType: "text/plain",
        ContentLanguage: "",
        CacheControl: "",
        Owner: "",
        Size: 6,
        ContentEncoding: "",
        MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
        CRC32C: *893245630,
        MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+69 more",
        Metadata: map[string]string nil,
        Generation: 1714642904966145,
        MetaGeneration: 1,
        StorageClass: "STANDARD",
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(2024-05-02T09:41:44Z){
                wall: 980000000,
                ext: 63850239704,
                loc: *time.Location nil,},
        ComponentCount: 0,
        ContentDisposition: "",
        CustomTime: "0001-01-01T00:00:00Z",
        EventBasedHold: false,
        Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:596 (PC: 0x19196e6)
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
=> 596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x1919744)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:597 (PC: 0x191974e)
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
=> 597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:594 (PC: 0x191977a)
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
=> 594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:599 (PC: 0x191978a)
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
=> 599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:573 (PC: 0x191981e)
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
=> 573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:604 (PC: 0x191982b)
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
=> 604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:606 (PC: 0x191984d)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
=> 606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x191985f)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) p newTok
""
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (hits total:0) (PC: 0x1919920)
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
=> 612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
(dlv) p p
"../"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:613 (PC: 0x1919935)
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
=> 613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
(dlv) p pathBase
".."
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:614 (PC: 0x191999a)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
=> 614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
(dlv) p dirName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "../"}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919a69)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919a7e)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919adf)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b0a)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:620 (PC: 0x1919b14)
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
=> 620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b6d)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:621 (PC: 0x1919b77)
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
=> 621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b9c)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1919bac)
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
=> 623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x1919c3d)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core [
        {bucketName: "", objectName: "14"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000d9a540),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc007b320c0),
                Local: false,}, 
        {bucketName: "", objectName: "../"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000958000),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (hits total:0) (PC: 0x1919920)
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
=> 612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:613 (PC: 0x1919935)
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
=> 613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
(dlv) p p
"./"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:614 (PC: 0x191999a)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
=> 614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919a69)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919a7e)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919adf)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b0a)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:620 (PC: 0x1919b14)
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
=> 620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b6d)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:621 (PC: 0x1919b77)
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
=> 621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b9c)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1919bac)
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
=> 623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x1919c3d)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (hits total:0) (PC: 0x1919920)
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
=> 612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:613 (PC: 0x1919935)
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
=> 613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
(dlv) p p
"/"
(dlv) p pathBase
"/"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:614 (PC: 0x191999a)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
=> 614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919a69)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919a7e)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919adf)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b0a)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:620 (PC: 0x1919b14)
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
=> 620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b6d)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:621 (PC: 0x1919b77)
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
=> 621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b9c)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1919bac)
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
=> 623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x1919c3d)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (hits total:0) (PC: 0x1919920)
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
=> 612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core [
        {bucketName: "", objectName: "14"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000d9a540),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc007b320c0),
                Local: false,}, 
        {bucketName: "", objectName: "../"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000958000),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
        {bucketName: "", objectName: "./"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0009580c0),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
        {bucketName: "", objectName: "/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000958100),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:613 (PC: 0x1919935)
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
=> 613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:614 (PC: 0x191999a)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
=> 614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919a69)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919a7e)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:619 (PC: 0x1919adf)
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
=> 619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b0a)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:620 (PC: 0x1919b14)
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
=> 620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b6d)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:621 (PC: 0x1919b77)
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
=> 621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:618 (PC: 0x1919b9c)
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
=> 618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1919bac)
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
=> 623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:611 (PC: 0x1919c3d)
   591:                         cores[dirName] = explicitDir
   592:                 } else {
   593:                         fileName := NewFileName(d.Name(), nameBase)
   594:                         file := &Core{
   595:                                 Bucket:    d.Bucket(),
   596:                                 FullName:  fileName,
   597:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   598:                         }
   599:                         cores[fileName] = file
   600:                 }
   601:         }
   602:
   603:         // Return an appropriate continuation token, if any.
   604:         newTok = listing.ContinuationToken
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
=> 611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:625 (PC: 0x1919c58)
   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
=> 625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core [
        {bucketName: "", objectName: "14"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000d9a540),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc007b320c0),
                Local: false,}, 
        {bucketName: "", objectName: "../"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000958000),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
        {bucketName: "", objectName: "./"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0009580c0),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
        {bucketName: "", objectName: "/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000958100),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
        {bucketName: "", objectName: "a/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0009581c0),
                Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}, 
]
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(2966):1 total:2) (PC: 0x1919d38)
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
=> 568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:569 (PC: 0x1919de7)
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
=> 569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (PC: 0x1919e8d)
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
=> 568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2744):1 total:46) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:569 (PC: 0x1919de7)
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
=> 569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (PC: 0x1919e8d)
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
=> 568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:569 (PC: 0x1919de7)
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
=> 569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (PC: 0x1919e8d)
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
=> 568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:569 (PC: 0x1919de7)
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
=> 569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (PC: 0x1919e8d)
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
=> 568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:569 (PC: 0x1919de7)
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
=> 569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (PC: 0x1919e8d)
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
=> 568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:571 (PC: 0x1919e9f)
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
=> 571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
   589:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   590:                         }
   591:                         cores[dirName] = explicitDir
(dlv) p d.cache
(unreadable invalid interface type)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:625 (PC: 0x1919c5d)
Values returned:

   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
=> 625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632 (PC: 0x1919f85)
Values returned:
        cores: map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core [
                {bucketName: "", objectName: "14"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000d9a540),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc007b320c0),
                        Local: false,}, 
                {bucketName: "", objectName: "../"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000958000),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                        Local: false,}, 
                {bucketName: "", objectName: "./"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0009580c0),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                        Local: false,}, 
                {bucketName: "", objectName: "/"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000958100),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                        Local: false,}, 
                {bucketName: "", objectName: "a/"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0009581c0),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                        Local: false,}, 
        ]
        newTok: ""
        err: error nil

   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
=> 632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
(dlv) bt
0  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
9  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) bt -full
0  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
       d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
       ctx = (unreadable invalid interface type)
       tok = ""
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       newTok = ""
       err = error nil
       cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
       ctx = (unreadable invalid interface type)
       in = (unreadable invalid interface type)
       localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       tok = ""
       batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil

4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       err = error nil
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       in = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
       em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil

6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil
       startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}

7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
       s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
       c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
       ctx = (unreadable invalid interface type)
       op = interface {}(*github.com/jacobsa/fuse/fuseops.ReadDirOp) 0xc007b8ff98
       err = error nil
       typed = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)

8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

9  0x00000000004817c1 in runtime.goexit
Sending output to pager...
0  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
       d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
       ctx = (unreadable invalid interface type)
       tok = ""
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       newTok = ""
       err = error nil
       cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
       ctx = (unreadable invalid interface type)
       in = (unreadable invalid interface type)
       localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       tok = ""
       batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil

4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       err = error nil
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       in = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
       em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil

6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil
       startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}

7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
       s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
       c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
       ctx = (unreadable invalid interface type)
       op = interface {}(*github.com/jacobsa/fuse/fuseops.ReadDirOp) 0xc007b8ff98
       err = error nil
       typed = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)

8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

(dlv) bt -full -14
Command failed: negative maximum stack depth
(dlv) bt -full -a 4
0  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
       d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
       ctx = (unreadable invalid interface type)
       tok = ""
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       newTok = ""
       err = error nil
       cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
       ctx = (unreadable invalid interface type)
       in = (unreadable invalid interface type)
       localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       tok = ""
       batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil

4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       err = error nil
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       in = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
       em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil

6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil
       startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}

7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
       s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
       c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
       ctx = (unreadable invalid interface type)
       op = interface {}(*github.com/jacobsa/fuse/fuseops.ReadDirOp) 0xc007b8ff98
       err = error nil
       typed = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)

8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

9  0x00000000004817c1 in runtime.goexit
Sending output to pager...
0  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
       d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
       ctx = (unreadable invalid interface type)
       tok = ""
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       newTok = ""
       err = error nil
       cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
       ctx = (unreadable invalid interface type)
       in = (unreadable invalid interface type)
       localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       tok = ""
       batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil

4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       err = error nil
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       in = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
       em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil

6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil
       startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}

7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
       s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
       c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
       ctx = (unreadable invalid interface type)
       op = interface {}(*github.com/jacobsa/fuse/fuseops.ReadDirOp) 0xc007b8ff98
       err = error nil
       typed = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)

8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

--More--Command failed: tracebackancestors is disabled
(dlv) bt -full -a=4
Command failed: depth must be a number
(dlv) bt -full -a 4
0  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
       d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
       ctx = (unreadable invalid interface type)
       tok = ""
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       newTok = ""
       err = error nil
       cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
       ctx = (unreadable invalid interface type)
       in = (unreadable invalid interface type)
       localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       tok = ""
       batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil

4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       err = error nil
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       in = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
       em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil

6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil
       startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}

7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
       s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
       c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
       ctx = (unreadable invalid interface type)
       op = interface {}(*github.com/jacobsa/fuse/fuseops.ReadDirOp) 0xc007b8ff98
       err = error nil
       typed = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)

8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

9  0x00000000004817c1 in runtime.goexit
Sending output to pager...
0  0x0000000001919f85 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632
       d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
       ctx = (unreadable invalid interface type)
       tok = ""
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       newTok = ""
       err = error nil
       cores = map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

1  0x000000000192746b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172
       ctx = (unreadable invalid interface type)
       in = (unreadable invalid interface type)
       localEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       tok = ""
       batch = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

2  0x0000000001927d53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil
       entries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

3  0x000000000192815b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
       err = error nil

4  0x00000000019450bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       err = error nil
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       in = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

5  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
       em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil

6  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil
       startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}

7  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
       s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
       c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
       ctx = (unreadable invalid interface type)
       op = interface {}(*github.com/jacobsa/fuse/fuseops.ReadDirOp) 0xc007b8ff98
       err = error nil
       typed = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)

8  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

--More--Command failed: tracebackancestors is disabled
9  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695

(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632 (PC: 0x1919f85)
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
=> 632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:633 (PC: 0x191a047)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
=> 633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:638 (PC: 0x191a184)
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
=> 638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:640 (PC: 0x191a230)
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
=> 640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   660:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:639 (PC: 0x191a277)
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
=> 639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:640 (PC: 0x191a292)
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
=> 640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   660:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:643 (PC: 0x191a2b2)
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
=> 643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   660:         }
   661:         fullName := NewFileName(d.Name(), name)
   662:
   663:         o, err := d.createNewObject(ctx, fullName, childMetadata)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:644 (PC: 0x191a2c9)
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
=> 644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   660:         }
   661:         fullName := NewFileName(d.Name(), name)
   662:
   663:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   664:         if err != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:646 (PC: 0x191a2e2)
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
=> 646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   660:         }
   661:         fullName := NewFileName(d.Name(), name)
   662:
   663:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   664:         if err != nil {
   665:                 return nil, err
   666:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:648 (PC: 0x191a2f9)
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
=> 648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   660:         }
   661:         fullName := NewFileName(d.Name(), name)
   662:
   663:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   664:         if err != nil {
   665:                 return nil, err
   666:         }
   667:         m := storageutil.ConvertObjToMinObject(o)
   668:
(dlv) p core
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000958000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "../"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:649 (PC: 0x191a30c)
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
=> 649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   660:         }
   661:         fullName := NewFileName(d.Name(), name)
   662:
   663:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   664:         if err != nil {
   665:                 return nil, err
   666:         }
   667:         m := storageutil.ConvertObjToMinObject(o)
   668:
   669:         d.cache.Insert(d.cacheClock.Now(), name, metadata.RegularFileType)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:651 (PC: 0x191a324)
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
=> 651:                 entries = append(entries, entry)
   652:         }
   653:         return
   654: }
   655:
   656: // LOCKS_REQUIRED(d)
   657: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   658:         childMetadata := map[string]string{
   659:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   660:         }
   661:         fullName := NewFileName(d.Name(), name)
   662:
   663:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   664:         if err != nil {
   665:                 return nil, err
   666:         }
   667:         m := storageutil.ConvertObjToMinObject(o)
   668:
   669:         d.cache.Insert(d.cacheClock.Now(), name, metadata.RegularFileType)
   670:         return &Core{
   671:                 Bucket:    d.Bucket(),
(dlv) p entry 
github.com/jacobsa/fuse/fuseutil.Dirent {Offset: 0, Inode: 0, Name: "..", Type: DT_Directory (4)}
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172 (PC: 0x192746b)
Values returned:
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 8, [
                {Offset: 0, Inode: 0, Name: "..", Type: DT_Directory (4)},
                {Offset: 0, Inode: 0, Name: ".", Type: DT_Directory (4)},
                {Offset: 0, Inode: 0, Name: "/", Type: DT_Directory (4)},
                {Offset: 0, Inode: 0, Name: "a", Type: DT_Directory (4)},
                {Offset: 0, Inode: 0, Name: "14", Type: DT_File (8)},
        ]
        newTok: ""
        err: error nil

   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
=> 172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:173 (PC: 0x1927577)
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
=> 173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:179 (PC: 0x19276a2)
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
=> 179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:188 (PC: 0x19277ae)
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
=> 188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:182 (PC: 0x19277ce)
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
=> 182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 5, [
        {Offset: 0, Inode: 0, Name: "..", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: ".", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "/", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "a", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "14", Type: DT_File (8)},
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:183 (PC: 0x19277db)
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
=> 183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:188 (PC: 0x19277dd)
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
=> 188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:192 (PC: 0x19278e6)
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
=> 192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:206 (PC: 0x1927905)
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
=> 206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 5, [
        {Offset: 0, Inode: 0, Name: ".", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "..", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "/", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "14", Type: DT_File (8)},
        {Offset: 0, Inode: 0, Name: "a", Type: DT_Directory (4)},
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:207 (PC: 0x192792f)
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
=> 207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:213 (PC: 0x1927a5c)
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
=> 213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 5, [
        {Offset: 0, Inode: 0, Name: ".", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "..", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "/", Type: DT_Directory (4)},
        {Offset: 0, Inode: 0, Name: "14", Type: DT_File (8)},
        {Offset: 0, Inode: 0, Name: "a", Type: DT_Directory (4)},
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:214 (PC: 0x1927a89)
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
=> 214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:213 (PC: 0x1927abd)
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
=> 213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:214 (PC: 0x1927a89)
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
=> 214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:213 (PC: 0x1927abd)
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
=> 213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:214 (PC: 0x1927a89)
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
=> 214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:213 (PC: 0x1927abd)
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
=> 213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:214 (PC: 0x1927a89)
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
=> 214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:213 (PC: 0x1927abd)
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
=> 213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:214 (PC: 0x1927a89)
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
=> 214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:213 (PC: 0x1927abd)
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
=> 213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:230 (PC: 0x1927ac4)
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
=> 230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:231 (PC: 0x1927af4)
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
=> 231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 5, [
        {Offset: 1, Inode: 0, Name: ".", Type: DT_Directory (4)},
        {Offset: 2, Inode: 0, Name: "..", Type: DT_Directory (4)},
        {Offset: 3, Inode: 0, Name: "/", Type: DT_Directory (4)},
        {Offset: 4, Inode: 0, Name: "14", Type: DT_File (8)},
        {Offset: 5, Inode: 0, Name: "a", Type: DT_Directory (4)},
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:230 (PC: 0x1927b22)
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
=> 230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:231 (PC: 0x1927af4)
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
=> 231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:230 (PC: 0x1927b22)
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
=> 230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245 (PC: 0x1927d53)
Values returned:
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 5, [
                {Offset: 1, Inode: 2, Name: ".", Type: DT_Directory (4)},
                {Offset: 2, Inode: 2, Name: "..", Type: DT_Directory (4)},
                {Offset: 3, Inode: 2, Name: "/", Type: DT_Directory (4)},
                {Offset: 4, Inode: 2, Name: "14", Type: DT_File (8)},
                {Offset: 5, Inode: 2, Name: "a", Type: DT_Directory (4)},
        ]
        err: error nil

   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
=> 245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:246 (PC: 0x1927e12)
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
=> 246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:252 (PC: 0x1927f27)
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
=> 252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:253 (PC: 0x1927f76)
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
=> 253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:255 (PC: 0x1927f84)
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
=> 255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(2934):1 total:10) (PC: 0x193b036)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283 (PC: 0x192815b)
Values returned:
        err: error nil

   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
=> 283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(2934):1 total:10) (PC: 0x193866a)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:284 (PC: 0x1928165)
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
=> 284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(2934):1 total:10) (PC: 0x1917596)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:291 (PC: 0x1928177)
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
=> 291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 27,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 4908, Pid: 3903693, Uid: 1012083},}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(2469):1 total:10) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(2468):1 total:10) (PC: 0x1918397)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:292 (PC: 0x192818a)
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
=> 292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p dh.entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 5, [
        {Offset: 1, Inode: 2, Name: ".", Type: DT_Directory (4)},
        {Offset: 2, Inode: 2, Name: "..", Type: DT_Directory (4)},
        {Offset: 3, Inode: 2, Name: "/", Type: DT_Directory (4)},
        {Offset: 4, Inode: 2, Name: "14", Type: DT_File (8)},
        {Offset: 5, Inode: 2, Name: "a", Type: DT_Directory (4)},
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(2469):1 total:10) (PC: 0x1916836)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:298 (PC: 0x19281d4)
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
=> 298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p n
Command failed: could not find symbol value for n
(dlv) p op.BytesRead
0
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(2469):1 total:10) (PC: 0x19169a5)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:299 (PC: 0x1928205)
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
=> 299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2469):1 total:47) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:300 (PC: 0x192830c)
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
=> 300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p n           
32
(dlv) p op.BytesRead
0
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:304 (PC: 0x1928315)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
=> 304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:298 (PC: 0x1928337)
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
=> 298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:299 (PC: 0x1928205)
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
=> 299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:300 (PC: 0x192830c)
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
=> 300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p n           
32
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:304 (PC: 0x1928315)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
=> 304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:298 (PC: 0x1928337)
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
=> 298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p op.BytesRead
64
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:299 (PC: 0x1928205)
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
=> 299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:300 (PC: 0x192830c)
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
=> 300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:304 (PC: 0x1928315)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
=> 304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p n           
32
(dlv) n             
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:298 (PC: 0x1928337)
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
=> 298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p op.BytesRead
96
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170 (PC: 0x19450bf)
Values returned:
        err: error nil

  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
=>2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2174 (PC: 0x1945104)
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
=>2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
  2191: }
  2192:
  2193: // LOCKS_EXCLUDED(fs.mu)
  2194: func (fs *fileSystem) OpenFile(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 27,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,4,0,0,0,46,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,4,0,0,0,46,46,0,0,0,0,0,0,...+4032 more],
        BytesRead: 160,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 4908, Pid: 3903693, Uid: 1012083},}
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2174 (PC: 0x1945104)
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
=>2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
  2191: }
  2192:
  2193: // LOCKS_EXCLUDED(fs.mu)
  2194: func (fs *fileSystem) OpenFile(
(dlv) bt -full
0  0x0000000001945104 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2174
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       err = error nil
       dh = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc007624280)
       in = (unreadable invalid interface type)
       localFileEntries = []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil

1  0x000000000192bda9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252
       em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil

2  0x000000000192fe2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
       ~r0 = error nil
       startTime = time.Time(2024-05-04T17:14:40Z, +44567879759139){wall: 13944755368665378452, ext: 44567879759139, loc: (*time.Location)(0x2d3cd60)}

3  0x0000000001912b5b in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
       s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
       c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
       ctx = (unreadable invalid interface type)
       op = interface {}(*github.com/jacobsa/fuse/fuseops.ReadDirOp) 0xc007b8ff98
       err = error nil
       typed = ("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)

4  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

5  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695

(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc007bec2d0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 27,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,4,0,0,0,46,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,4,0,0,0,46,46,0,0,0,0,0,0,...+4032 more],
        BytesRead: 160,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 4908, Pid: 3903693, Uid: 1012083},}
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2174 (PC: 0x1945104)
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
=>2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
  2191: }
  2192:
  2193: // LOCKS_EXCLUDED(fs.mu)
  2194: func (fs *fileSystem) OpenFile(
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252 (PC: 0x192bda9)
Values returned:
        err: error nil

   232:         defer em.handlePanic()
   233:
   234:         err := em.wrapped.Unlink(ctx, op)
   235:         return em.mapError("Unlink", err)
   236: }
   237:
   238: func (em *errorMapping) OpenDir(
   239:         ctx context.Context,
   240:         op *fuseops.OpenDirOp) error {
   241:         defer em.handlePanic()
   242:
   243:         err := em.wrapped.OpenDir(ctx, op)
   244:         return em.mapError("OpenDir", err)
   245: }
   246:
   247: func (em *errorMapping) ReadDir(
   248:         ctx context.Context,
   249:         op *fuseops.ReadDirOp) error {
   250:         defer em.handlePanic()
   251:
=> 252:         err := em.wrapped.ReadDir(ctx, op)
   253:         return em.mapError("ReadDir", err)
   254: }
   255:
   256: func (em *errorMapping) ReleaseDirHandle(
   257:         ctx context.Context,
   258:         op *fuseops.ReleaseDirHandleOp) error {
   259:         defer em.handlePanic()
   260:
   261:         err := em.wrapped.ReleaseDirHandle(ctx, op)
   262:         return em.mapError("ReleaseDirHandle", err)
   263: }
   264:
   265: func (em *errorMapping) OpenFile(
   266:         ctx context.Context,
   267:         op *fuseops.OpenFileOp) error {
   268:         defer em.handlePanic()
   269:
   270:         err := em.wrapped.OpenFile(ctx, op)
   271:         return em.mapError("OpenFile", err)
   272: }
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282 (PC: 0x192fe2e)
Values returned:
        ~r0: error nil

   262:         op *fuseops.UnlinkOp) error {
   263:         startTime := time.Now()
   264:         err := fs.wrapped.Unlink(ctx, op)
   265:         recordOp(ctx, "Unlink", startTime, err)
   266:         return err
   267: }
   268:
   269: func (fs *monitoring) OpenDir(
   270:         ctx context.Context,
   271:         op *fuseops.OpenDirOp) error {
   272:         startTime := time.Now()
   273:         err := fs.wrapped.OpenDir(ctx, op)
   274:         recordOp(ctx, "OpenDir", startTime, err)
   275:         return err
   276: }
   277:
   278: func (fs *monitoring) ReadDir(
   279:         ctx context.Context,
   280:         op *fuseops.ReadDirOp) error {
   281:         startTime := time.Now()
=> 282:         err := fs.wrapped.ReadDir(ctx, op)
   283:         recordOp(ctx, "ReadDir", startTime, err)
   284:         return err
   285: }
   286:
   287: func (fs *monitoring) ReleaseDirHandle(
   288:         ctx context.Context,
   289:         op *fuseops.ReleaseDirHandleOp) error {
   290:         startTime := time.Now()
   291:         err := fs.wrapped.ReleaseDirHandle(ctx, op)
   292:         recordOp(ctx, "ReleaseDirHandle", startTime, err)
   293:         return err
   294: }
   295:
   296: func (fs *monitoring) OpenFile(
   297:         ctx context.Context,
   298:         op *fuseops.OpenFileOp) error {
   299:         startTime := time.Now()
   300:         err := fs.wrapped.OpenFile(ctx, op)
   301:         recordOp(ctx, "OpenFile", startTime, err)
   302:         return err
(dlv) so
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199 (PC: 0x1912b5b)
Values returned:
        ~r0: error nil

   179:
   180:         case *fuseops.CreateLinkOp:
   181:                 err = s.fs.CreateLink(ctx, typed)
   182:
   183:         case *fuseops.CreateSymlinkOp:
   184:                 err = s.fs.CreateSymlink(ctx, typed)
   185:
   186:         case *fuseops.RenameOp:
   187:                 err = s.fs.Rename(ctx, typed)
   188:
   189:         case *fuseops.RmDirOp:
   190:                 err = s.fs.RmDir(ctx, typed)
   191:
   192:         case *fuseops.UnlinkOp:
   193:                 err = s.fs.Unlink(ctx, typed)
   194:
   195:         case *fuseops.OpenDirOp:
   196:                 err = s.fs.OpenDir(ctx, typed)
   197:
   198:         case *fuseops.ReadDirOp:
=> 199:                 err = s.fs.ReadDir(ctx, typed)
   200:
   201:         case *fuseops.ReleaseDirHandleOp:
   202:                 err = s.fs.ReleaseDirHandle(ctx, typed)
   203:
   204:         case *fuseops.OpenFileOp:
   205:                 err = s.fs.OpenFile(ctx, typed)
   206:
   207:         case *fuseops.ReadFileOp:
   208:                 err = s.fs.ReadFile(ctx, typed)
   209:
   210:         case *fuseops.WriteFileOp:
   211:                 err = s.fs.WriteFile(ctx, typed)
   212:
   213:         case *fuseops.SyncFileOp:
   214:                 err = s.fs.SyncFile(ctx, typed)
   215:
   216:         case *fuseops.FlushFileOp:
   217:                 err = s.fs.FlushFile(ctx, typed)
   218:
   219:         case *fuseops.ReleaseFileHandleOp:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(2846):1 total:55) (PC: 0x1944d76)
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Values returned:

  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
  1695:         BYTE    $0x90   // NOP
=>1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
  1716: #ifndef GOOS_plan9
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(2846):1 total:55) (PC: 0x1944d76)
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Command failed: nothing to stepout to
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(2469):1 total:33) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) bt
0  0x00000000018c22cc in github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284
1  0x00000000018c66dd in github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205
2  0x000000000190ce68 in github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.(*contentTypeBucket).ListObjects
   at <autogenerated>:1
3  0x00000000019169e8 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335
4  0x00000000019180cc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454
5  0x0000000000ed4a31 in github.com/jacobsa/syncutil.(*Bundle).Add.func1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89
6  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) bt -full
0  0x00000000018c22cc in github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284
       b = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage.bucketHandle")(0xc00072cc60)
       ctx = (unreadable invalid interface type)
       req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000ab0b90)
       listing = *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing nil
       err = error nil
       query = ("*cloud.google.com/go/storage.Query")(0xc0004e6f30)
       itr = ("*cloud.google.com/go/storage.ObjectIterator")(0xc000868000)
       pi = ("*google.golang.org/api/iterator.PageInfo")(0xc000ab0c30)
       list = github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 0, cap: 0, nil, CollapsedRuns: []string len: 0, cap: 0, nil, ContinuationToken: ""}
       attrs = ("*cloud.google.com/go/storage.ObjectAttrs")(0xc0001f6000)

1  0x00000000018c66dd in github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205
       b = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage.debugBucket")(0xc00072e330)
       ctx = (unreadable invalid interface type)
       req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000ab0b90)
       listing = *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing nil
       err = error nil
       desc = "ListObjects(\"a/\")"
       start = time.Time(2024-05-04T17:29:06Z, +45433730032467){wall: 13944756298376071324, ext: 45433730032467, loc: (*time.Location)(0x2d3cd60)}
       id = 58

2  0x000000000190ce68 in github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.(*contentTypeBucket).ListObjects
   at <autogenerated>:1
       ~p0 = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.contentTypeBucket")(0xc00070abd0)
       ctx = (unreadable invalid interface type)
       req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000ab0b90)
       ~r0 = *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing nil
       ~r1 = error nil

3  0x00000000019169e8 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335
       ctx = (unreadable invalid interface type)
       bucket = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0)
       name = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"}
       ~r0 = *github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil
       ~r1 = error nil
       req = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000ab0b90)

4  0x00000000019180cc in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454
       ctx = (unreadable invalid interface type)
       err = error nil
       d = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
       name = "a"
       dirResult = *github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core nil

5  0x0000000000ed4a31 in github.com/jacobsa/syncutil.(*Bundle).Add.func1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/syncutil@v0.0.0-20180201203307-228ac8e5a6c3/bundle.go:89
       b = ("*github.com/jacobsa/syncutil.Bundle")(0xc000ab0af0)
       f = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3

6  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695

(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(2469):1 total:33) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) vp
Command failed: command not available
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446724,0x45f40e,0x446804 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (10)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (55)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (28)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (47)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (111)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (33)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (10)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (10)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (10)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (10)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (10)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (10)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (8)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (4)
Breakpoint 17 (enabled) at 0x1917dea for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (3)
Breakpoint 18 (enabled) at 0x1919d38 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (2)
Breakpoint 19 (enabled) at 0x1919920 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (0)
        cond p == "a//"
(dlv) b 302
Breakpoint 20 set at 0x18c2419 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:302
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:302 (hits goroutine(2469):1 total:1) (PC: 0x18c2419)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
=> 302:         return
   303: }
   304:
   305: func (b *bucketHandle) UpdateObject(ctx context.Context, req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   306:         obj := b.bucket.Object(req.Name)
   307:
   308:         if req.Generation != 0 {
   309:                 obj = obj.Generation(req.Generation)
   310:         }
   311:
   312:         if req.MetaGenerationPrecondition != nil {
   313:                 obj = obj.If(storage.Conditions{MetagenerationMatch: *req.MetaGenerationPrecondition})
   314:         }
   315:
   316:         updateQuery := storage.ObjectAttrsToUpdate{}
   317:
   318:         if req.ContentType != nil {
   319:                 updateQuery.ContentType = *req.ContentType
   320:         }
   321:
   322:         if req.ContentEncoding != nil {
(dlv) clear 20
Breakpoint 20 cleared at 0x18c2419 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:302
(dlv) p list
github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057f900),
        ],
        CollapsedRuns: []string len: 0, cap: 0, nil,
        ContinuationToken: "CgZhLy4uLzg=",}
(dlv) p listing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000958400)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057f900),
        ],
        CollapsedRuns: []string len: 0, cap: 0, nil,
        ContinuationToken: "CgZhLy4uLzg=",}
(dlv) p listing.Objects
[]*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
        *{
                Name: "a/../8",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-t...+77 more",
                Metadata: map[string]string nil,
                Generation: 1714642897885179,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc00057f9b0),
                Updated: (*time.Time)(0xc00057f9c8),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
]
(dlv) c 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(2934):1 total:9) (PC: 0x1917da2)
   468:         case metadata.ExplicitDirType:
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
=> 488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
(dlv) p dirResult
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000959540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:489 (PC: 0x1917db2)
   469:                 b.Add(lookUpExplicitDir)
   470:         case metadata.RegularFileType, metadata.SymlinkType:
   471:                 b.Add(lookUpFile)
   472:         case metadata.NonexistentType:
   473:                 return nil, nil
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
=> 489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
   509:                         Delimiter:         "", // recursively
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2832):1 total:48) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (hits goroutine(2934):1 total:4) (PC: 0x1917dea)
   474:         case metadata.UnknownType:
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
=> 494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
   509:                         Delimiter:         "", // recursively
   510:                         Prefix:            d.Name().GcsObjectName(),
   511:                         ContinuationToken: tok,
   512:                         MaxResults:        limit + 1, // to exclude itself
   513:                 })
   514:                 if err != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:495 (PC: 0x1917df7)
   475:                 b.Add(lookUpFile)
   476:                 if d.implicitDirs {
   477:                         b.Add(lookUpImplicitOrExplicitDir)
   478:                 } else {
   479:                         b.Add(lookUpExplicitDir)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
=> 495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
   500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
   509:                         Delimiter:         "", // recursively
   510:                         Prefix:            d.Name().GcsObjectName(),
   511:                         ContinuationToken: tok,
   512:                         MaxResults:        limit + 1, // to exclude itself
   513:                 })
   514:                 if err != nil {
   515:                         return nil, fmt.Errorf("list objects: %w", err)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:500 (PC: 0x1917f55)
   480:                 }
   481:         }
   482:
   483:         if err := b.Join(); err != nil {
   484:                 return nil, err
   485:         }
   486:
   487:         var result *Core
   488:         if dirResult != nil {
   489:                 result = dirResult
   490:         } else if fileResult != nil {
   491:                 result = fileResult
   492:         }
   493:
   494:         if result != nil {
   495:                 d.cache.Insert(d.cacheClock.Now(), name, result.Type())
   496:         } else if d.enableNonexistentTypeCache && cachedType == metadata.UnknownType {
   497:                 d.cache.Insert(d.cacheClock.Now(), name, metadata.NonexistentType)
   498:         }
   499:
=> 500:         return result, nil
   501: }
   502:
   503: // LOCKS_REQUIRED(d)
   504: func (d *dirInode) ReadDescendants(ctx context.Context, limit int) (map[Name]*Core, error) {
   505:         var tok string
   506:         descendants := make(map[Name]*Core)
   507:         for {
   508:                 listing, err := d.bucket.ListObjects(ctx, &gcs.ListObjectsRequest{
   509:                         Delimiter:         "", // recursively
   510:                         Prefix:            d.Name().GcsObjectName(),
   511:                         ContinuationToken: tok,
   512:                         MaxResults:        limit + 1, // to exclude itself
   513:                 })
   514:                 if err != nil {
   515:                         return nil, fmt.Errorf("list objects: %w", err)
   516:                 }
   517:
   518:                 for _, o := range listing.Objects {
   519:                         if len(descendants) >= limit {
   520:                                 return descendants, nil
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (PC: 0x19386b4)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000959540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
                FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
                Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                        Bucket: (unreadable invalid interface type),
                        Syncer: (unreadable invalid interface type),},
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}
        ~r1: error nil

   909: // LOCKS_EXCLUDED(parent)
   910: // LOCK_FUNCTION(child)
   911: func (fs *fileSystem) lookUpOrCreateChildInode(
   912:         ctx context.Context,
   913:         parent inode.DirInode,
   914:         childName string) (child inode.Inode, err error) {
   915:         // First check if the requested child is a localFileInode.
   916:         child = fs.lookUpLocalFileInode(parent, childName)
   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
=> 929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
(dlv) n 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:937 (PC: 0x1938154)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000959540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
                FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
                Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                        Bucket: (unreadable invalid interface type),
                        Syncer: (unreadable invalid interface type),},
                MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                Local: false,}
        ~r1: error nil

   917:         if child != nil {
   918:                 return
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
=> 937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:939 (PC: 0x19381c0)
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
=> 939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
(dlv) bt   
0  0x00000000019381c0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:939
1  0x000000000193b23f in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330
2  0x000000000192a1a6 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126
3  0x000000000192edab in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156
4  0x0000000001911d44 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144
5  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
6  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) bt -full
0  0x00000000019381c0 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:939
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       parent = (unreadable invalid interface type)
       childName = "a"
       child = github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Inode nil
       err = error nil
       getLookupResult = github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1
       n = 0
       core = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000959540)

1  0x000000000193b23f in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem")(0xc00069c7e0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.LookUpInodeOp")(0xc000146000)
       err = error nil
       parent = (unreadable invalid interface type)

2  0x000000000192a1a6 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126
       em = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping")(0xc000d86690)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.LookUpInodeOp")(0xc000146000)
       ~r0 = error nil

3  0x000000000192edab in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode
   at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156
       fs = ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring")(0xc000d866a0)
       ctx = (unreadable invalid interface type)
       op = ("*github.com/jacobsa/fuse/fuseops.LookUpInodeOp")(0xc000146000)
       ~r0 = error nil
       startTime = time.Time(2024-05-04T17:28:18Z, +45385540139767){wall: 13944756246646571112, ext: 45385540139767, loc: (*time.Location)(0x2d3cd60)}

4  0x0000000001911d44 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144
       s = ("*github.com/jacobsa/fuse/fuseutil.fileSystemServer")(0xc000d0c100)
       c = ("*github.com/jacobsa/fuse.Connection")(0xc00070c340)
       ctx = (unreadable invalid interface type)
       op = interface {}(*github.com/jacobsa/fuse/fuseops.LookUpInodeOp) 0xc00059ff98
       err = error nil
       typed = ("*github.com/jacobsa/fuse/fuseops.LookUpInodeOp")(0xc000146000)

5  0x0000000001911a66 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
   at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123

6  0x00000000004817c1 in runtime.goexit
   at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695

(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:939 (PC: 0x19381c0)
   919:         }
   920:
   921:         // If the requested child is not a localFileInode, continue with the existing
   922:         // flow of checking GCS for file/directory.
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
=> 939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:943 (PC: 0x19381da)
   923:
   924:         // Set up a function that will find a lookup result for the child with the
   925:         // given name. Expects no locks to be held.
   926:         getLookupResult := func() (*inode.Core, error) {
   927:                 parent.Lock()
   928:                 defer parent.Unlock()
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
=> 943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:949 (PC: 0x19381e7)
   929:                 return parent.LookUpChild(ctx, childName)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
=> 949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
   964: // LOCK_FUNCTION(child)
   965: func (fs *fileSystem) lookUpLocalFileInode(parent inode.DirInode, childName string) (child inode.Inode) {
   966:         defer func() {
   967:                 if child != nil {
   968:                         child.IncrementLookupCount()
   969:                 }
(dlv) p core
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core")(0xc000959540)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "a/"},
        Bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
        Local: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:950 (PC: 0x193826f)
   930:         }
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
=> 950:                 if child != nil {
   951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
   964: // LOCK_FUNCTION(child)
   965: func (fs *fileSystem) lookUpLocalFileInode(parent inode.DirInode, childName string) (child inode.Inode) {
   966:         defer func() {
   967:                 if child != nil {
   968:                         child.IncrementLookupCount()
   969:                 }
   970:                 fs.mu.Unlock()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:951 (PC: 0x1938276)
   931:
   932:         // Run a retry loop around lookUpOrCreateInodeIfNotStale.
   933:         const maxTries = 3
   934:         for n := 0; n < maxTries; n++ {
   935:                 // Create a record.
   936:                 var core *inode.Core
   937:                 core, err = getLookupResult()
   938:
   939:                 if err != nil {
   940:                         return
   941:                 }
   942:
   943:                 if core == nil {
   944:                         err = fuse.ENOENT
   945:                         return
   946:                 }
   947:
   948:                 // Attempt to create the inode. Return if successful.
   949:                 child = fs.lookUpOrCreateInodeIfNotStale(*core)
   950:                 if child != nil {
=> 951:                         return
   952:                 }
   953:         }
   954:
   955:         err = fmt.Errorf("cannot find %q in %q with %v tries", childName, parent.Name(), maxTries)
   956:         return
   957: }
   958:
   959: // Look up the localFileInodes to check if a file with given name exists.
   960: // Return inode if it exists, else return nil.
   961: // LOCKS_EXCLUDED(fs.mu)
   962: // LOCKS_EXCLUDED(parent)
   963: // UNLOCK_FUNCTION(fs.mu)
   964: // LOCK_FUNCTION(child)
   965: func (fs *fileSystem) lookUpLocalFileInode(parent inode.DirInode, childName string) (child inode.Inode) {
   966:         defer func() {
   967:                 if child != nil {
   968:                         child.IncrementLookupCount()
   969:                 }
   970:                 fs.mu.Unlock()
   971:         }()
(dlv) p child
(unreadable invalid interface type)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1330 (PC: 0x193b23f)
Values returned:
        child: (unreadable invalid interface type)
        err: error nil

  1310:         return
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
=>1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1331 (PC: 0x193b2e0)
  1311: }
  1312:
  1313: // LOCKS_EXCLUDED(fs.mu)
  1314: func (fs *fileSystem) LookUpInode(
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
=>1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
(dlv) p child
(unreadable invalid interface type)
(dlv) p op.Name
"a"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1335 (PC: 0x193b305)
  1315:         ctx context.Context,
  1316:         op *fuseops.LookUpInodeOp) (err error) {
  1317:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
=>1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (hits goroutine(2934):1 total:5) (PC: 0x193b43f)
  1318:                 // When ignore interrupts config is set, we are creating a new context not
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
=>1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(127):1 total:29) (PC: 0x1944a73)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1339 (PC: 0x193b455)
  1319:                 // cancellable by parent context.
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
=>1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1340 (PC: 0x193b482)
  1320:                 var cancel context.CancelFunc
  1321:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
=>1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1342 (PC: 0x193b68c)
  1322:                 defer cancel()
  1323:         }
  1324:         // Find the parent directory in question.
  1325:         fs.mu.Lock()
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
=>1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
  1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
  1361:         fs.mu.Lock()
  1362:         in := fs.inodeOrDie(op.Inode)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1346 (PC: 0x193b6b1)
  1326:         parent := fs.dirInodeOrDie(op.Parent)
  1327:         fs.mu.Unlock()
  1328:
  1329:         // Find or create the child inode.
  1330:         child, err := fs.lookUpOrCreateChildInode(ctx, parent, op.Name)
  1331:         if err != nil {
  1332:                 return err
  1333:         }
  1334:
  1335:         defer fs.unlockAndMaybeDisposeOfInode(child, &err)
  1336:
  1337:         // Fill out the response.
  1338:         e := &op.Entry
  1339:         e.Child = child.ID()
  1340:         e.Attributes, e.AttributesExpiration, err = fs.getAttributes(ctx, child)
  1341:
  1342:         if err != nil {
  1343:                 return err
  1344:         }
  1345:
=>1346:         return
  1347: }
  1348:
  1349: // LOCKS_EXCLUDED(fs.mu)
  1350: func (fs *fileSystem) GetInodeAttributes(
  1351:         ctx context.Context,
  1352:         op *fuseops.GetInodeAttributesOp) (err error) {
  1353:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  1354:                 // When ignore interrupts config is set, we are creating a new context not
  1355:                 // cancellable by parent context.
  1356:                 var cancel context.CancelFunc
  1357:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  1358:                 defer cancel()
  1359:         }
  1360:         // Find the inode.
  1361:         fs.mu.Lock()
  1362:         in := fs.inodeOrDie(op.Inode)
  1363:         fs.mu.Unlock()
  1364:
  1365:         in.Lock()
  1366:         defer in.Unlock()
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(2589):1 total:56) (PC: 0x1944d76)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? f
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2589):1 total:49) (PC: 0x18c1f48)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:126 (PC: 0x192a1a6)
Values returned:
        err: error nil

   106: func (em *errorMapping) Destroy() {
   107:         defer em.handlePanic()
   108:
   109:         em.wrapped.Destroy()
   110: }
   111:
   112: func (em *errorMapping) StatFS(
   113:         ctx context.Context,
   114:         op *fuseops.StatFSOp) error {
   115:         defer em.handlePanic()
   116:
   117:         err := em.wrapped.StatFS(ctx, op)
   118:         return em.mapError("StatFS", err)
   119: }
   120:
   121: func (em *errorMapping) LookUpInode(
   122:         ctx context.Context,
   123:         op *fuseops.LookUpInodeOp) error {
   124:         defer em.handlePanic()
   125:
=> 126:         err := em.wrapped.LookUpInode(ctx, op)
   127:         return em.mapError("LookUpInode", err)
   128: }
   129:
   130: func (em *errorMapping) GetInodeAttributes(
   131:         ctx context.Context,
   132:         op *fuseops.GetInodeAttributesOp) error {
   133:         defer em.handlePanic()
   134:
   135:         err := em.wrapped.GetInodeAttributes(ctx, op)
   136:         return em.mapError("GetInodeAttributes", err)
   137: }
   138:
   139: func (em *errorMapping) SetInodeAttributes(
   140:         ctx context.Context,
   141:         op *fuseops.SetInodeAttributesOp) error {
   142:         defer em.handlePanic()
   143:
   144:         err := em.wrapped.SetInodeAttributes(ctx, op)
   145:         return em.mapError("SetInodeAttributes", err)
   146: }
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:156 (PC: 0x192edab)
Values returned:
        ~r0: error nil

   136:         wrapped fuseutil.FileSystem
   137: }
   138:
   139: func (fs *monitoring) Destroy() {
   140:         fs.wrapped.Destroy()
   141: }
   142:
   143: func (fs *monitoring) StatFS(
   144:         ctx context.Context,
   145:         op *fuseops.StatFSOp) error {
   146:         startTime := time.Now()
   147:         err := fs.wrapped.StatFS(ctx, op)
   148:         recordOp(ctx, "StatFS", startTime, err)
   149:         return err
   150: }
   151:
   152: func (fs *monitoring) LookUpInode(
   153:         ctx context.Context,
   154:         op *fuseops.LookUpInodeOp) error {
   155:         startTime := time.Now()
=> 156:         err := fs.wrapped.LookUpInode(ctx, op)
   157:         recordOp(ctx, "LookUpInode", startTime, err)
   158:         return err
   159: }
   160:
   161: func (fs *monitoring) GetInodeAttributes(
   162:         ctx context.Context,
   163:         op *fuseops.GetInodeAttributesOp) error {
   164:         startTime := time.Now()
   165:         err := fs.wrapped.GetInodeAttributes(ctx, op)
   166:         recordOp(ctx, "GetInodeAttributes", startTime, err)
   167:         return err
   168: }
   169:
   170: func (fs *monitoring) SetInodeAttributes(
   171:         ctx context.Context,
   172:         op *fuseops.SetInodeAttributesOp) error {
   173:         startTime := time.Now()
   174:         err := fs.wrapped.SetInodeAttributes(ctx, op)
   175:         recordOp(ctx, "SetInodeAttributes", startTime, err)
   176:         return err
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(2589):1 total:34) (PC: 0x18c22cc)
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:144 (PC: 0x1911d44)
Values returned:
        ~r0: error nil

   124:                 }
   125:         }
   126: }
   127:
   128: func (s *fileSystemServer) handleOp(
   129:         c *fuse.Connection,
   130:         ctx context.Context,
   131:         op interface{}) {
   132:         defer s.opsInFlight.Done()
   133:
   134:         // Dispatch to the appropriate method.
   135:         var err error
   136:         switch typed := op.(type) {
   137:         default:
   138:                 err = fuse.ENOSYS
   139:
   140:         case *fuseops.StatFSOp:
   141:                 err = s.fs.StatFS(ctx, typed)
   142:
   143:         case *fuseops.LookUpInodeOp:
=> 144:                 err = s.fs.LookUpInode(ctx, typed)
   145:
   146:         case *fuseops.GetInodeAttributesOp:
   147:                 err = s.fs.GetInodeAttributes(ctx, typed)
   148:
   149:         case *fuseops.SetInodeAttributesOp:
   150:                 err = s.fs.SetInodeAttributes(ctx, typed)
   151:
   152:         case *fuseops.ForgetInodeOp:
   153:                 err = s.fs.ForgetInode(ctx, typed)
   154:
   155:         case *fuseops.BatchForgetOp:
   156:                 err = s.fs.BatchForget(ctx, typed)
   157:                 if err == fuse.ENOSYS {
   158:                         // Handle as a series of single-inode forget operations
   159:                         for _, entry := range typed.Entries {
   160:                                 err = s.fs.ForgetInode(ctx, &fuseops.ForgetInodeOp{
   161:                                         Inode:     entry.Inode,
   162:                                         N:         entry.N,
   163:                                         OpContext: typed.OpContext,
   164:                                 })
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2589):1 total:112) (PC: 0x18c21f0)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? f
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2589):2 total:113) (PC: 0x18c21f0)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2589):3 total:114) (PC: 0x18c21f0)
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Values returned:

  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
  1695:         BYTE    $0x90   // NOP
=>1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
  1716: #ifndef GOOS_plan9
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2589):4 total:115) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*debugBucket).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/debug_bucket.go:205 (PC: 0x18c66dd)
Values returned:
        listing: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000c3e280)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e280),
                ],
                CollapsedRuns: []string len: 4, cap: 4, ["../","./","/","a/"],
                ContinuationToken: "",}
        err: error nil

   185:         o, err = b.wrapped.ComposeObjects(ctx, req)
   186:         return
   187: }
   188:
   189: func (b *debugBucket) StatObject(
   190:         ctx context.Context,
   191:         req *gcs.StatObjectRequest) (m *gcs.MinObject, e *gcs.ExtendedObjectAttributes, err error) {
   192:         id, desc, start := b.startRequest("StatObject(%q)", req.Name)
   193:         defer b.finishRequest(id, desc, start, &err)
   194:
   195:         m, e, err = b.wrapped.StatObject(ctx, req)
   196:         return
   197: }
   198:
   199: func (b *debugBucket) ListObjects(
   200:         ctx context.Context,
   201:         req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   202:         id, desc, start := b.startRequest("ListObjects(%q)", req.Prefix)
   203:         defer b.finishRequest(id, desc, start, &err)
   204:
=> 205:         listing, err = b.wrapped.ListObjects(ctx, req)
   206:         return
   207: }
   208:
   209: func (b *debugBucket) UpdateObject(
   210:         ctx context.Context,
   211:         req *gcs.UpdateObjectRequest) (o *gcs.Object, err error) {
   212:         id, desc, start := b.startRequest("UpdateObject(%q)", req.Name)
   213:         defer b.finishRequest(id, desc, start, &err)
   214:
   215:         o, err = b.wrapped.UpdateObject(ctx, req)
   216:         return
   217: }
   218:
   219: func (b *debugBucket) DeleteObject(
   220:         ctx context.Context,
   221:         req *gcs.DeleteObjectRequest) (err error) {
   222:         id, desc, start := b.startRequest("DeleteObject(%q)", req.Name)
   223:         defer b.finishRequest(id, desc, start, &err)
   224:
   225:         err = b.wrapped.DeleteObject(ctx, req)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (hits goroutine(2989):1 total:11) (PC: 0x193b036)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? f
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (hits goroutine(2989):1 total:11) (PC: 0x193866a)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:559 (PC: 0x1918f13)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000c3e280)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 1, cap: 1, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00057e280),
                ],
                CollapsedRuns: []string len: 4, cap: 4, ["../","./","/","a/"],
                ContinuationToken: "",}
        ~r1: error nil

   539:
   540: }
   541:
   542: // LOCKS_REQUIRED(d)
   543: func (d *dirInode) readObjects(
   544:         ctx context.Context,
   545:         tok string) (cores map[Name]*Core, newTok string, err error) {
   546:         // Ask the bucket to list some objects.
   547:         req := &gcs.ListObjectsRequest{
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
=> 559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
   568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (hits goroutine(2989):1 total:11) (PC: 0x1917596)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? f
continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (hits goroutine(3024):1 total:11) (PC: 0x1918017)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (hits goroutine(3023):1 total:11) (PC: 0x1918397)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (hits goroutine(3024):1 total:11) (PC: 0x1916836)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (hits goroutine(3024):1 total:11) (PC: 0x19169a5)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(3024):1 total:50) (PC: 0x18c1f48)
        breakpoint hit during stepout, continuing...
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(2589):1 total:3) (PC: 0x1919d38)
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
=> 568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (hits goroutine(2989):1 total:10) (PC: 0x1917da2)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:625 (PC: 0x1919c5d)
Values returned:

   605:
   606:         if !d.implicitDirs {
   607:                 return
   608:         }
   609:
   610:         // Add implicit directories into the result.
   611:         for _, p := range listing.CollapsedRuns {
   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
=> 625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
   632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (hits goroutine(2989):1 total:5) (PC: 0x1917dea)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:632 (PC: 0x1919f85)
Values returned:
        cores: map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core [
                {bucketName: "", objectName: "14"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b8e000),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc0079001e0),
                        Local: false,}, 
                {bucketName: "", objectName: "../"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b8e040),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                        Local: false,}, 
                {bucketName: "", objectName: "./"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b8e080),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                        Local: false,}, 
                {bucketName: "", objectName: "/"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b8e0c0),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                        Local: false,}, 
                {bucketName: "", objectName: "a/"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b8e100),
                        Bucket: *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket")(0xc000d0c0e0),
                        MinObject: *github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject nil,
                        Local: false,}, 
        ]
        newTok: ""
        err: error nil

   612:                 pathBase := path.Base(p)
   613:                 dirName := NewDirName(d.Name(), pathBase)
   614:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   615:                         continue
   616:                 }
   617:
   618:                 implicitDir := &Core{
   619:                         Bucket:    d.Bucket(),
   620:                         FullName:  dirName,
   621:                         MinObject: nil,
   622:                 }
   623:                 cores[dirName] = implicitDir
   624:         }
   625:         return
   626: }
   627:
   628: func (d *dirInode) ReadEntries(
   629:         ctx context.Context,
   630:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   631:         var cores map[Name]*Core
=> 632:         cores, newTok, err = d.readObjects(ctx, tok)
   633:         if err != nil {
   634:                 err = fmt.Errorf("read objects: %w", err)
   635:                 return
   636:         }
   637:
   638:         for fullName, core := range cores {
   639:                 entry := fuseutil.Dirent{
   640:                         Name: path.Base(fullName.LocalName()),
   641:                         Type: fuseutil.DT_Unknown,
   642:                 }
   643:                 switch core.Type() {
   644:                 case metadata.SymlinkType:
   645:                         entry.Type = fuseutil.DT_Link
   646:                 case metadata.RegularFileType:
   647:                         entry.Type = fuseutil.DT_File
   648:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   649:                         entry.Type = fuseutil.DT_Directory
   650:                 }
   651:                 entries = append(entries, entry)
   652:         }
(dlv) p d
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode")(0xc0002286c0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode {
        bucket: *github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket {
                Bucket: (unreadable invalid interface type),
                Syncer: (unreadable invalid interface type),},
        mtimeClock: (unreadable invalid interface type),
        cacheClock: (unreadable invalid interface type),
        id: 1,
        implicitDirs: true,
        enableManagedFoldersListing: false,
        enableNonexistentTypeCache: false,
        name: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: ""},
        attrs: github.com/jacobsa/fuse/fuseops.InodeAttributes {
                Size: 0,
                Nlink: 0,
                Mode: 2147484141,
                Rdev: 0,
                Atime: (*time.Time)(0xc000228730),
                Mtime: (*time.Time)(0xc000228748),
                Ctime: (*time.Time)(0xc000228760),
                Crtime: (*time.Time)(0xc000228778),
                Uid: 1012083,
                Gid: 89939,},
        mu: (unreadable invalid interface type),
        lc: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.lookupCount {id: 1, count: 1, destroyed: false},
        cache: (unreadable invalid interface type),}
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:172 (PC: 0x192746b)
Values returned:
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 8, [
                {Offset: 0, Inode: 0, Name: ".", Type: DT_Directory (4)},
                {Offset: 0, Inode: 0, Name: "/", Type: DT_Directory (4)},
                {Offset: 0, Inode: 0, Name: "a", Type: DT_Directory (4)},
                {Offset: 0, Inode: 0, Name: "14", Type: DT_File (8)},
                {Offset: 0, Inode: 0, Name: "..", Type: DT_Directory (4)},
        ]
        newTok: ""
        err: error nil

   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
=> 172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(2215):1 total:57) (PC: 0x1944d76)
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:245 (PC: 0x1927d53)
Values returned:
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 5, [
                {Offset: 1, Inode: 2, Name: ".", Type: DT_Directory (4)},
                {Offset: 2, Inode: 2, Name: "..", Type: DT_Directory (4)},
                {Offset: 3, Inode: 2, Name: "/", Type: DT_Directory (4)},
                {Offset: 4, Inode: 2, Name: "14", Type: DT_File (8)},
                {Offset: 5, Inode: 2, Name: "a", Type: DT_Directory (4)},
        ]
        err: error nil

   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
=> 245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
(dlv) p dh
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle")(0xc00091c0a0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle {
        in: (unreadable invalid interface type),
        implicitDirs: true,
        Mu: (unreadable invalid interface type),
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil,
        entriesValid: false,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:246 (PC: 0x1927e12)
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
=> 246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 5, cap: 5, [
        {Offset: 1, Inode: 2, Name: ".", Type: DT_Directory (4)},
        {Offset: 2, Inode: 2, Name: "..", Type: DT_Directory (4)},
        {Offset: 3, Inode: 2, Name: "/", Type: DT_Directory (4)},
        {Offset: 4, Inode: 2, Name: "14", Type: DT_File (8)},
        {Offset: 5, Inode: 2, Name: "a", Type: DT_Directory (4)},
]
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/handle/dir_handle.go:283 (PC: 0x192815b)
Values returned:
        err: error nil

   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
=> 283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2170 (PC: 0x19450bf)
Values returned:
        err: error nil

  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
=>2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/error_mapping.go:252 (PC: 0x192bda9)
Values returned:
        err: error nil

   232:         defer em.handlePanic()
   233:
   234:         err := em.wrapped.Unlink(ctx, op)
   235:         return em.mapError("Unlink", err)
   236: }
   237:
   238: func (em *errorMapping) OpenDir(
   239:         ctx context.Context,
   240:         op *fuseops.OpenDirOp) error {
   241:         defer em.handlePanic()
   242:
   243:         err := em.wrapped.OpenDir(ctx, op)
   244:         return em.mapError("OpenDir", err)
   245: }
   246:
   247: func (em *errorMapping) ReadDir(
   248:         ctx context.Context,
   249:         op *fuseops.ReadDirOp) error {
   250:         defer em.handlePanic()
   251:
=> 252:         err := em.wrapped.ReadDir(ctx, op)
   253:         return em.mapError("ReadDir", err)
   254: }
   255:
   256: func (em *errorMapping) ReleaseDirHandle(
   257:         ctx context.Context,
   258:         op *fuseops.ReleaseDirHandleOp) error {
   259:         defer em.handlePanic()
   260:
   261:         err := em.wrapped.ReleaseDirHandle(ctx, op)
   262:         return em.mapError("ReleaseDirHandle", err)
   263: }
   264:
   265: func (em *errorMapping) OpenFile(
   266:         ctx context.Context,
   267:         op *fuseops.OpenFileOp) error {
   268:         defer em.handlePanic()
   269:
   270:         err := em.wrapped.OpenFile(ctx, op)
   271:         return em.mapError("OpenFile", err)
   272: }
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/wrappers/monitoring.go:282 (PC: 0x192fe2e)
Values returned:
        ~r0: error nil

   262:         op *fuseops.UnlinkOp) error {
   263:         startTime := time.Now()
   264:         err := fs.wrapped.Unlink(ctx, op)
   265:         recordOp(ctx, "Unlink", startTime, err)
   266:         return err
   267: }
   268:
   269: func (fs *monitoring) OpenDir(
   270:         ctx context.Context,
   271:         op *fuseops.OpenDirOp) error {
   272:         startTime := time.Now()
   273:         err := fs.wrapped.OpenDir(ctx, op)
   274:         recordOp(ctx, "OpenDir", startTime, err)
   275:         return err
   276: }
   277:
   278: func (fs *monitoring) ReadDir(
   279:         ctx context.Context,
   280:         op *fuseops.ReadDirOp) error {
   281:         startTime := time.Now()
=> 282:         err := fs.wrapped.ReadDir(ctx, op)
   283:         recordOp(ctx, "ReadDir", startTime, err)
   284:         return err
   285: }
   286:
   287: func (fs *monitoring) ReleaseDirHandle(
   288:         ctx context.Context,
   289:         op *fuseops.ReleaseDirHandleOp) error {
   290:         startTime := time.Now()
   291:         err := fs.wrapped.ReleaseDirHandle(ctx, op)
   292:         recordOp(ctx, "ReleaseDirHandle", startTime, err)
   293:         return err
   294: }
   295:
   296: func (fs *monitoring) OpenFile(
   297:         ctx context.Context,
   298:         op *fuseops.OpenFileOp) error {
   299:         startTime := time.Now()
   300:         err := fs.wrapped.OpenFile(ctx, op)
   301:         recordOp(ctx, "OpenFile", startTime, err)
   302:         return err
(dlv) so
> github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp() /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199 (PC: 0x1912b5b)
Values returned:
        ~r0: error nil

   179:
   180:         case *fuseops.CreateLinkOp:
   181:                 err = s.fs.CreateLink(ctx, typed)
   182:
   183:         case *fuseops.CreateSymlinkOp:
   184:                 err = s.fs.CreateSymlink(ctx, typed)
   185:
   186:         case *fuseops.RenameOp:
   187:                 err = s.fs.Rename(ctx, typed)
   188:
   189:         case *fuseops.RmDirOp:
   190:                 err = s.fs.RmDir(ctx, typed)
   191:
   192:         case *fuseops.UnlinkOp:
   193:                 err = s.fs.Unlink(ctx, typed)
   194:
   195:         case *fuseops.OpenDirOp:
   196:                 err = s.fs.OpenDir(ctx, typed)
   197:
   198:         case *fuseops.ReadDirOp:
=> 199:                 err = s.fs.ReadDir(ctx, typed)
   200:
   201:         case *fuseops.ReleaseDirHandleOp:
   202:                 err = s.fs.ReleaseDirHandle(ctx, typed)
   203:
   204:         case *fuseops.OpenFileOp:
   205:                 err = s.fs.OpenFile(ctx, typed)
   206:
   207:         case *fuseops.ReadFileOp:
   208:                 err = s.fs.ReadFile(ctx, typed)
   209:
   210:         case *fuseops.WriteFileOp:
   211:                 err = s.fs.WriteFile(ctx, typed)
   212:
   213:         case *fuseops.SyncFileOp:
   214:                 err = s.fs.SyncFile(ctx, typed)
   215:
   216:         case *fuseops.FlushFileOp:
   217:                 err = s.fs.FlushFile(ctx, typed)
   218:
   219:         case *fuseops.ReleaseFileHandleOp:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(3107):1 total:58) (PC: 0x1944d76)
        breakpoint hit during stepout
[c] continue [s] stop here and cancel stepout, [f] finish stepout skipping all breakpoints? f
continuing...
> runtime.goexit() /usr/lib/google-golang/src/runtime/asm_amd64.s:1696 (PC: 0x4817c1)
Warning: debugging optimized function
Values returned:

  1676:
  1677: TEXT runtime·return0(SB), NOSPLIT, $0
  1678:         MOVL    $0, AX
  1679:         RET
  1680:
  1681:
  1682: // Called from cgo wrappers, this function returns g->m->curg.stack.hi.
  1683: // Must obey the gcc calling convention.
  1684: TEXT _cgo_topofstack(SB),NOSPLIT,$0
  1685:         get_tls(CX)
  1686:         MOVQ    g(CX), AX
  1687:         MOVQ    g_m(AX), AX
  1688:         MOVQ    m_curg(AX), AX
  1689:         MOVQ    (g_stack+stack_hi)(AX), AX
  1690:         RET
  1691:
  1692: // The top-most function running on a goroutine
  1693: // returns to goexit+PCQuantum.
  1694: TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
  1695:         BYTE    $0x90   // NOP
=>1696:         CALL    runtime·goexit1(SB)     // does not return
  1697:         // traceback from goexit1 must hit code range of goexit
  1698:         BYTE    $0x90   // NOP
  1699:
  1700: // This is called from .init_array and follows the platform, not Go, ABI.
  1701: TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
  1702:         PUSHQ   R15 // The access to global variables below implicitly uses R15, which is callee-save
  1703:         MOVQ    runtime·lastmoduledatap(SB), AX
  1704:         MOVQ    DI, moduledata_next(AX)
  1705:         MOVQ    DI, runtime·lastmoduledatap(SB)
  1706:         POPQ    R15
  1707:         RET
  1708:
  1709: // Initialize special registers then jump to sigpanic.
  1710: // This function is injected from the signal handler for panicking
  1711: // signals. It is quite painful to set X15 in the signal context,
  1712: // so we do it here.
  1713: TEXT ·sigpanic0(SB),NOSPLIT,$0-0
  1714:         get_tls(R14)
  1715:         MOVQ    g(R14), R14
  1716: #ifndef GOOS_plan9
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (hits goroutine(3082):1 total:30) (PC: 0x1944a73)
  2106:         // Delete the backing object.
  2107:         err = parent.DeleteChildFile(
  2108:                 ctx,
  2109:                 op.Name,
  2110:                 0,   // Latest generation
  2111:                 nil) // No meta-generation precondition
  2112:
  2113:         if err != nil {
  2114:                 err = fmt.Errorf("DeleteChildFile: %w", err)
  2115:                 return err
  2116:         }
  2117:
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
=>2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.OpenDirOp")(0xc0001c2280)
*github.com/jacobsa/fuse/fuseops.OpenDirOp {
        Inode: 1,
        Handle: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 5118, Pid: 3983754, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(2752):1 total:59) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0007824b0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 29,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 5130, Pid: 3983754, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (hits goroutine(2752):1 total:51) (PC: 0x18c1f48)
   240:         // Default Projection value in jacobsa/gcloud library is 0 that maps to 1 in Go Client API interface, and that is for "full".
   241:         default:
   242:                 convertedProjection = storage.Projection(1)
   243:         }
   244:         return convertedProjection
   245: }
   246:
   247: func (b *bucketHandle) ListObjects(ctx context.Context, req *gcs.ListObjectsRequest) (listing *gcs.Listing, err error) {
   248:         // Converting *ListObjectsRequest to type *storage.Query as expected by the Go Storage Client.
   249:         query := &storage.Query{
   250:                 Delimiter:                req.Delimiter,
   251:                 Prefix:                   req.Prefix,
   252:                 Projection:               getProjectionValue(req.ProjectionVal),
   253:                 IncludeTrailingDelimiter: req.IncludeTrailingDelimiter,
   254:                 IncludeFoldersAsPrefixes: req.IncludeFoldersAsPrefixes,
   255:                 //MaxResults: , (Field not present in storage.Query of Go Storage Library but present in ListObjectsQuery in Jacobsa code.)
   256:         }
   257:         itr := b.bucket.Objects(ctx, query) // Returning iterator to the list of objects.
   258:         pi := itr.PageInfo()
   259:         pi.MaxSize = req.MaxResults
=> 260:         pi.Token = req.ContinuationToken
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
(dlv) p req
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest")(0xc000ab06e0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest {Prefix: "", Delimiter: "/", IncludeTrailingDelimiter: true, IncludeFoldersAsPrefixes: false, ContinuationToken: "", MaxResults: 5000, ProjectionVal: NoAcl (1)}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (hits goroutine(2752):1 total:35) (PC: 0x18c22cc)
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
   281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
=> 284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
   302:         return
   303: }
   304:
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2752):1 total:116) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2752):2 total:117) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2752):3 total:118) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (hits goroutine(2752):4 total:119) (PC: 0x18c21f0)
   261:         var list gcs.Listing
   262:
   263:         // Iterating through all the objects in the bucket and one by one adding them to the list.
   264:         for {
   265:                 var attrs *storage.ObjectAttrs
   266:
   267:                 attrs, err = itr.Next()
   268:                 if err == iterator.Done {
   269:                         err = nil
   270:                         break
   271:                 }
   272:                 if err != nil {
   273:                         err = fmt.Errorf("Error in iterating through objects: %w", err)
   274:                         return
   275:                 }
   276:
   277:                 // Prefix attribute will be set for the objects returned as part of Prefix[] array in list response.
   278:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/storage.go#L1304
   279:                 // https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/cloud.google.com/go/storage/http_client.go#L370
   280:                 if attrs.Prefix != "" {
=> 281:                         list.CollapsedRuns = append(list.CollapsedRuns, attrs.Prefix)
   282:                 } else {
   283:                         // Converting attrs to *Object type.
   284:                         currObject := storageutil.ObjectAttrsToBucketObject(attrs)
   285:                         list.Objects = append(list.Objects, currObject)
   286:                 }
   287:
   288:                 // itr.next returns all the objects present in the bucket. Hence adding a
   289:                 // check to break after iterating over the current page. pi.Remaining()
   290:                 // function returns number of items (items + prefixes) remaining in current
   291:                 // page to be iterated by iterator (itr). The func returns (number of items in current page - 1)
   292:                 // after first itr.Next() call and becomes 0 when iteration is done.
   293:                 // If req.MaxResults is 0, then wait till iterator is done. This is similar
   294:                 // to https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/vendor/github.com/jacobsa/gcloud/gcs/bucket.go#L164
   295:                 if req.MaxResults != 0 && (pi.Remaining() == 0) {
   296:                         break
   297:                 }
   298:         }
   299:
   300:         list.ContinuationToken = itr.PageInfo().Token
   301:         listing = &list
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (hits goroutine(2752):1 total:4) (PC: 0x1919d38)
   548:                 Delimiter:                "/",
   549:                 IncludeTrailingDelimiter: true,
   550:                 Prefix:                   d.Name().GcsObjectName(),
   551:                 ContinuationToken:        tok,
   552:                 MaxResults:               MaxResultsForListObjectsCall,
   553:                 // Setting Projection param to noAcl since fetching owner and acls are not
   554:                 // required.
   555:                 ProjectionVal:            gcs.NoAcl,
   556:                 IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   557:         }
   558:
   559:         listing, err := d.bucket.ListObjects(ctx, req)
   560:         if err != nil {
   561:                 err = fmt.Errorf("ListObjects: %w", err)
   562:                 return
   563:         }
   564:
   565:         cores = make(map[Name]*Core)
   566:         defer func() {
   567:                 now := d.cacheClock.Now()
=> 568:                 for fullName, c := range cores {
   569:                         d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   570:                 }
   571:         }()
   572:
   573:         for _, o := range listing.Objects {
   574:                 // Skip empty results or the directory object backing this inode.
   575:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   576:                         continue
   577:                 }
   578:
   579:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   580:
   581:                 // Given the alphabetical order of the objects, if a file "foo" and
   582:                 // directory "foo/" coexist, the directory would eventually occupy
   583:                 // the value of records["foo"].
   584:                 if strings.HasSuffix(o.Name, "/") {
   585:                         dirName := NewDirName(d.Name(), nameBase)
   586:                         explicitDir := &Core{
   587:                                 Bucket:    d.Bucket(),
   588:                                 FullName:  dirName,
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(3031):1 total:60) (PC: 0x1944d76)
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
(dlv) c
received SIGINT, stopping process (will not forward signal)
> runtime.futex() /usr/lib/google-golang/src/runtime/sys_linux_amd64.s:559 (PC: 0x4835c3)
Warning: debugging optimized function
   539: TEXT runtime·madvise(SB),NOSPLIT,$0
   540:         MOVQ    addr+0(FP), DI
   541:         MOVQ    n+8(FP), SI
   542:         MOVL    flags+16(FP), DX
   543:         MOVQ    $SYS_madvise, AX
   544:         SYSCALL
   545:         MOVL    AX, ret+24(FP)
   546:         RET
   547:
   548: // int64 futex(int32 *uaddr, int32 op, int32 val,
   549: //      struct timespec *timeout, int32 *uaddr2, int32 val2);
   550: TEXT runtime·futex(SB),NOSPLIT,$0
   551:         MOVQ    addr+0(FP), DI
   552:         MOVL    op+8(FP), SI
   553:         MOVL    val+12(FP), DX
   554:         MOVQ    ts+16(FP), R10
   555:         MOVQ    addr2+24(FP), R8
   556:         MOVL    val3+32(FP), R9
   557:         MOVL    $SYS_futex, AX
   558:         SYSCALL
=> 559:         MOVL    AX, ret+40(FP)
   560:         RET
   561:
   562: // int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
   563: TEXT runtime·clone(SB),NOSPLIT|NOFRAME,$0
   564:         MOVL    flags+0(FP), DI
   565:         MOVQ    stk+8(FP), SI
   566:         MOVQ    $0, DX
   567:         MOVQ    $0, R10
   568:         MOVQ    $0, R8
   569:         // Copy mp, gp, fn off parent stack for use by child.
   570:         // Careful: Linux system call clobbers CX and R11.
   571:         MOVQ    mp+16(FP), R13
   572:         MOVQ    gp+24(FP), R9
   573:         MOVQ    fn+32(FP), R12
   574:         CMPQ    R13, $0    // m
   575:         JEQ     nog1
   576:         CMPQ    R9, $0    // g
   577:         JEQ     nog1
   578:         LEAQ    m_tls(R13), R8
   579: #ifdef GOOS_android
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446804,0x446724,0x45f40e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x446cc4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x193b036 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1314 (11)
Breakpoint 2 (enabled) at 0x1944d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2148 (60)
Breakpoint 3 (enabled) at 0x1944a73 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).OpenDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:2126 (30)
Breakpoint 4 (enabled) at 0x18c1f48 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:260 (51)
Breakpoint 6 (enabled) at 0x18c21f0 for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:281 (119)
Breakpoint 7 (enabled) at 0x18c22cc for github.com/googlecloudplatform/gcsfuse/v2/internal/storage.(*bucketHandle).ListObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/storage/bucket_handle.go:284 (35)
Breakpoint 8 (enabled) at 0x1916836 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:326 (11)
Breakpoint 9 (enabled) at 0x19169a5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.findDirInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:335 (11)
Breakpoint 10 (enabled) at 0x1917596 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:437 (11)
Breakpoint 11 (enabled) at 0x193866a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).lookUpOrCreateChildInode.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:929 (11)
Breakpoint 12 (enabled) at 0x1918397 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:446 (11)
Breakpoint 13 (enabled) at 0x19181d7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:450 (0)
Breakpoint 14 (enabled) at 0x1918017 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild.func3() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:454 (11)
Breakpoint 15 (enabled) at 0x1917da2 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:488 (10)
Breakpoint 16 (enabled) at 0x193b43f for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/fs.go:1338 (5)
Breakpoint 17 (enabled) at 0x1917dea for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).LookUpChild() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:494 (5)
Breakpoint 18 (enabled) at 0x1919d38 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:568 (4)
Breakpoint 19 (enabled) at 0x1919920 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse/internal/fs/inode/dir.go:612 (0)
        cond p == "a//"
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch$ unmount $mountpath# ; ./creationSituation.sh 2 debugCommand unmount not found
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 2 -gt 1 ']'
+ echo 'master branch (2) ...'
master branch (2) ...
+ bucket=gargnitin-test-empty-dirname-asia-se1
+ filename=hello.txt
+ gcspath=gs://gargnitin-test-empty-dirname-asia-se1//hello.txt
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2
mkdir: cannot stat ‘/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2’: Transport endpoint is not connected
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch$ 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch$ sudo umount $mountpath ; ./creationSituation.sh 2                                                                                                                                                       
[sudo] password for gargnitin: 
umount: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2: not mounted.
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'master branch (2) ...'
master branch (2) ...
+ bucket=gargnitin-test-empty-dirname-asia-se1
+ filename=hello.txt
+ gcspath=gs://gargnitin-test-empty-dirname-asia-se1//hello.txt
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2 not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --implicit-dirs --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-2.log --log-format=text gargnitin-test-empty-dirname-asia-se1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2
{"timestamp":{"seconds":1714850102,"nanos":333000478},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch/config.yml]\n"}
time="04/05/2024 07:15:02.333393" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240317-RC00 cl/616607620 +0a6f05e30f X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2\n"
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch$ export | grep 'bucket\|mountpath\|logfile'
declare -x bucket="gargnitin-test-empty-dirname-asia-se1"
declare -x mountpath="/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount2"
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch$ lsfusemnts 
gargnitin-test-empty-dirname-asia-se1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-test-empty-dirname-asia-se1-mount4
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch$                                                                                
If you do not reboot now, your system will reboot automatically                
at Fri May 17 02:52:10 UTC 2024. For more info, see go/glinux-reboot-policy.   
To reboot your computer 10 hours from now, on the command line run:            
echo systemctl reboot | at now + 10 hours                                      
Also you may have a pending maintenance. See go/cloudtop-faq#cloudtop-maintenan
ce-scheduler                                                                   
To run maintenance in 10 hours run:                                            
ctop self maintenance schedule in 10h
                                                                               
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240429-fix-empty-dirname-issue/master-branch$ 
