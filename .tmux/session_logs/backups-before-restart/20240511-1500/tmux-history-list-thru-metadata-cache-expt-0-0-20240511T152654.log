   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
=> 614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (PC: 0x1946ca7)
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
=> 615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
(dlv) p fullName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file1"}
(dlv) p c
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing")(0xc0006910b0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file1"},
        ItemType: RegularFileType (2),}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614 (PC: 0x1946d4d)
   584:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
=> 614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
(dlv) b 615
Breakpoint 4 set at 0x1946ca7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (hits goroutine(122):1 total:1) (PC: 0x1946ca7)
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
=> 615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
(dlv) p c
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing")(0xc0006910e0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file2"},
        ItemType: RegularFileType (2),}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (hits goroutine(122):2 total:2) (PC: 0x1946ca7)
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
=> 615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
(dlv) p c
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing")(0xc000691110)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir1/"},
        ItemType: UnknownType (0),}
(dlv) q 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:568
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:585
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:601
Breakpoint 1 set at 0x1945d1b for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:601
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614
Breakpoint 2 set at 0x1946bf8 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623
Breakpoint 3 set at 0x1945b3e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648
Breakpoint 4 set at 0x194625a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 5 set at 0x1946427 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682
Breakpoint 6 set at 0x19467e9 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682
(dlv) c
{"timestamp":{"seconds":1715269871,"nanos":624216913},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:601 (hits goroutine(57):1 total:1) (PC: 0x1945d1b)
   571:         return
   572: }
   573:
   574: // purely for debugging and logging. Remove later!
   575: func PrintGcsListing(listing *gcs.Listing, printFn func(string)) {
   576:         for _, str := range StrsOfGcsListing(listing) {
   577:                 printFn(str)
   578:         }
   579: }
   580:
   581: // LOCKS_REQUIRED(d)
   582: func (d *dirInode) readObjects(
   583:         ctx context.Context,
   584:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
=> 601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(57):1 total:1) (PC: 0x1946427)
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
(dlv) p fileName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file1"}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(57):2 total:2) (PC: 0x1946427)
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
(dlv) p fileName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file2"}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (hits goroutine(57):1 total:1) (PC: 0x19467e9)
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
=> 682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
(dlv) p dirName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir1/"}
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:66 (PC: 0x1940fae)
    36:         MinObject *gcs.MinObject
    37:
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
=>  66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
    68:         case m == nil:
    69:                 return metadata.UnknownType
    70:         case m == nil && !local:
    71:                 return metadata.ImplicitDirType
    72:         case fullname.IsDir():
    73:                 return metadata.ExplicitDirType
    74:         case IsSymlink(m):
    75:                 return metadata.SymlinkType
    76:         default:
    77:                 return metadata.RegularFileType
    78:         }
    79: }
    80:
    81: func (c *Core) Type() metadata.Type {
    82:         switch {
    83:         case c == nil:
    84:                 return metadata.UnknownType
    85:         default:
    86:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    87:         }
    88: }
    89:
    90: func (c *MinCoreForListing) Type() metadata.Type {
    91:         if c == nil {
    92:                 return metadata.UnknownType
    93:         }
    94:         return c.ItemType
    95: }
    96:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:68 (PC: 0x1940fd8)
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
=>  68:         case m == nil:
    69:                 return metadata.UnknownType
    70:         case m == nil && !local:
    71:                 return metadata.ImplicitDirType
    72:         case fullname.IsDir():
    73:                 return metadata.ExplicitDirType
    74:         case IsSymlink(m):
    75:                 return metadata.SymlinkType
    76:         default:
    77:                 return metadata.RegularFileType
    78:         }
    79: }
    80:
    81: func (c *Core) Type() metadata.Type {
    82:         switch {
    83:         case c == nil:
    84:                 return metadata.UnknownType
    85:         default:
    86:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    87:         }
    88: }
    89:
    90: func (c *MinCoreForListing) Type() metadata.Type {
    91:         if c == nil {
    92:                 return metadata.UnknownType
    93:         }
    94:         return c.ItemType
    95: }
    96:
    97: // SanityCheck returns an error if the object is conflicting with itself, which
    98: // means the metadata of the file system is broken.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:69 (PC: 0x194109d)
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
    68:         case m == nil:
=>  69:                 return metadata.UnknownType
    70:         case m == nil && !local:
    71:                 return metadata.ImplicitDirType
    72:         case fullname.IsDir():
    73:                 return metadata.ExplicitDirType
    74:         case IsSymlink(m):
    75:                 return metadata.SymlinkType
    76:         default:
    77:                 return metadata.RegularFileType
    78:         }
    79: }
    80:
    81: func (c *Core) Type() metadata.Type {
    82:         switch {
    83:         case c == nil:
    84:                 return metadata.UnknownType
    85:         default:
    86:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    87:         }
    88: }
    89:
    90: func (c *MinCoreForListing) Type() metadata.Type {
    91:         if c == nil {
    92:                 return metadata.UnknownType
    93:         }
    94:         return c.ItemType
    95: }
    96:
    97: // SanityCheck returns an error if the object is conflicting with itself, which
    98: // means the metadata of the file system is broken.
    99: func (c Core) SanityCheck() error {
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1      
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715270204,"nanos":36936228},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
time="09/05/2024 03:56:44.037811" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="09/05/2024 03:56:44.346487" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:568
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:585
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:601
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614
Breakpoint 1 set at 0x1946bd8 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623
Breakpoint 2 set at 0x1945b1e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648
Breakpoint 3 set at 0x194623a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 4 set at 0x1946407 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682
Breakpoint 5 set at 0x19467c9 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682
(dlv) c
{"timestamp":{"seconds":1715270237,"nanos":25784637},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(102):1 total:1) (PC: 0x1946407)
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
(dlv) p fileName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file1"}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(102):2 total:2) (PC: 0x1946407)
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
(dlv) p fileName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file2"}
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446404,0x4464e4,0x45f38e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1946bd8 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614 (0)
Breakpoint 2 (enabled) at 0x1945b1e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623 (0)
Breakpoint 3 (enabled) at 0x194623a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648 (0)
Breakpoint 4 (enabled) at 0x1946407 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (2)
Breakpoint 5 (enabled) at 0x19467c9 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (0)
(dlv) toggle 4
Breakpoint 4 toggled at 0x1946407 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (PC: 0x1946407)
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
(dlv) p fileName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file2"}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (hits goroutine(102):1 total:1) (PC: 0x19467c9)
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
=> 682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
(dlv) p dirName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir1/"}
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:66 (PC: 0x1940fae)
    36:         MinObject *gcs.MinObject
    37:
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
=>  66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
    68:         case m == nil && !local:
    69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:68 (PC: 0x1940fd8)
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
=>  68:         case m == nil && !local:
    69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
    97: func (c Core) SanityCheck() error {
    98:         if c.MinObject != nil && c.FullName.objectName != c.MinObject.Name {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:67 (PC: 0x1940fef)
    37:
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
=>  67:         switch {
    68:         case m == nil && !local:
    69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
    97: func (c Core) SanityCheck() error {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:68 (PC: 0x1940ff4)
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
=>  68:         case m == nil && !local:
    69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
    97: func (c Core) SanityCheck() error {
    98:         if c.MinObject != nil && c.FullName.objectName != c.MinObject.Name {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:69 (PC: 0x1940ffa)
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
    68:         case m == nil && !local:
=>  69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
    97: func (c Core) SanityCheck() error {
    98:         if c.MinObject != nil && c.FullName.objectName != c.MinObject.Name {
    99:                 return fmt.Errorf("inode name %q mismatches object name %q", c.FullName, c.MinObject.Name)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (PC: 0x19467f2)
Values returned:
        ~r0: ImplicitDirType (4)

   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
=> 682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:678 (PC: 0x19467fa)
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
=> 678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:680 (PC: 0x194680e)
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
=> 680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:678 (PC: 0x1946869)
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
=> 678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (PC: 0x1946873)
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
=> 682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:678 (PC: 0x194687f)
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
=> 678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:684 (PC: 0x194688f)
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
=> 684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
   713:         }
   714:         return
(dlv) p implicitDir
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing")(0xc00081d5c0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir1/"},
        ItemType: ImplicitDirType (4),}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (hits goroutine(102):2 total:2) (PC: 0x19467c9)
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
=> 682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614 (hits goroutine(102):1 total:1) (PC: 0x1946bd8)
   584:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
=> 614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
(dlv) bp   
Breakpoint runtime-fatal-throw (enabled) at 0x4464e4,0x45f38e,0x446404 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1946bd8 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614 (1)
Breakpoint 2 (enabled) at 0x1945b1e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623 (0)
Breakpoint 3 (enabled) at 0x194623a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648 (0)
Breakpoint 4 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 5 (enabled) at 0x19467c9 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (2)
(dlv) b 615
Breakpoint 6 set at 0x1946c87 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615
(dlv) toggle 614
Command failed: no breakpoint with id 614
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614 (hits goroutine(102):1 total:1) (PC: 0x1946bd8)
Warning: listing may not match stale executable
   584:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
=> 614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446404,0x4464e4,0x45f38e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1946bd8 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614 (1)
Breakpoint 2 (enabled) at 0x1945b1e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623 (0)
Breakpoint 3 (enabled) at 0x194623a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648 (0)
Breakpoint 4 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 5 (enabled) at 0x19467c9 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (2)
Breakpoint 6 (enabled) at 0x1946c87 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (0)
(dlv) toggle 1
Breakpoint 1 toggled at 0x1946bd8 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (hits goroutine(102):1 total:1) (PC: 0x1946c87)
Warning: listing may not match stale executable
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
=> 615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
(dlv) p c
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing")(0xc00081d5c0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir1/"},
        ItemType: ImplicitDirType (4),}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (hits goroutine(102):2 total:2) (PC: 0x1946c87)
Warning: listing may not match stale executable
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
=> 615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
(dlv) p c
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing")(0xc000e00000)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir2/"},
        ItemType: ImplicitDirType (4),}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (hits goroutine(102):3 total:3) (PC: 0x1946c87)
Warning: listing may not match stale executable
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
=> 615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
(dlv) p c
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing")(0xc00081d530)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file1"},
        ItemType: RegularFileType (2),}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (hits goroutine(102):4 total:4) (PC: 0x1946c87)
Warning: listing may not match stale executable
   585:         var listing *gcs.Listing
   586:         if !d.hasObjectsListBeenRead.Load() {
   587:
   588:                 // Ask the bucket to list some objects.
   589:                 req := &gcs.ListObjectsRequest{
   590:                         Delimiter:                "/",
   591:                         IncludeTrailingDelimiter: true,
   592:                         Prefix:                   d.Name().GcsObjectName(),
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
=> 615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
(dlv) p c
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing")(0xc00081d560)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing {
        FullName: github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "file2"},
        ItemType: RegularFileType (2),}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623 (hits goroutine(199):1 total:1) (PC: 0x1945b1e)
Warning: listing may not match stale executable
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
=> 623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
(dlv) n       
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p name
"file2"
(dlv) p objtype
RegularFileType (2)
(dlv) b
Breakpoint 7 set at 0x19469be for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x45f38e,0x446404,0x4464e4 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614
Breakpoint 2 (enabled) at 0x1945b1e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623 (1)
Breakpoint 3 (enabled) at 0x194623a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648 (0)
Breakpoint 4 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 5 (enabled) at 0x19467c9 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (2)
Breakpoint 6 (enabled) at 0x1946c87 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (4)
Breakpoint 7 (enabled) at 0x19469be for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (0)
(dlv) toggle 2
Breakpoint 2 toggled at 0x1945b1e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(199):1 total:1) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p name
"file2"
(dlv) p objtype
RegularFileType (2)
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(199):2 total:2) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p objtype
ImplicitDirType (4)
(dlv) p name   
"dir1"
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(199):3 total:3) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p name
"dir2"
(dlv) p objtype
ImplicitDirType (4)
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(199):4 total:4) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p name
"file1"
(dlv) p objtype
RegularFileType (2)
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(105):1 total:5) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(105):2 total:6) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(105):3 total:7) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(105):4 total:8) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(210):1 total:9) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(210):2 total:10) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(210):3 total:11) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(210):4 total:12) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(213):1 total:13) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(213):2 total:14) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(213):3 total:15) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(213):4 total:16) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(202):1 total:17) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p name
"dir1"
(dlv) p objtype
ImplicitDirType (4)
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(202):2 total:18) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(202):3 total:19) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(202):4 total:20) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(216):1 total:21) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(216):2 total:22) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(216):3 total:23) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(216):4 total:24) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(108):1 total:25) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(108):2 total:26) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(108):3 total:27) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(108):4 total:28) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(111):1 total:29) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(111):2 total:30) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) bt
 0  0x00000000019469be in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624
 1  0x0000000001946e25 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:693
 2  0x00000000019544cb in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:172
 3  0x0000000001954db3 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:245
 4  0x00000000019551bb in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:283
 5  0x000000000197211f in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2170
 6  0x0000000001958e09 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/wrappers/error_mapping.go:252
 7  0x000000000195ce8e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/wrappers/monitoring.go:282
 8  0x000000000193edbb in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
 9  0x000000000193dcc6 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
10  0x0000000000481d01 in runtime.goexit
    at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(111):3 total:31) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(111):4 total:32) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(217):1 total:33) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(217):2 total:34) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(217):3 total:35) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(217):4 total:36) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(227):1 total:37) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(227):2 total:38) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(227):3 total:39) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(227):4 total:40) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(206):1 total:41) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(206):2 total:42) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(206):3 total:43) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(206):4 total:44) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(241):1 total:45) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(241):2 total:46) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(241):3 total:47) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(241):4 total:48) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(28):1 total:49) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(28):2 total:50) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:627 (PC: 0x1946b1b)
Warning: listing may not match stale executable
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
=> 627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1946b22)
Warning: listing may not match stale executable
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
=> 623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(28):3 total:51) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p i
2
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(28):4 total:52) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(259):1 total:53) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p i
0
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(259):2 total:54) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p i
1
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(259):3 total:55) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p i
2
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(259):4 total:56) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p i
3
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:627 (PC: 0x1946b1b)
Warning: listing may not match stale executable
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
=> 627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623 (PC: 0x1946b22)
Warning: listing may not match stale executable
   593:                         ContinuationToken:        tok,
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
=> 623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:631 (PC: 0x1946025)
Warning: listing may not match stale executable
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
   624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
=> 631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
(dlv) p listing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000a43220)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 0, cap: 0, nil,
        CollapsedRuns: []string len: 0, cap: 0, nil,
        ContinuationToken: "",}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:664 (PC: 0x1946585)
Warning: listing may not match stale executable
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
=> 664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:666 (PC: 0x19465a7)
Warning: listing may not match stale executable
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
=> 666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
(dlv) p d.implicitDirs
true
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:671 (PC: 0x19465b9)
Warning: listing may not match stale executable
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
   655:                                 FullName: fileName,
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
=> 671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
(dlv) p listing       
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing")(0xc000a43220)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 0, cap: 0, nil,
        CollapsedRuns: []string len: 0, cap: 0, nil,
        ContinuationToken: "",}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:686 (PC: 0x1946945)
Warning: listing may not match stale executable
   656:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   657:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   658:                         }
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
=> 686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
   713:         }
   714:         return
   715: }
   716:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:693 (PC: 0x1946e25)
Values returned:
        cores: map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing nil
        newTok: ""
        err: error nil

Warning: listing may not match stale executable
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
=> 693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
   713:         }
   714:         return
   715: }
   716:
   717: // LOCKS_REQUIRED(d)
   718: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   719:         childMetadata := map[string]string{
   720:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   721:         }
   722:         fullName := NewFileName(d.Name(), name)
   723:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:694 (PC: 0x1946ee7)
Warning: listing may not match stale executable
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
=> 694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
   713:         }
   714:         return
   715: }
   716:
   717: // LOCKS_REQUIRED(d)
   718: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   719:         childMetadata := map[string]string{
   720:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   721:         }
   722:         fullName := NewFileName(d.Name(), name)
   723:
   724:         o, err := d.createNewObject(ctx, fullName, childMetadata)
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing nil
(dlv) p newTok
""
(dlv) p err
error nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:699 (PC: 0x1947024)
Warning: listing may not match stale executable
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
=> 699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
   713:         }
   714:         return
   715: }
   716:
   717: // LOCKS_REQUIRED(d)
   718: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   719:         childMetadata := map[string]string{
   720:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   721:         }
   722:         fullName := NewFileName(d.Name(), name)
   723:
   724:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   725:         if err != nil {
   726:                 return nil, err
   727:         }
   728:         m := storageutil.ConvertObjToMinObject(o)
   729:
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:714 (PC: 0x19472c5)
Warning: listing may not match stale executable
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
   689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
   713:         }
=> 714:         return
   715: }
   716:
   717: // LOCKS_REQUIRED(d)
   718: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   719:         childMetadata := map[string]string{
   720:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   721:         }
   722:         fullName := NewFileName(d.Name(), name)
   723:
   724:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   725:         if err != nil {
   726:                 return nil, err
   727:         }
   728:         m := storageutil.ConvertObjToMinObject(o)
   729:
   730:         d.cache.Insert(d.cacheClock.Now(), name, metadata.RegularFileType)
   731:         return &Core{
   732:                 Bucket:    d.Bucket(),
   733:                 FullName:  fullName,
   734:                 MinObject: m,
   735:         }, nil
   736: }
   737:
   738: func (d *dirInode) CreateLocalChildFile(name string) (*Core, error) {
   739:         fullName := NewFileName(d.Name(), name)
   740:
   741:         return &Core{
   742:                 Bucket:    d.Bucket(),
   743:                 FullName:  fullName,
   744:                 MinObject: nil,
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:172 (PC: 0x19544cb)
Values returned:
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        newTok: ""
        err: error nil

   142:
   143:                         return
   144:                 }
   145:
   146:                 // Repair whichever is not the directory.
   147:                 if eIsDir {
   148:                         prev.Name += inode.ConflictingFileNameSuffix
   149:                 } else {
   150:                         e.Name += inode.ConflictingFileNameSuffix
   151:                 }
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
=> 172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:173 (PC: 0x19545d7)
   143:                         return
   144:                 }
   145:
   146:                 // Repair whichever is not the directory.
   147:                 if eIsDir {
   148:                         prev.Name += inode.ConflictingFileNameSuffix
   149:                 } else {
   150:                         e.Name += inode.ConflictingFileNameSuffix
   151:                 }
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
=> 173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:179 (PC: 0x1954702)
   149:                 } else {
   150:                         e.Name += inode.ConflictingFileNameSuffix
   151:                 }
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
=> 179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:188 (PC: 0x195480e)
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
=> 188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:182 (PC: 0x195482e)
   152:         }
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
=> 182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
(dlv) p tok
""
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:183 (PC: 0x195483b)
   153:
   154:         return
   155: }
   156:
   157: // Read all entries for the directory, fix up conflicting names, and fill in
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
=> 183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:188 (PC: 0x195483d)
   158: // offset fields.
   159: //
   160: // LOCKS_REQUIRED(in)
   161: func readAllEntries(
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
=> 188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:192 (PC: 0x1954946)
   162:         ctx context.Context,
   163:         in inode.DirInode,
   164:         localEntries []fuseutil.Dirent) (entries []fuseutil.Dirent, err error) {
   165:         // Read entries from GCS.
   166:         // Read one batch at a time.
   167:         var tok string
   168:         for {
   169:                 // Read a batch.
   170:                 var batch []fuseutil.Dirent
   171:
   172:                 batch, tok, err = in.ReadEntries(ctx, tok)
   173:                 if err != nil {
   174:                         err = fmt.Errorf("ReadEntries: %w", err)
   175:                         return
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
=> 192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:206 (PC: 0x1954965)
   176:                 }
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
=> 206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Breakpoint 8 set at 0x1946d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:689
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Breakpoint 9 set at 0x1968096 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:1314
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 10 set at 0x1971dd6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) p entries
[]github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:207 (PC: 0x195498f)
   177:
   178:                 // Accumulate.
   179:                 entries = append(entries, batch...)
   180:
   181:                 // Are we done?
   182:                 if tok == "" {
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
=> 207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:213 (PC: 0x1954abc)
   183:                         break
   184:                 }
   185:         }
   186:
   187:         // Append local file entries (not synced to GCS).
   188:         entries = append(entries, localEntries...)
   189:
   190:         // Ensure that the entries are sorted, for use in fixConflictingNames
   191:         // below.
   192:         sort.Sort(sortedDirents(entries))
   193:
   194:         // Fix name conflicts.
   195:         // When a local file is synced to GCS but not removed from the local file map,
   196:         // the entries list will have two duplicate entries.
   197:         // To handle this scenario, we had 2 options:
   198:         // Option 1: [Selected]
   199:         // Throw an error while fixing conflicting names. The error will be fixed in
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
=> 213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:230 (PC: 0x1954b24)
   200:         // subsequent ls calls assuming that entry will be removed from localFileInodes.
   201:         // Option 2: [Not Selected]
   202:         // Restrict fixConflictingNames to only GCS entries and show duplicate
   203:         // entries when ReadDir is called. In this case, a local file can have
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
=> 230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:234 (PC: 0x1954b89)
   204:         // same name as directory and LookUpInode call will fetch directory details
   205:         // for both of them.
   206:         err = fixConflictingNames(entries)
   207:         if err != nil {
   208:                 err = fmt.Errorf("fixConflictingNames: %w", err)
   209:                 return
   210:         }
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
=> 234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:245 (PC: 0x1954db3)
Values returned:
        entries: []github.com/jacobsa/fuse/fuseutil.Dirent len: 0, cap: 0, nil
        err: error nil

   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
=> 245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:246 (PC: 0x1954e72)
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
=> 246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:252 (PC: 0x1954f87)
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
=> 252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:253 (PC: 0x1954fd6)
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
=> 253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:255 (PC: 0x1954fe4)
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
   241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
=> 255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:283 (PC: 0x19551bb)
Values returned:
        err: error nil

   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
=> 283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:284 (PC: 0x19551c5)
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
=> 284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:291 (PC: 0x19551d7)
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
=> 291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p op.Offset
0
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:292 (PC: 0x19551ea)
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
=> 292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) p index
0
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:298 (PC: 0x1955234)
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
   272:         op *fuseops.ReadDirOp,
   273:         localFileEntries []fuseutil.Dirent) (err error) {
   274:         // If the request is for offset zero, we assume that either this is the first
   275:         // call or rewinddir has been called. Reset state.
   276:         if op.Offset == 0 {
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
=> 298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
   307:         return
   308: }
(dlv) n 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:307 (PC: 0x19553a7)
   277:                 dh.entries = nil
   278:                 dh.entriesValid = false
   279:         }
   280:
   281:         // Do we need to read entries from GCS?
   282:         if !dh.entriesValid {
   283:                 err = dh.ensureEntries(ctx, localFileEntries)
   284:                 if err != nil {
   285:                         return
   286:                 }
   287:         }
   288:
   289:         // Is the offset past the end of what we have buffered? If so, this must be
   290:         // an invalid seekdir according to posix.
   291:         index := int(op.Offset)
   292:         if index > len(dh.entries) {
   293:                 err = fuse.EINVAL
   294:                 return
   295:         }
   296:
   297:         // We copy out entries until we run out of entries or space.
   298:         for i := index; i < len(dh.entries); i++ {
   299:                 n := fuseutil.WriteDirent(op.Dst[op.BytesRead:], dh.entries[i])
   300:                 if n == 0 {
   301:                         break
   302:                 }
   303:
   304:                 op.BytesRead += n
   305:         }
   306:
=> 307:         return
   308: }
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2170 (PC: 0x197211f)
Values returned:
        err: error nil

  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
=>2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
  2191: }
  2192:
  2193: // LOCKS_EXCLUDED(fs.mu)
  2194: func (fs *fileSystem) OpenFile(
  2195:         ctx context.Context,
  2196:         op *fuseops.OpenFileOp) (err error) {
  2197:         fs.mu.Lock()
  2198:         defer fs.mu.Unlock()
  2199:
  2200:         // Find the inode.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2174 (PC: 0x1972164)
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
  2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
=>2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
  2179:         ctx context.Context,
  2180:         op *fuseops.ReleaseDirHandleOp) (err error) {
  2181:         fs.mu.Lock()
  2182:         defer fs.mu.Unlock()
  2183:
  2184:         // Sanity check that this handle exists and is of the correct type.
  2185:         _ = fs.handles[op.Handle].(*handle.DirHandle)
  2186:
  2187:         // Clear the entry from the map.
  2188:         delete(fs.handles, op.Handle)
  2189:
  2190:         return
  2191: }
  2192:
  2193: // LOCKS_EXCLUDED(fs.mu)
  2194: func (fs *fileSystem) OpenFile(
  2195:         ctx context.Context,
  2196:         op *fuseops.OpenFileOp) (err error) {
  2197:         fs.mu.Lock()
  2198:         defer fs.mu.Unlock()
  2199:
  2200:         // Find the inode.
  2201:         in := fs.fileInodeOrDie(op.Inode)
  2202:
  2203:         // Allocate a handle.
  2204:         handleID := fs.nextHandleID
(dlv) p err
error nil
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(228):1 total:1) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:689 (hits goroutine(228):1 total:1) (PC: 0x1946d76)
Warning: listing may not match stale executable
   659:                         cores[fileName] = file
   660:                 }
   661:         }
   662:
   663:         // Return an appropriate continuation token, if any.
   664:         newTok = listing.ContinuationToken
   665:
   666:         if !d.implicitDirs {
   667:                 return
   668:         }
   669:
   670:         // Add implicit directories into the result.
   671:         for _, p := range listing.CollapsedRuns {
   672:                 pathBase := path.Base(p)
   673:                 dirName := NewDirName(d.Name(), pathBase)
   674:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   675:                         continue
   676:                 }
   677:
   678:                 implicitDir := &MinCoreForListing{
   679:                         // Bucket:    d.Bucket(),
   680:                         FullName: dirName,
   681:                         // MinObject: nil,
   682:                         ItemType: TypeFromMinCore(nil, false, dirName),
   683:                 }
   684:                 cores[dirName] = implicitDir
   685:         }
   686:         return
   687: }
   688:
=> 689: func (d *dirInode) ReadEntries(
   690:         ctx context.Context,
   691:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   692:         var cores map[Name]*MinCoreForListing
   693:         cores, newTok, err = d.readObjects(ctx, tok)
   694:         if err != nil {
   695:                 err = fmt.Errorf("read objects: %w", err)
   696:                 return
   697:         }
   698:
   699:         for fullName, core := range cores {
   700:                 entry := fuseutil.Dirent{
   701:                         Name: path.Base(fullName.LocalName()),
   702:                         Type: fuseutil.DT_Unknown,
   703:                 }
   704:                 switch core.Type() {
   705:                 case metadata.SymlinkType:
   706:                         entry.Type = fuseutil.DT_Link
   707:                 case metadata.RegularFileType:
   708:                         entry.Type = fuseutil.DT_File
   709:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   710:                         entry.Type = fuseutil.DT_Directory
   711:                 }
   712:                 entries = append(entries, entry)
   713:         }
   714:         return
   715: }
   716:
   717: // LOCKS_REQUIRED(d)
   718: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   719:         childMetadata := map[string]string{
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446404,0x4464e4,0x45f38e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614
Breakpoint 2 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623
Breakpoint 3 (enabled) at 0x194623a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648 (0)
Breakpoint 4 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 5 (enabled) at 0x19467c9 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (2)
Breakpoint 6 (enabled) at 0x1946c87 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (4)
Breakpoint 7 (enabled) at 0x19469be for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (56)
Breakpoint 8 (enabled) at 0x1946d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:689 (1)
Breakpoint 9 (enabled) at 0x1968096 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:1314 (0)
Breakpoint 10 (enabled) at 0x1971dd6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (1)
(dlv) toggle 8
Breakpoint 8 toggled at 0x1946d76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:689
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(228):1 total:57) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(228):2 total:58) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(228):3 total:59) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(228):4 total:60) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(31):1 total:2) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc00069b270)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 16,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 120, Pid: 1847614, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(31):1 total:61) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(31):2 total:62) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(31):3 total:63) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(31):4 total:64) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(275):1 total:3) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0008200a0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 17,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 126, Pid: 1847614, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(275):1 total:65) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(275):2 total:66) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p i
1
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(275):3 total:67) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p i
2
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(275):4 total:68) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) p i
3
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(32):1 total:4) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0007cb6d0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 18,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 132, Pid: 1847614, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (hits goroutine(32):1 total:69) (PC: 0x19469be)
Warning: listing may not match stale executable
   594:                         MaxResults:               MaxResultsForListObjectsCall,
   595:                         // Setting Projection param to noAcl since fetching owner and acls are not
   596:                         // required.
   597:                         ProjectionVal:            gcs.NoAcl,
   598:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   599:                 }
   600:
   601:                 listing, err = d.bucket.ListObjects(ctx, req)
   602:                 if err != nil {
   603:                         err = fmt.Errorf("ListObjects: %w", err)
   604:                         return
   605:                 }
   606:
   607:                 PrintGcsListing(listing, func(s string) {
   608:                         logger.Debugf("ListObjects: " + s)
   609:                 })
   610:
   611:                 cores = make(map[Name]*MinCoreForListing)
   612:                 defer func() {
   613:                         now := d.cacheClock.Now()
   614:                         for fullName, c := range cores {
   615:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   616:                         }
   617:                 }()
   618:
   619:                 d.hasObjectsListBeenRead.Store(true)
   620:         } else {
   621:                 listing = &(gcs.Listing{})
   622:                 i := 0
   623:                 for name, objtype := range d.cache.Index() {
=> 624:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   625:                         // switch  {
   626:                         // }
   627:                         i++
   628:                 }
   629:         }
   630:
   631:         for _, o := range listing.Objects {
   632:                 // Skip empty results or the directory object backing this inode.
   633:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   634:                         continue
   635:                 }
   636:
   637:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   638:
   639:                 // Given the alphabetical order of the objects, if a file "foo" and
   640:                 // directory "foo/" coexist, the directory would eventually occupy
   641:                 // the value of records["foo"].
   642:                 if strings.HasSuffix(o.Name, "/") {
   643:                         dirName := NewDirName(d.Name(), nameBase)
   644:                         explicitDir := &MinCoreForListing{
   645:                                 // Bucket:    d.Bucket(),
   646:                                 FullName: dirName,
   647:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   648:                                 ItemType: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   649:                         }
   650:                         cores[dirName] = explicitDir
   651:                 } else {
   652:                         fileName := NewFileName(d.Name(), nameBase)
   653:                         file := &MinCoreForListing{
   654:                                 // Bucket:    d.Bucket(),
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446404,0x4464e4,0x45f38e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:614
Breakpoint 2 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:623
Breakpoint 3 (enabled) at 0x194623a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:648 (0)
Breakpoint 4 (disabled) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 5 (enabled) at 0x19467c9 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:682 (2)
Breakpoint 6 (enabled) at 0x1946c87 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:615 (4)
Breakpoint 7 (enabled) at 0x19469be for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624 (69)
Breakpoint 8 (disabled) at github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Breakpoint 9 (enabled) at 0x1968096 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:1314 (0)
Breakpoint 10 (enabled) at 0x1971dd6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (4)
(dlv) toggle 7
Breakpoint 7 toggled at 0x19469be for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:624
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(222):1 total:5) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op    
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0007ca4b0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 19,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 138, Pid: 1847614, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(224):1 total:6) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0007ca5a0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 20,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 144, Pid: 1847614, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(245):1 total:7) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0001833b0)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 21,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 150, Pid: 1847614, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(289):1 total:8) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0007cab90)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 22,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 156, Pid: 1847614, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(292):1 total:9) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0007cad20)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 23,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 162, Pid: 1847614, Uid: 1012083},}
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(295):1 total:10) (PC: 0x1971dd6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) p op
("*github.com/jacobsa/fuse/fuseops.ReadDirOp")(0xc0007caf00)
*github.com/jacobsa/fuse/fuseops.ReadDirOp {
        Inode: 1,
        Handle: 24,
        Offset: 0,
        Dst: []uint8 len: 4096, cap: 4096, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+4032 more],
        BytesRead: 0,
        OpContext: github.com/jacobsa/fuse/fuseops.OpContext {FuseID: 168, Pid: 1847614, Uid: 1012083},}
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$                                                                                
If you do not reboot now, your system will reboot automatically                
at Fri May 17 02:52:10 UTC 2024. For more info, see go/glinux-reboot-policy.   
To reboot your computer 10 hours from now, on the command line run:            
echo systemctl reboot | at now + 10 hours                                      
Also you may have a pending maintenance. See go/cloudtop-faq#cloudtop-maintenan
ce-scheduler                                                                   
To run maintenance in 10 hours run:                                            
ctop self maintenance schedule in 10h
                                                                               
^C
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$ pwd
/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
# github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode
../../src/gcsfuse/internal/fs/inode/dir.go:673:9: duplicate case metadata.RegularFileType (constant 2 of type "github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata".Type) in expression switch
        ../../src/gcsfuse/internal/fs/inode/dir.go:671:17: previous case
../../src/gcsfuse/internal/fs/inode/dir.go:675:9: duplicate case metadata.RegularFileType (constant 2 of type "github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata".Type) in expression switch
        ../../src/gcsfuse/internal/fs/inode/dir.go:671:17: previous case
../../src/gcsfuse/internal/fs/inode/dir.go:677:9: duplicate case metadata.RegularFileType (constant 2 of type "github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata".Type) in expression switch
        ../../src/gcsfuse/internal/fs/inode/dir.go:671:17: previous case
../../src/gcsfuse/internal/fs/inode/dir.go:701:65: cannot use o (variable of type *MinObjectForListing) as *gcs.Object value in argument to storageutil.ConvertObjToMinObject
../../src/gcsfuse/internal/fs/inode/dir.go:710:65: cannot use o (variable of type *MinObjectForListing) as *gcs.Object value in argument to storageutil.ConvertObjToMinObject
exit status 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
# github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode
../../src/gcsfuse/internal/fs/inode/dir.go:693:65: cannot use o (variable of type *MinObjectForListing) as *gcs.Object value in argument to storageutil.ConvertObjToMinObject
../../src/gcsfuse/internal/fs/inode/dir.go:702:65: cannot use o (variable of type *MinObjectForListing) as *gcs.Object value in argument to storageutil.ConvertObjToMinObject
exit status 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
# github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode
../../src/gcsfuse/internal/fs/inode/dir.go:702:65: cannot use o (variable of type *MinObjectForListing) as *gcs.Object value in argument to storageutil.ConvertObjToMinObject
exit status 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$ pwd                                                
/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
# github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode
../../src/gcsfuse/internal/fs/inode/dir.go:702:65: cannot use o (variable of type *MinObjectForListing) as *gcs.Object value in argument to storageutil.ConvertObjToMinObject
exit status 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
# github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode
../../src/gcsfuse/internal/fs/inode/dir.go:668:12: undefined: logger.Warningf
exit status 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
# github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode
../../src/gcsfuse/internal/fs/inode/dir.go:668:12: undefined: logger.Warning
exit status 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) q   
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972396 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 1972396
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Breakpoint 3 set at 0x1947167 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 4 set at 0x194632d for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Breakpoint 5 set at 0x1945e86 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 6 set at 0x1946635 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Breakpoint 7 set at 0x19467c5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
(dlv) c
{"timestamp":{"seconds":1715314135,"nanos":179984993},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(147):1 total:1) (PC: 0x1972396)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
Process 3084545 has exited with status 1
(dlv) bt
Process 3084545 has exited with status 1
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:585
Breakpoint 1 set at 0x19453d6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:585
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Breakpoint 2 set at 0x1947167 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 3 set at 0x194632d for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Breakpoint 4 set at 0x1945e86 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 5 set at 0x1946635 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Breakpoint 6 set at 0x19467c5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
(dlv) c
{"timestamp":{"seconds":1715314269,"nanos":528975583},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:585 (hits goroutine(91):1 total:1) (PC: 0x19453d6)
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
=> 585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:587 (PC: 0x1945430)
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
=> 587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:589 (PC: 0x1945559)
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
=> 589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:591 (PC: 0x19455d0)
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
=> 591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
(dlv) p strs
[]string len: 2, cap: 2, [
        "gcs.listing={",
        "    listing.ContinuationToken=\"\"",
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:592 (PC: 0x1945676)
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
=> 592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:593 (PC: 0x19456e1)
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
=> 593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:592 (PC: 0x1945827)
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
=> 592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:593 (PC: 0x19456e1)
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
=> 593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:592 (PC: 0x1945827)
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
=> 592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:593 (PC: 0x19456e1)
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
=> 593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:592 (PC: 0x1945827)
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
=> 592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:595 (PC: 0x1945831)
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
=> 595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:597 (PC: 0x194587a)
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
=> 597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
(dlv) p strs
[]string len: 7, cap: 8, [
        "gcs.listing={",
        "    listing.ContinuationToken=\"\"",
        "",
        "    Objects=[",
        "        object=&gcs.Object{Name:\"\", ContentType:\"text/plain\", Co...+678 more",
        "        object=&gcs.Object{Name:\"file1\", ContentType:\"text/plain...+687 more",
        "        object=&gcs.Object{Name:\"file2\", ContentType:\"text/plain...+687 more",
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:598 (PC: 0x194592a)
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
=> 598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
(dlv) p listing.CollapsedRuns
[]string len: 2, cap: 2, ["dir1/","dir2/"]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:599 (PC: 0x19459b8)
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
=> 599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:598 (PC: 0x1945b05)
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
=> 598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:599 (PC: 0x19459b8)
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
=> 599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:598 (PC: 0x1945b05)
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
=> 598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:601 (PC: 0x1945b25)
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
=> 601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
(dlv) p strs
[]string len: 11, cap: 16, [
        "gcs.listing={",
        "    listing.ContinuationToken=\"\"",
        "",
        "    Objects=[",
        "        object=&gcs.Object{Name:\"\", ContentType:\"text/plain\", Co...+678 more",
        "        object=&gcs.Object{Name:\"file1\", ContentType:\"text/plain...+687 more",
        "        object=&gcs.Object{Name:\"file2\", ContentType:\"text/plain...+687 more",
        "    ]",
        "    CollapsedRuns=[",
        "        \"dir1/\"",
        "        \"dir2/\"",
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:603 (PC: 0x1945b70)
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
=> 603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
   608: // purely for debugging and logging. Remove later!
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.StrsOfGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:605 (PC: 0x1945c23)
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
=> 605:         return
   606: }
   607:
   608: // purely for debugging and logging. Remove later!
   609: func PrintGcsListing(listing *gcs.Listing, printFn func(string)) {
   610:         for _, str := range StrsOfGcsListing(listing) {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.PrintGcsListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:610 (PC: 0x1945c87)
Values returned:
        strs: []string len: 13, cap: 16, [
                "gcs.listing={",
                "    listing.ContinuationToken=\"\"",
                "",
                "    Objects=[",
                "        object=&gcs.Object{Name:\"\", ContentType:\"text/plain\", Co...+678 more",
                "        object=&gcs.Object{Name:\"file1\", ContentType:\"text/plain...+687 more",
                "        object=&gcs.Object{Name:\"file2\", ContentType:\"text/plain...+687 more",
                "    ]",
                "    CollapsedRuns=[",
                "        \"dir1/\"",
                "        \"dir2/\"",
                "    ]",
                "}",
        ]

   605:         return
   606: }
   607:
   608: // purely for debugging and logging. Remove later!
   609: func PrintGcsListing(listing *gcs.Listing, printFn func(string)) {
=> 610:         for _, str := range StrsOfGcsListing(listing) {
   611:                 printFn(str)
   612:         }
   613: }
   614:
   615: // LOCKS_REQUIRED(d)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:643 (PC: 0x194625f)
Values returned:

   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
=> 643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:647 (PC: 0x1946260)
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
=> 647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:241 (PC: 0x195562a)
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
=> 241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
(dlv) bt
 0  0x000000000195562a in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:241
 1  0x00000000004459f6 in runtime.gopanic
    at /usr/lib/google-golang/src/runtime/panic.go:759
 2  0x0000000000444339 in runtime.goPanicIndex
    at /usr/lib/google-golang/src/runtime/panic.go:114
 3  0x0000000001945385 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
 4  0x0000000001946325 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:655
 5  0x0000000001947305 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:740
 6  0x0000000001954a8b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:172
 7  0x0000000001955373 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:245
 8  0x000000000195577b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:283
 9  0x00000000019726df in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2170
10  0x00000000019593c9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/wrappers/error_mapping.go:252
11  0x000000000195d44e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/wrappers/monitoring.go:282
12  0x000000000193edbb in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
13  0x000000000193dcc6 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
14  0x0000000000481d01 in runtime.goexit
    at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972396 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 1972396
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Breakpoint 3 set at 0x1945312 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Breakpoint 4 set at 0x1947167 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 5 set at 0x194632d for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Breakpoint 6 set at 0x1945e86 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 7 set at 0x1946635 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Breakpoint 8 set at 0x19467c5 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
(dlv) c
{"timestamp":{"seconds":1715314450,"nanos":712122678},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(170):1 total:1) (PC: 0x1972396)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (hits goroutine(170):1 total:1) (PC: 0x1945312)
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for k, v := range listing.Objects {
=> 577:                 minListing.Objects[k] = ObjectToMinObjectForListing(v)
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) p listing.Objectd
Command failed: listing has no member Objectd
(dlv) p listing.Objects
[]*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 3, cap: 4, [
        *{
                Name: "",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 0,
                ContentEncoding: "",
                MD5: *[16]uint8 [212,29,140,217,143,0,178,4,233,128,9,152,236,248,66,126],
                CRC32C: *0,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2F?generation=171...+23 more",
                Metadata: map[string]string nil,
                Generation: 1715237031570514,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c470),
                Updated: (*time.Time)(0xc000d2c488),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
        *{
                Name: "file1",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2Ffile1?generatio...+28 more",
                Metadata: map[string]string nil,
                Generation: 1715238786092575,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c5b0),
                Updated: (*time.Time)(0xc000d2c5c8),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
        *{
                Name: "file2",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2Ffile2?generatio...+28 more",
                Metadata: map[string]string nil,
                Generation: 1715238789088815,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c6f0),
                Updated: (*time.Time)(0xc000d2c708),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
]
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (hits goroutine(170):1 total:1) (PC: 0x1945312)
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for k, v := range listing.Objects {
=> 577:                 minListing.Objects[k] = ObjectToMinObjectForListing(v)
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) p k
0
(dlv) p listing.Objects
[]*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 3, cap: 4, [
        *{
                Name: "",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 0,
                ContentEncoding: "",
                MD5: *[16]uint8 [212,29,140,217,143,0,178,4,233,128,9,152,236,248,66,126],
                CRC32C: *0,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2F?generation=171...+23 more",
                Metadata: map[string]string nil,
                Generation: 1715237031570514,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c470),
                Updated: (*time.Time)(0xc000d2c488),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
        *{
                Name: "file1",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2Ffile1?generatio...+28 more",
                Metadata: map[string]string nil,
                Generation: 1715238786092575,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c5b0),
                Updated: (*time.Time)(0xc000d2c5c8),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
        *{
                Name: "file2",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2Ffile2?generatio...+28 more",
                Metadata: map[string]string nil,
                Generation: 1715238789088815,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c6f0),
                Updated: (*time.Time)(0xc000d2c708),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
]
(dlv) 
[]*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 3, cap: 4, [
        *{
                Name: "",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 0,
                ContentEncoding: "",
                MD5: *[16]uint8 [212,29,140,217,143,0,178,4,233,128,9,152,236,248,66,126],
                CRC32C: *0,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2F?generation=171...+23 more",
                Metadata: map[string]string nil,
                Generation: 1715237031570514,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c470),
                Updated: (*time.Time)(0xc000d2c488),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
        *{
                Name: "file1",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2Ffile1?generatio...+28 more",
                Metadata: map[string]string nil,
                Generation: 1715238786092575,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c5b0),
                Updated: (*time.Time)(0xc000d2c5c8),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
        *{
                Name: "file2",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2Ffile2?generatio...+28 more",
                Metadata: map[string]string nil,
                Generation: 1715238789088815,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc000d2c6f0),
                Updated: (*time.Time)(0xc000d2c708),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
]
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
# github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode
../../src/gcsfuse/internal/fs/inode/dir.go:576:6: `k' declared and not used
exit status 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x19723f6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 19723f6
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Breakpoint 3 set at 0x1945325 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Breakpoint 4 set at 0x19471c7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 5 set at 0x194638d for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Breakpoint 6 set at 0x1945ee6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 7 set at 0x1946695 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Breakpoint 8 set at 0x1946825 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706 at 1946825
(dlv) c
{"timestamp":{"seconds":1715314573,"nanos":850025536},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(116):1 total:1) (PC: 0x19723f6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (hits goroutine(116):1 total:1) (PC: 0x1945325)
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
=> 577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) p v
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00063cb40)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object {
        Name: "",
        ContentType: "text/plain",
        ContentLanguage: "",
        CacheControl: "",
        Owner: "",
        Size: 0,
        ContentEncoding: "",
        MD5: *[16]uint8 [212,29,140,217,143,0,178,4,233,128,9,152,236,248,66,126],
        CRC32C: *0,
        MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2F?generation=171...+23 more",
        Metadata: map[string]string nil,
        Generation: 1715237031570514,
        MetaGeneration: 1,
        StorageClass: "STANDARD",
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(2024-05-09T06:43:51Z){
                wall: 616000000,
                ext: 63850833831,
                loc: *time.Location nil,},
        ComponentCount: 0,
        ContentDisposition: "",
        CustomTime: "0001-01-01T00:00:00Z",
        EventBasedHold: false,
        Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,}
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (hits goroutine(116):1 total:1) (PC: 0x1945325)
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
=> 577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:555 (PC: 0x194506e)
   525:                 for _, o := range listing.Objects {
   526:                         if len(descendants) >= limit {
   527:                                 return descendants, nil
   528:                         }
   529:                         // skip the current directory
   530:                         if o.Name == d.Name().GcsObjectName() {
   531:                                 continue
   532:                         }
   533:                         name := NewDescendantName(d.Name(), o.Name)
   534:                         descendants[name] = &Core{
   535:                                 Bucket:    d.Bucket(),
   536:                                 FullName:  name,
   537:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   538:                         }
   539:                 }
   540:
   541:                 // Are we done listing?
   542:                 if tok = listing.ContinuationToken; tok == "" {
   543:                         return descendants, nil
   544:                 }
   545:         }
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
=> 555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:556 (PC: 0x1945083)
   526:                         if len(descendants) >= limit {
   527:                                 return descendants, nil
   528:                         }
   529:                         // skip the current directory
   530:                         if o.Name == d.Name().GcsObjectName() {
   531:                                 continue
   532:                         }
   533:                         name := NewDescendantName(d.Name(), o.Name)
   534:                         descendants[name] = &Core{
   535:                                 Bucket:    d.Bucket(),
   536:                                 FullName:  name,
   537:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   538:                         }
   539:                 }
   540:
   541:                 // Are we done listing?
   542:                 if tok = listing.ContinuationToken; tok == "" {
   543:                         return descendants, nil
   544:                 }
   545:         }
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
=> 556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:560 (PC: 0x1945093)
   530:                         if o.Name == d.Name().GcsObjectName() {
   531:                                 continue
   532:                         }
   533:                         name := NewDescendantName(d.Name(), o.Name)
   534:                         descendants[name] = &Core{
   535:                                 Bucket:    d.Bucket(),
   536:                                 FullName:  name,
   537:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   538:                         }
   539:                 }
   540:
   541:                 // Are we done listing?
   542:                 if tok = listing.ContinuationToken; tok == "" {
   543:                         return descendants, nil
   544:                 }
   545:         }
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
=> 560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
(dlv) p o
("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object")(0xc00063cb40)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object {
        Name: "",
        ContentType: "text/plain",
        ContentLanguage: "",
        CacheControl: "",
        Owner: "",
        Size: 0,
        ContentEncoding: "",
        MD5: *[16]uint8 [212,29,140,217,143,0,178,4,233,128,9,152,236,248,66,126],
        CRC32C: *0,
        MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2F?generation=171...+23 more",
        Metadata: map[string]string nil,
        Generation: 1715237031570514,
        MetaGeneration: 1,
        StorageClass: "STANDARD",
        Deleted: time.Time(0001-01-01T00:00:00Z){
                wall: 0,
                ext: 0,
                loc: *time.Location nil,},
        Updated: time.Time(2024-05-09T06:43:51Z){
                wall: 616000000,
                ext: 63850833831,
                loc: *time.Location nil,},
        ComponentCount: 0,
        ContentDisposition: "",
        CustomTime: "0001-01-01T00:00:00Z",
        EventBasedHold: false,
        Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,}
(dlv) frame 1
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:560 (PC: 0x1945093)
Frame 1: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (PC: 194532a)
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
=> 577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) frame 2
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:560 (PC: 0x1945093)
Frame 2: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:655 (PC: 1946385)
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
=> 655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
(dlv) p gcsListing.Objects
[]*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object len: 3, cap: 4, [
        *{
                Name: "",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 0,
                ContentEncoding: "",
                MD5: *[16]uint8 [212,29,140,217,143,0,178,4,233,128,9,152,236,248,66,126],
                CRC32C: *0,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2F?generation=171...+23 more",
                Metadata: map[string]string nil,
                Generation: 1715237031570514,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc00063cbf0),
                Updated: (*time.Time)(0xc00063cc08),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
        *{
                Name: "file1",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2Ffile1?generatio...+28 more",
                Metadata: map[string]string nil,
                Generation: 1715238786092575,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc00063cd30),
                Updated: (*time.Time)(0xc00063cd48),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
        *{
                Name: "file2",
                ContentType: "text/plain",
                ContentLanguage: "",
                CacheControl: "",
                Owner: "",
                Size: 6,
                ContentEncoding: "",
                MD5: *[16]uint8 [177,148,106,201,36,146,210,52,124,98,53,180,210,97,17,132],
                CRC32C: *893245630,
                MediaLink: "https://storage.googleapis.com/download/storage/v1/b/gargnitin-empty-bucket/o/list-through-metadata-cache-expt%2Ffile2?generatio...+28 more",
                Metadata: map[string]string nil,
                Generation: 1715238789088815,
                MetaGeneration: 1,
                StorageClass: "STANDARD",
                Deleted: (*time.Time)(0xc00063d0f0),
                Updated: (*time.Time)(0xc00063d108),
                ComponentCount: 0,
                ContentDisposition: "",
                CustomTime: "0001-01-01T00:00:00Z",
                EventBasedHold: false,
                Acl: []*google.golang.org/api/storage/v1.ObjectAccessControl len: 0, cap: 0, nil,},
]
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) help
The following commands are available:

Running the program:
    call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!)
    continue (alias: c) --------- Run until breakpoint or program termination.
    next (alias: n) ------------- Step over to next source line.
    rebuild --------------------- Rebuild the target executable and restarts it. It does not work if the executable was not built by delve.
    restart (alias: r) ---------- Restart process.
    step (alias: s) ------------- Single step through program.
    step-instruction (alias: si)  Single step a single cpu instruction.
    stepout (alias: so) --------- Step out of the current function.

Manipulating breakpoints:
    break (alias: b) ------- Sets a breakpoint.
    breakpoints (alias: bp)  Print out info for active breakpoints.
    clear ------------------ Deletes breakpoint.
    clearall --------------- Deletes multiple breakpoints.
    condition (alias: cond)  Set breakpoint condition.
    on --------------------- Executes a command when a breakpoint is hit.
    toggle ----------------- Toggles on or off a breakpoint.
    trace (alias: t) ------- Set tracepoint.
    watch ------------------ Set watchpoint.

Viewing program variables and memory:
    args ----------------- Print function arguments.
    display -------------- Print value of an expression every time the program stops.
    examinemem (alias: x)  Examine raw memory at the given address.
    locals --------------- Print local variables.
    print (alias: p) ----- Evaluate an expression.
    regs ----------------- Print contents of CPU registers.
    set ------------------ Changes the value of a variable.
    vars ----------------- Print package variables.
    whatis --------------- Prints type of an expression.

Listing and switching between threads and goroutines:
    goroutine (alias: gr) -- Shows or changes current goroutine
    goroutines (alias: grs)  List program goroutines.
    thread (alias: tr) ----- Switch to the specified thread.
    threads ---------------- Print out info for every traced thread.

Viewing the call stack and selecting frames:
    deferred --------- Executes command in the context of a deferred call.
    down ------------- Move the current frame down.
    frame ------------ Set the current frame, or execute command on a different frame.
    stack (alias: bt)  Print stack trace.
    up --------------- Move the current frame up.

Other commands:
    config --------------------- Changes configuration parameters.
    disassemble (alias: disass)  Disassembler.
    dump ----------------------- Creates a core dump from the current process state
    edit (alias: ed) ----------- Open where you are in $DELVE_EDITOR or $EDITOR
    exit (alias: quit | q) ----- Exit the debugger.
    funcs ---------------------- Print list of functions.
    help (alias: h) ------------ Prints the help message.
    libraries ------------------ List loaded dynamic libraries
    list (alias: ls | l) ------- Show source code.
    packages ------------------- Print list of packages.
    source --------------------- Executes a file containing a list of delve commands
    sources -------------------- Print list of source files.
    target --------------------- Manages child process debugging.
    transcript ----------------- Appends command output to a file.
    types ---------------------- Print list of types

Type help followed by a command for full documentation.
(dlv) funcs ReadDir
github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir.deferwrap1
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir.deferwrap1
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
github.com/jacobsa/fuse/fuseutil.(*NotImplementedFileSystem).ReadDir
internal/poll.(*FD).ReadDirent
internal/poll.(*FD).ReadDirent.deferwrap1
io/ioutil.ReadDir
io/ioutil.ReadDir.func1
os.(*File).ReadDir
os.(*fileWithoutReadFrom).ReadDir
os.(*fileWithoutWriteTo).ReadDir
os.ReadDir
os.ReadDir.deferwrap1
os.ReadDir.func1
os.fileWithoutReadFrom.ReadDir
os.fileWithoutWriteTo.ReadDir
syscall.ReadDirent
(dlv) r
Process restarted with PID 3094340
(dlv) c
{"timestamp":{"seconds":1715315043,"nanos":611165381},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
Process 3094340 has exited with status 1
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) ^C
(dlv) 
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Breakpoint 1 set at 0x1945325 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Breakpoint 2 set at 0x19471c7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 3 set at 0x194638d for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Breakpoint 4 set at 0x1945ee6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:680
Breakpoint 5 set at 0x1946464 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:680
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 6 set at 0x1946695 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Breakpoint 7 set at 0x1946825 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706 at 1946825
(dlv) c
{"timestamp":{"seconds":1715315118,"nanos":827634798},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (hits goroutine(179):1 total:1) (PC: 0x1945325)
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
=> 577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) b 556
Breakpoint 9 set at 0x1945083 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:556
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:556 (hits goroutine(179):1 total:1) (PC: 0x1945083)
   526:                         if len(descendants) >= limit {
   527:                                 return descendants, nil
   528:                         }
   529:                         // skip the current directory
   530:                         if o.Name == d.Name().GcsObjectName() {
   531:                                 continue
   532:                         }
   533:                         name := NewDescendantName(d.Name(), o.Name)
   534:                         descendants[name] = &Core{
   535:                                 Bucket:    d.Bucket(),
   536:                                 FullName:  name,
   537:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   538:                         }
   539:                 }
   540:
   541:                 // Are we done listing?
   542:                 if tok = listing.ContinuationToken; tok == "" {
   543:                         return descendants, nil
   544:                 }
   545:         }
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
=> 556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:560 (PC: 0x1945093)
   530:                         if o.Name == d.Name().GcsObjectName() {
   531:                                 continue
   532:                         }
   533:                         name := NewDescendantName(d.Name(), o.Name)
   534:                         descendants[name] = &Core{
   535:                                 Bucket:    d.Bucket(),
   536:                                 FullName:  name,
   537:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   538:                         }
   539:                 }
   540:
   541:                 // Are we done listing?
   542:                 if tok = listing.ContinuationToken; tok == "" {
   543:                         return descendants, nil
   544:                 }
   545:         }
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
=> 560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/storageutil/object_attrs.go:137 (PC: 0x102dc6e)
   107:         wc.Name = req.Name
   108:         wc.ContentType = req.ContentType
   109:         wc.ContentLanguage = req.ContentLanguage
   110:         wc.ContentEncoding = req.ContentEncoding
   111:         wc.CacheControl = req.CacheControl
   112:         wc.Metadata = req.Metadata
   113:         wc.ContentDisposition = req.ContentDisposition
   114:         wc.CustomTime, _ = time.Parse(time.RFC3339, req.CustomTime)
   115:         wc.EventBasedHold = req.EventBasedHold
   116:         wc.StorageClass = req.StorageClass
   117:
   118:         // Converting []*storagev1.ObjectAccessControl to []ACLRule for writer object.
   119:         var aclRules []storage.ACLRule
   120:         for _, element := range req.Acl {
   121:                 aclRules = append(aclRules, convertObjectAccessControlToACLRule(element))
   122:         }
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
=> 137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
   138:         if o == nil {
   139:                 return nil
   140:         }
   141:
   142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
   159:                 ContentType:        o.ContentType,
   160:                 ContentLanguage:    o.ContentLanguage,
   161:                 CacheControl:       o.CacheControl,
   162:                 Owner:              o.Owner,
   163:                 MD5:                o.MD5,
   164:                 CRC32C:             o.CRC32C,
   165:                 MediaLink:          o.MediaLink,
   166:                 StorageClass:       o.StorageClass,
   167:                 Deleted:            o.Deleted,
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/storageutil/object_attrs.go:138 (PC: 0x102dc80)
   108:         wc.ContentType = req.ContentType
   109:         wc.ContentLanguage = req.ContentLanguage
   110:         wc.ContentEncoding = req.ContentEncoding
   111:         wc.CacheControl = req.CacheControl
   112:         wc.Metadata = req.Metadata
   113:         wc.ContentDisposition = req.ContentDisposition
   114:         wc.CustomTime, _ = time.Parse(time.RFC3339, req.CustomTime)
   115:         wc.EventBasedHold = req.EventBasedHold
   116:         wc.StorageClass = req.StorageClass
   117:
   118:         // Converting []*storagev1.ObjectAccessControl to []ACLRule for writer object.
   119:         var aclRules []storage.ACLRule
   120:         for _, element := range req.Acl {
   121:                 aclRules = append(aclRules, convertObjectAccessControlToACLRule(element))
   122:         }
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
   137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
=> 138:         if o == nil {
   139:                 return nil
   140:         }
   141:
   142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
   159:                 ContentType:        o.ContentType,
   160:                 ContentLanguage:    o.ContentLanguage,
   161:                 CacheControl:       o.CacheControl,
   162:                 Owner:              o.Owner,
   163:                 MD5:                o.MD5,
   164:                 CRC32C:             o.CRC32C,
   165:                 MediaLink:          o.MediaLink,
   166:                 StorageClass:       o.StorageClass,
   167:                 Deleted:            o.Deleted,
   168:                 ComponentCount:     o.ComponentCount,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.ConvertObjToMinObject() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/storageutil/object_attrs.go:142 (PC: 0x102dc8d)
   112:         wc.Metadata = req.Metadata
   113:         wc.ContentDisposition = req.ContentDisposition
   114:         wc.CustomTime, _ = time.Parse(time.RFC3339, req.CustomTime)
   115:         wc.EventBasedHold = req.EventBasedHold
   116:         wc.StorageClass = req.StorageClass
   117:
   118:         // Converting []*storagev1.ObjectAccessControl to []ACLRule for writer object.
   119:         var aclRules []storage.ACLRule
   120:         for _, element := range req.Acl {
   121:                 aclRules = append(aclRules, convertObjectAccessControlToACLRule(element))
   122:         }
   123:         wc.ACL = aclRules
   124:
   125:         if req.CRC32C != nil {
   126:                 wc.CRC32C = *req.CRC32C
   127:                 wc.SendCRC32C = true
   128:         }
   129:
   130:         if req.MD5 != nil {
   131:                 wc.MD5 = (*req.MD5)[:]
   132:         }
   133:
   134:         return wc
   135: }
   136:
   137: func ConvertObjToMinObject(o *gcs.Object) *gcs.MinObject {
   138:         if o == nil {
   139:                 return nil
   140:         }
   141:
=> 142:         return &gcs.MinObject{
   143:                 Name:            o.Name,
   144:                 Size:            o.Size,
   145:                 Generation:      o.Generation,
   146:                 MetaGeneration:  o.MetaGeneration,
   147:                 Updated:         o.Updated,
   148:                 Metadata:        o.Metadata,
   149:                 ContentEncoding: o.ContentEncoding,
   150:         }
   151: }
   152:
   153: func ConvertObjToExtendedObjectAttributes(o *gcs.Object) *gcs.ExtendedObjectAttributes {
   154:         if o == nil {
   155:                 return nil
   156:         }
   157:
   158:         return &gcs.ExtendedObjectAttributes{
   159:                 ContentType:        o.ContentType,
   160:                 ContentLanguage:    o.ContentLanguage,
   161:                 CacheControl:       o.CacheControl,
   162:                 Owner:              o.Owner,
   163:                 MD5:                o.MD5,
   164:                 CRC32C:             o.CRC32C,
   165:                 MediaLink:          o.MediaLink,
   166:                 StorageClass:       o.StorageClass,
   167:                 Deleted:            o.Deleted,
   168:                 ComponentCount:     o.ComponentCount,
   169:                 ContentDisposition: o.ContentDisposition,
   170:                 CustomTime:         o.CustomTime,
   171:                 EventBasedHold:     o.EventBasedHold,
   172:                 Acl:                o.Acl,
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:560 (PC: 0x19450a5)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject")(0xc000796f00)
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject {
                Name: "",
                Size: 0,
                Generation: 1715237031570514,
                MetaGeneration: 1,
                Updated: time.Time(2024-05-09T06:43:51Z){
                        wall: 616000000,
                        ext: 63850833831,
                        loc: *time.Location nil,},
                Metadata: map[string]string nil,
                ContentEncoding: "",}

   530:                         if o.Name == d.Name().GcsObjectName() {
   531:                                 continue
   532:                         }
   533:                         name := NewDescendantName(d.Name(), o.Name)
   534:                         descendants[name] = &Core{
   535:                                 Bucket:    d.Bucket(),
   536:                                 FullName:  name,
   537:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   538:                         }
   539:                 }
   540:
   541:                 // Are we done listing?
   542:                 if tok = listing.ContinuationToken; tok == "" {
   543:                         return descendants, nil
   544:                 }
   545:         }
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
=> 560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (PC: 0x194532a)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7c8)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing {Name: "", Type: ExplicitDirType (3)}

   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
=> 577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:576 (PC: 0x19453cd)
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
=> 576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
(dlv) p minListing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing")(0xc000e18700)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing len: 1, cap: 1, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7c8),
        ],
        CollapsedRuns: []string len: 2, cap: 2, ["dir1/","dir2/"],
        ContinuationToken: "",}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (hits goroutine(179):2 total:2) (PC: 0x1945325)
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
=> 577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:556 (hits goroutine(179):2 total:2) (PC: 0x1945083)
   526:                         if len(descendants) >= limit {
   527:                                 return descendants, nil
   528:                         }
   529:                         // skip the current directory
   530:                         if o.Name == d.Name().GcsObjectName() {
   531:                                 continue
   532:                         }
   533:                         name := NewDescendantName(d.Name(), o.Name)
   534:                         descendants[name] = &Core{
   535:                                 Bucket:    d.Bucket(),
   536:                                 FullName:  name,
   537:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   538:                         }
   539:                 }
   540:
   541:                 // Are we done listing?
   542:                 if tok = listing.ContinuationToken; tok == "" {
   543:                         return descendants, nil
   544:                 }
   545:         }
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
=> 556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x4464e4,0x45f38e,0x446404 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1945325 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (2)
Breakpoint 2 (enabled) at 0x19471c7 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651 (0)
Breakpoint 3 (enabled) at 0x194638d for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (0)
Breakpoint 4 (enabled) at 0x1945ee6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663 (0)
Breakpoint 5 (enabled) at 0x1946464 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:680 (0)
Breakpoint 6 (enabled) at 0x1946695 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697 (0)
Breakpoint 7 (enabled) at 0x1946825 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706 (0)
Breakpoint 9 (enabled) at 0x1945083 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:556 (2)
(dlv) clear 9
Breakpoint 9 cleared at 0x1945083 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:556
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.ObjectToMinObjectForListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:560 (PC: 0x1945093)
   530:                         if o.Name == d.Name().GcsObjectName() {
   531:                                 continue
   532:                         }
   533:                         name := NewDescendantName(d.Name(), o.Name)
   534:                         descendants[name] = &Core{
   535:                                 Bucket:    d.Bucket(),
   536:                                 FullName:  name,
   537:                                 MinObject: storageutil.ConvertObjToMinObject(o),
   538:                         }
   539:                 }
   540:
   541:                 // Are we done listing?
   542:                 if tok = listing.ContinuationToken; tok == "" {
   543:                         return descendants, nil
   544:                 }
   545:         }
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
=> 560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
(dlv) p o.Name
"file1"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (PC: 0x194532a)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7e0)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing {Name: "file1", Type: RegularFileType (2)}

   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
=> 577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:576 (PC: 0x19453cd)
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
=> 576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577 (hits goroutine(179):3 total:3) (PC: 0x1945325)
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
=> 577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
(dlv) p v.Name
"file2"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:576 (PC: 0x19453cd)
   546:
   547: }
   548:
   549: // shortened from gcs.Object
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
=> 576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
   580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GcsListingToMinGcListing() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:580 (PC: 0x19453d7)
   550: type MinObjectForListing struct {
   551:         Name string
   552:         Type metadata.Type
   553: }
   554:
   555: func ObjectToMinObjectForListing(o *gcs.Object) *MinObjectForListing {
   556:         if o == nil {
   557:                 return nil
   558:         }
   559:
   560:         return &MinObjectForListing{Name: o.Name, Type: TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, Name{objectName: o.Name})}
   561: }
   562:
   563: // shortened from gcs.Listing
   564: type MinGcsListing struct {
   565:         Objects           []*MinObjectForListing
   566:         CollapsedRuns     []string
   567:         ContinuationToken string
   568: }
   569:
   570: func GcsListingToMinGcListing(listing *gcs.Listing) *MinGcsListing {
   571:         if listing == nil {
   572:                 return nil
   573:         }
   574:
   575:         minListing := &MinGcsListing{CollapsedRuns: listing.CollapsedRuns, ContinuationToken: listing.ContinuationToken, Objects: []*MinObjectForListing{}}
   576:         for _, v := range listing.Objects {
   577:                 minListing.Objects = append(minListing.Objects, ObjectToMinObjectForListing(v))
   578:         }
   579:
=> 580:         return minListing
   581: }
   582:
   583: // purely for debugging and logging. Remove later!
   584: func StrsOfGcsListing(listing *gcs.Listing) (strs []string) {
   585:         strs = append(strs, "gcs.listing={")
   586:
   587:         strs = append(strs, fmt.Sprintf("    listing.ContinuationToken=%q", listing.ContinuationToken))
   588:
   589:         strs = append(strs, "")
   590:
   591:         strs = append(strs, "    Objects=[")
   592:         for _, obj := range listing.Objects {
   593:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   594:         }
   595:         strs = append(strs, "    ]")
   596:
   597:         strs = append(strs, "    CollapsedRuns=[")
   598:         for _, cr := range listing.CollapsedRuns {
   599:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   600:         }
   601:         strs = append(strs, "    ]")
   602:
   603:         strs = append(strs, "}")
   604:
   605:         return
   606: }
   607:
   608: // purely for debugging and logging. Remove later!
   609: func PrintGcsListing(listing *gcs.Listing, printFn func(string)) {
   610:         for _, str := range StrsOfGcsListing(listing) {
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:655 (PC: 0x1946385)
Values returned:
        ~r0: ("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing")(0xc000e18700)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing {
                Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing len: 3, cap: 4, [
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7c8),
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7e0),
                        *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7f8),
                ],
                CollapsedRuns: []string len: 2, cap: 2, ["dir1/","dir2/"],
                ContinuationToken: "",}

   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
=> 655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(179):1 total:1) (PC: 0x194638d)
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
=> 657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
(dlv) p listing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing")(0xc000e18700)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing len: 3, cap: 4, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7c8),
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7e0),
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7f8),
        ],
        CollapsedRuns: []string len: 2, cap: 2, ["dir1/","dir2/"],
        ContinuationToken: "",}
(dlv) p listing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing")(0xc000e18700)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing len: 3, cap: 4, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7c8),
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7e0),
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000a2c7f8),
        ],
        CollapsedRuns: []string len: 2, cap: 2, ["dir1/","dir2/"],
        ContinuationToken: "",}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:678 (PC: 0x19463e7)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
=> 678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:680 (hits goroutine(179):1 total:1) (PC: 0x1946464)
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
=> 680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:681 (PC: 0x1946517)
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
=> 681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:678 (PC: 0x19468be)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
=> 678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:680 (hits goroutine(179):2 total:2) (PC: 0x1946464)
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
=> 680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:684 (PC: 0x194651c)
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
=> 684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
(dlv) p o.Name
"file1"
(dlv) display o.Name
Command failed: wrong arguments
(dlv) display o     
Command failed: wrong arguments
(dlv) display
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:689 (PC: 0x1946555)
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
=> 689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:699 (PC: 0x194672a)
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
=> 699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:700 (PC: 0x194678c)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
=> 700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (PC: 0x19467a0)
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
=> 702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:700 (PC: 0x19467f9)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
=> 700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:704 (PC: 0x1946803)
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:700 (PC: 0x1946815)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
=> 700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706 (hits goroutine(179):1 total:1) (PC: 0x1946825)
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
=> 706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:678 (PC: 0x19468be)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
=> 678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:680 (hits goroutine(179):3 total:3) (PC: 0x1946464)
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
=> 680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:684 (PC: 0x194651c)
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
=> 684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
        {bucketName: "", objectName: "file1"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70000),
                ItemType: RegularFileType (2),}, 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:689 (PC: 0x1946555)
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
=> 689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:699 (PC: 0x194672a)
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
=> 699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:700 (PC: 0x194678c)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
=> 700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (PC: 0x19467a0)
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
=> 702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:700 (PC: 0x19467f9)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
=> 700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:704 (PC: 0x1946803)
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:700 (PC: 0x1946815)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
=> 700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706 (hits goroutine(179):2 total:2) (PC: 0x1946825)
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
=> 706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:678 (PC: 0x19468be)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
=> 678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:711 (PC: 0x19468cb)
   681:                         continue
   682:                 }
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
=> 711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:713 (PC: 0x19468ed)
   683:
   684:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   685:
   686:                 // Given the alphabetical order of the objects, if a file "foo" and
   687:                 // directory "foo/" coexist, the directory would eventually occupy
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
=> 713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (PC: 0x19468ff)
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
=> 718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:719 (PC: 0x19469d4)
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
=> 719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:720 (PC: 0x19469e9)
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
=> 720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:721 (PC: 0x1946a4b)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
=> 721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
        {bucketName: "", objectName: "file1"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70000),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "file2"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70030),
                ItemType: RegularFileType (2),}, 
]
(dlv) p pathBase
"dir1"
(dlv) p dirName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir1/"}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (PC: 0x1946b16)
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
=> 729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
(dlv) s
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:66 (PC: 0x1940fae)
    36:         MinObject *gcs.MinObject
    37:
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
=>  66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
    68:         case m == nil && !local:
    69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:68 (PC: 0x1940fd8)
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
=>  68:         case m == nil && !local:
    69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
    97: func (c Core) SanityCheck() error {
    98:         if c.MinObject != nil && c.FullName.objectName != c.MinObject.Name {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:67 (PC: 0x1940fef)
    37:
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
=>  67:         switch {
    68:         case m == nil && !local:
    69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
    97: func (c Core) SanityCheck() error {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:68 (PC: 0x1940ff4)
    38:         // Specifies a local object which is not yet synced to GCS.
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
=>  68:         case m == nil && !local:
    69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
    97: func (c Core) SanityCheck() error {
    98:         if c.MinObject != nil && c.FullName.objectName != c.MinObject.Name {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.TypeFromMinCore() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/core.go:69 (PC: 0x1940ffa)
    39:         Local bool
    40: }
    41:
    42: // Core contains critical information about an inode before its creation.
    43: type MinCoreForListing struct {
    44:         // The full name of the file or directory. Required for all inodes.
    45:         FullName Name
    46:
    47:         // // The bucket that backs up the inode. Required for all inodes except the
    48:         // // base directory that holds all the buckets mounted.
    49:         // Bucket *gcsx.SyncerBucket
    50:
    51:         // // The GCS object in the bucket above that backs up the inode. Can be empty
    52:         // // if the inode is the base directory or an implicit directory.
    53:         // MinObject *gcs.MinObject
    54:
    55:         // // Specifies a local object which is not yet synced to GCS.
    56:         // Local bool
    57:
    58:         ItemType metadata.Type
    59: }
    60:
    61: // Exists returns true iff the back object exists implicitly or explicitly.
    62: func (c *Core) Exists() bool {
    63:         return c != nil
    64: }
    65:
    66: func TypeFromMinCore(m *gcs.MinObject, local bool, fullname Name) metadata.Type {
    67:         switch {
    68:         case m == nil && !local:
=>  69:                 return metadata.ImplicitDirType
    70:         case fullname.IsDir():
    71:                 return metadata.ExplicitDirType
    72:         case IsSymlink(m):
    73:                 return metadata.SymlinkType
    74:         default:
    75:                 return metadata.RegularFileType
    76:         }
    77: }
    78:
    79: func (c *Core) Type() metadata.Type {
    80:         switch {
    81:         case c == nil:
    82:                 return metadata.UnknownType
    83:         default:
    84:                 return TypeFromMinCore(c.MinObject, c.Local, c.FullName)
    85:         }
    86: }
    87:
    88: func (c *MinCoreForListing) Type() metadata.Type {
    89:         if c == nil {
    90:                 return metadata.UnknownType
    91:         }
    92:         return c.ItemType
    93: }
    94:
    95: // SanityCheck returns an error if the object is conflicting with itself, which
    96: // means the metadata of the file system is broken.
    97: func (c Core) SanityCheck() error {
    98:         if c.MinObject != nil && c.FullName.objectName != c.MinObject.Name {
    99:                 return fmt.Errorf("inode name %q mismatches object name %q", c.FullName, c.MinObject.Name)
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (PC: 0x1946b3f)
Values returned:
        ~r0: ImplicitDirType (4)

   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
=> 729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:725 (PC: 0x1946b47)
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
=> 725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:727 (PC: 0x1946b5b)
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
=> 727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:725 (PC: 0x1946bb4)
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
=> 725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (PC: 0x1946bbe)
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
=> 729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:725 (PC: 0x1946bca)
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
=> 725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:731 (PC: 0x1946bda)
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
=> 731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
   760:         }
   761:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (PC: 0x1946c6b)
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
=> 718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:719 (PC: 0x19469d4)
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
=> 719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:720 (PC: 0x19469e9)
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
=> 720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:721 (PC: 0x1946a4b)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
=> 721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (PC: 0x1946b16)
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
=> 729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:725 (PC: 0x1946b47)
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
=> 725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:727 (PC: 0x1946b5b)
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
=> 727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:725 (PC: 0x1946bb4)
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
=> 725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (PC: 0x1946bbe)
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
=> 729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:725 (PC: 0x1946bca)
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
=> 725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
        {bucketName: "", objectName: "file1"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70000),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "file2"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70030),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "dir1/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70060),
                ItemType: ImplicitDirType (4),}, 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:731 (PC: 0x1946bda)
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
=> 731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
   760:         }
   761:         return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (PC: 0x1946c6b)
   688:                 // the value of records["foo"].
   689:                 if strings.HasSuffix(o.Name, "/") {
   690:                         dirName := NewDirName(d.Name(), nameBase)
   691:                         explicitDir := &MinCoreForListing{
   692:                                 // Bucket:    d.Bucket(),
   693:                                 FullName: dirName,
   694:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   695:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   696:                         }
   697:                         cores[dirName] = explicitDir
   698:                 } else {
   699:                         fileName := NewFileName(d.Name(), nameBase)
   700:                         file := &MinCoreForListing{
   701:                                 // Bucket:    d.Bucket(),
   702:                                 FullName: fileName,
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
=> 718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:733 (PC: 0x1946c8c)
   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
=> 733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
   760:         }
   761:         return
   762: }
   763:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651 (hits goroutine(179):1 total:1) (PC: 0x19471c7)
   621:
   622:         if !d.hasObjectsListBeenRead.Load() {
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
=> 651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
        {bucketName: "", objectName: "file1"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70000),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "file2"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70030),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "dir1/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70060),
                ItemType: ImplicitDirType (4),}, 
        {bucketName: "", objectName: "dir2/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70090),
                ItemType: ImplicitDirType (4),}, 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:650 (PC: 0x194726d)
   620:         var listing *MinGcsListing
   621:
   622:         if !d.hasObjectsListBeenRead.Load() {
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
=> 650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651 (hits goroutine(179):2 total:2) (PC: 0x19471c7)
   621:
   622:         if !d.hasObjectsListBeenRead.Load() {
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
=> 651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:650 (PC: 0x194726d)
   620:         var listing *MinGcsListing
   621:
   622:         if !d.hasObjectsListBeenRead.Load() {
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
=> 650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651 (hits goroutine(179):3 total:3) (PC: 0x19471c7)
   621:
   622:         if !d.hasObjectsListBeenRead.Load() {
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
=> 651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:650 (PC: 0x194726d)
   620:         var listing *MinGcsListing
   621:
   622:         if !d.hasObjectsListBeenRead.Load() {
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
=> 650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651 (hits goroutine(179):4 total:4) (PC: 0x19471c7)
   621:
   622:         if !d.hasObjectsListBeenRead.Load() {
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
=> 651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:650 (PC: 0x194726d)
   620:         var listing *MinGcsListing
   621:
   622:         if !d.hasObjectsListBeenRead.Load() {
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
=> 650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
   653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:653 (PC: 0x194727f)
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
=> 653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
(dlv) p d.cache
(unreadable invalid interface type)
(dlv) p d.cache.(TypeCache)
Command failed: no type entry found, use 'types' for a list of valid types
(dlv) type TypeCache
Command failed: command not available
(dlv) types         
***encoding/gob.decEngine
**[]uint8
**bool
**cloud.google.com/go/auth.Error
**cloud.google.com/go/auth/credentials/internal/externalaccount.AwsSecurityCredentials
**cloud.google.com/go/auth/internal/credsfile.ExternalAccountAuthorizedUserFile
**cloud.google.com/go/auth/internal/credsfile.ExternalAccountFile
**cloud.google.com/go/auth/internal/credsfile.GDCHServiceAccountFile
**cloud.google.com/go/auth/internal/credsfile.ImpersonatedServiceAccountFile
**cloud.google.com/go/auth/internal/credsfile.ServiceAccountFile
**cloud.google.com/go/auth/internal/credsfile.UserCredentialsFile
**cloud.google.com/go/iam/apiv1/iampb.AuditConfig
**cloud.google.com/go/iam/apiv1/iampb.AuditConfigDelta
**cloud.google.com/go/iam/apiv1/iampb.AuditLogConfig
**cloud.google.com/go/iam/apiv1/iampb.Binding
**cloud.google.com/go/iam/apiv1/iampb.BindingDelta
**cloud.google.com/go/iam/apiv1/iampb.Policy
**cloud.google.com/go/iam/apiv1/iampb.TestIamPermissionsResponse
**cloud.google.com/go/longrunning/autogen.OperationsCallOptions
**cloud.google.com/go/longrunning/autogen.OperationsClient
**cloud.google.com/go/longrunning/autogen/longrunningpb.ListOperationsResponse
**cloud.google.com/go/longrunning/autogen/longrunningpb.Operation
**cloud.google.com/go/monitoring/apiv3/v2.MetricCallOptions
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Aggregation
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_AlertStrategy_NotificationChannelStrategy
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateTimeSeriesRequest
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateTimeSeriesSummary_Error
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Group
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.InternalChecker
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.LabelValue
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListMetricDescriptorsResponse
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListMonitoredResourceDescriptorsResponse
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListTimeSeriesResponse
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.MutationRecord
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.NotificationChannel
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.NotificationChannelDescriptor
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Point
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.QueryError
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelObjective
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Snooze
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeries
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesData
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesData_PointData
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesDescriptor_ValueDescriptor
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TypedValue
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ContentMatcher
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_ResponseStatusCode
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckIp
**cloud.google.com/go/pubsub/apiv1/pubsubpb.PubsubMessage
**cloud.google.com/go/pubsub/apiv1/pubsubpb.ReceivedMessage
**cloud.google.com/go/pubsub/apiv1/pubsubpb.Schema
**cloud.google.com/go/pubsub/apiv1/pubsubpb.Snapshot
**cloud.google.com/go/pubsub/apiv1/pubsubpb.Subscription
**cloud.google.com/go/pubsub/apiv1/pubsubpb.Topic
**cloud.google.com/go/storage.BucketAttrs
**cloud.google.com/go/storage.HMACKey
**cloud.google.com/go/storage.Notification
**cloud.google.com/go/storage.ObjectAttrs
**cloud.google.com/go/storage.ObjectHandle
**cloud.google.com/go/storage.readStreamResponse
**cloud.google.com/go/storage/control/apiv2.StorageControlCallOptions
**cloud.google.com/go/storage/control/apiv2/controlpb.Folder
**cloud.google.com/go/storage/control/apiv2/controlpb.ListFoldersResponse
**cloud.google.com/go/storage/control/apiv2/controlpb.StorageLayout
**cloud.google.com/go/storage/internal/apiv2.BucketIterator
**cloud.google.com/go/storage/internal/apiv2.CallOptions
**cloud.google.com/go/storage/internal/apiv2.ObjectIterator
**cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket
**cloud.google.com/go/storage/internal/apiv2/storagepb.BucketAccessControl
**cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Cors
Sending output to pager...
***encoding/gob.decEngine
**[]uint8
**bool
**cloud.google.com/go/auth.Error
**cloud.google.com/go/auth/credentials/internal/externalaccount.AwsSecurityCredentials
**cloud.google.com/go/auth/internal/credsfile.ExternalAccountAuthorizedUserFile
**cloud.google.com/go/auth/internal/credsfile.ExternalAccountFile
**cloud.google.com/go/auth/internal/credsfile.GDCHServiceAccountFile
**cloud.google.com/go/auth/internal/credsfile.ImpersonatedServiceAccountFile
**cloud.google.com/go/auth/internal/credsfile.ServiceAccountFile
**cloud.google.com/go/auth/internal/credsfile.UserCredentialsFile
**cloud.google.com/go/iam/apiv1/iampb.AuditConfig
**cloud.google.com/go/iam/apiv1/iampb.AuditConfigDelta
**cloud.google.com/go/iam/apiv1/iampb.AuditLogConfig
**cloud.google.com/go/iam/apiv1/iampb.Binding
**cloud.google.com/go/iam/apiv1/iampb.BindingDelta
**cloud.google.com/go/iam/apiv1/iampb.Policy
**cloud.google.com/go/iam/apiv1/iampb.TestIamPermissionsResponse
**cloud.google.com/go/longrunning/autogen.OperationsCallOptions
**cloud.google.com/go/longrunning/autogen.OperationsClient
**cloud.google.com/go/longrunning/autogen/longrunningpb.ListOperationsResponse
**cloud.google.com/go/longrunning/autogen/longrunningpb.Operation
**cloud.google.com/go/monitoring/apiv3/v2.MetricCallOptions
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Aggregation
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_AlertStrategy_NotificationChannelStrategy
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateTimeSeriesRequest
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateTimeSeriesSummary_Error
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Group
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.InternalChecker
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.LabelValue
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListMetricDescriptorsResponse
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListMonitoredResourceDescriptorsResponse
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListTimeSeriesResponse
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.MutationRecord
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.NotificationChannel
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.NotificationChannelDescriptor
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Point
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.QueryError
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelObjective
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Snooze
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeries
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesData
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesData_PointData
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesDescriptor_ValueDescriptor
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TypedValue
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ContentMatcher
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_ResponseStatusCode
**cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckIp
**cloud.google.com/go/pubsub/apiv1/pubsubpb.PubsubMessage
**cloud.google.com/go/pubsub/apiv1/pubsubpb.ReceivedMessage
**cloud.google.com/go/pubsub/apiv1/pubsubpb.Schema
**cloud.google.com/go/pubsub/apiv1/pubsubpb.Snapshot
**cloud.google.com/go/pubsub/apiv1/pubsubpb.Subscription
**cloud.google.com/go/pubsub/apiv1/pubsubpb.Topic
**cloud.google.com/go/storage.BucketAttrs
**cloud.google.com/go/storage.HMACKey
**cloud.google.com/go/storage.Notification
**cloud.google.com/go/storage.ObjectAttrs
**cloud.google.com/go/storage.ObjectHandle
**cloud.google.com/go/storage.readStreamResponse
**cloud.google.com/go/storage/control/apiv2.StorageControlCallOptions
**cloud.google.com/go/storage/control/apiv2/controlpb.Folder
**cloud.google.com/go/storage/control/apiv2/controlpb.ListFoldersResponse
**cloud.google.com/go/storage/control/apiv2/controlpb.StorageLayout
**cloud.google.com/go/storage/internal/apiv2.BucketIterator
**cloud.google.com/go/storage/internal/apiv2.CallOptions
**cloud.google.com/go/storage/internal/apiv2.ObjectIterator
**cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket
**cloud.google.com/go/storage/internal/apiv2/storagepb.BucketAccessControl
**cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Cors
**cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Lifecycle_Rule
**cloud.google.com/go/storage/internal/apiv2/storagepb.CancelResumableWriteResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.ComposeObjectRequest_SourceObject
**cloud.google.com/go/storage/internal/apiv2/storagepb.CreateHmacKeyResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.HmacKeyMetadata
**cloud.google.com/go/storage/internal/apiv2/storagepb.ListBucketsResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.ListHmacKeysResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.ListNotificationConfigsResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.ListObjectsResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.NotificationConfig
**cloud.google.com/go/storage/internal/apiv2/storagepb.Object
**cloud.google.com/go/storage/internal/apiv2/storagepb.ObjectAccessControl
**cloud.google.com/go/storage/internal/apiv2/storagepb.QueryWriteStatusResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.ReadObjectResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.RewriteResponse
**cloud.google.com/go/storage/internal/apiv2/storagepb.ServiceAccount
**cloud.google.com/go/storage/internal/apiv2/storagepb.StartResumableWriteResponse
**cloud.google.com/go/trace/apiv2.CallOptions
**cloud.google.com/go/trace/apiv2/tracepb.Span
**cloud.google.com/go/trace/apiv2/tracepb.Span_Link
**cloud.google.com/go/trace/apiv2/tracepb.Span_TimeEvent
**cloud.google.com/go/trace/apiv2/tracepb.StackTrace_StackFrame
**container/list.Element
**contrib.go.opencensus.io/exporter/stackdriver.response
**contrib.go.opencensus.io/exporter/stackdriver.worker
**crypto/internal/edwards25519.Point
**crypto/internal/nistec.P224Point
**crypto/internal/nistec.P256Point
**crypto/internal/nistec.P384Point
**crypto/internal/nistec.P521Point
**crypto/internal/nistec.p256OrdElement
**crypto/tls.Certificate
**crypto/tls.CipherSuite
**crypto/tls.Config
**crypto/tls.SessionState
**crypto/tls.activeCert
**crypto/tls.cipherSuite
**crypto/tls.cipherSuiteTLS13
**crypto/x509.Certificate
**encoding/gob.decEngine
**encoding/gob.decOp
**encoding/gob.encOp
**encoding/gob.typeInfo
**encoding/gob.wireType
**encoding/json.field
**flag.Flag
**float32
**float64
**github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.DistributionValue_Bucket
**github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.LabelKey
**github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.LabelValue
**github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Metric
**github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Point
**github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.SummaryValue_Snapshot_ValueAtPercentile
**github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.TimeSeries
**github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.AttributeValue
**github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span
**github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_Link
**github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_TimeEvent
**github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_Tracestate_Entry
**github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.StackTrace_StackFrame
**github.com/cncf/xds/go/xds/core/v3.Authority
**github.com/cncf/xds/go/xds/core/v3.CidrRange
**github.com/cncf/xds/go/xds/core/v3.CollectionEntry
**github.com/cncf/xds/go/xds/core/v3.ResourceLocator_Directive
**github.com/cncf/xds/go/xds/type/matcher/v3.DoubleRangeMatcher_RangeMatcher
**github.com/cncf/xds/go/xds/type/matcher/v3.IPMatcher_IPRangeMatcher
**github.com/cncf/xds/go/xds/type/matcher/v3.Int32RangeMatcher_RangeMatcher
**github.com/cncf/xds/go/xds/type/matcher/v3.Int64RangeMatcher_RangeMatcher
**github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_FieldMatcher
**github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate
**github.com/cncf/xds/go/xds/type/matcher/v3.ServerNameMatcher_DomainMatcher
**github.com/cncf/xds/go/xds/type/matcher/v3.StringMatcher
**github.com/cncf/xds/go/xds/type/v3.DoubleRange
**github.com/cncf/xds/go/xds/type/v3.Int32Range
**github.com/cncf/xds/go/xds/type/v3.Int64Range
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.Certificate
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateDetails
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClusterStatus
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump_DynamicCluster
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump_StaticCluster
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.EcdsConfigDump_EcdsFilterConfig
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump_DynamicEndpointConfig
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump_StaticEndpointConfig
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.HostStatus
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenerStatus
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_DynamicListener
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_StaticListener
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump_DynamicRouteConfig
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump_StaticRouteConfig
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump_DynamicScopedRouteConfigs
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump_InlineScopedRouteConfigs
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump_DynamicSecret
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump_StaticSecret
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.SimpleMetric
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.SubjectAlternateName
**github.com/envoyproxy/go-control-plane/envoy/admin/v3.UnreadyTargetsDumps_UnreadyTargetsDump
**github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLog
**github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter
**github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.CustomInlineHeader
**github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.FatalAction
**github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer
**github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Watchdog_WatchdogAction
**github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakers_Thresholds
**github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster
**github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfig_LbSubsetSelector
**github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_TransportSocketMatch
**github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Filter
**github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.LoadBalancingPolicy_Policy
**github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatch_GenericTextMatch
**github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate
**github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_FieldMatcher
**github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Address
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AlternateProtocolsCacheOptions_AlternateProtocolsCacheEntry
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.CidrRange
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSource
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DataSource
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Extension
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtraSourceAddress
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcMethodList_Service
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValue
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValueOption
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_Payload
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http2ProtocolOptions_SettingsParameter
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketAddress
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOption
**github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TypedExtensionConfig
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignment_Policy_DropOverload
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterStats
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterStats_DroppedRequests
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.EndpointLoadMetricStats
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint_AdditionalAddress
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LbEndpoint
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpoints
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.UpstreamEndpointStats
**github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.UpstreamLocalityStats
**github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.AdditionalAddress
**github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Filter
**github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChain
**github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener
**github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilter
**github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate
**github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.HistogramBucketSettings
**github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsSink
**github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.TagSpecifier
**github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.LoadShedPoint
**github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.OverloadAction
**github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ResourceMonitor
**github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig_ScaleTimer
**github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.Trigger
**github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission
**github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal
**github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC
**github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_AuditLoggingOptions_AuditLoggerConfig
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ClusterSpecifierPlugin
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.QueryParameterMatcher
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_ResetHeader
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryHostPredicate
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Route
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_CookieAttribute
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_RequestMirrorPolicy
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_UpgradeConfig
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration_Key_Fragment
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualCluster
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualHost
**github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedCluster_ClusterWeight
**github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatch_GenericTextMatch
**github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate
**github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSink
**github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificateProperties_SubjectAltName
**github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_UpgradeConfig
**github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpFilter
**github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ResponseMapper
**github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder
**github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SPIFFECertValidatorConfig_TrustDomain
**github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SdsSecretConfig
**github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.Secret
**github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SubjectAltNameMatcher
**github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsCertificate
**github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints
**github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.Resource
**github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.ResourceLocator
**github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.ResourceName
**github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfig
**github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfig_GenericXdsConfig
**github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfig
**github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation_Operation
**github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcher
**github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcher_PathSegment
**github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.NodeMatcher
**github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcher
**github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcher
**github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcher_PathSegment
**github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher
**github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKey_PathSegment
**github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag
**github.com/envoyproxy/go-control-plane/envoy/type/v3.Int64Range
**github.com/google/s2a-go/internal/proto/common_go_proto.Identity
**github.com/google/s2a-go/internal/proto/s2a_go_proto.AuthenticationMechanism
**github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.AuthenticationMechanism
**github.com/google/s2a-go/retry.S2ARetryer
**github.com/googlecloudplatform/gcsfuse/v2/internal/cache/file/downloader.Job
**github.com/googlecloudplatform/gcsfuse/v2/internal/contentcache.CacheObject
**github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core
**github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing
**github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing
**github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.NotFoundError
**github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object
**github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.PreconditionError
**github.com/russross/blackfriday/v2.Node
**github.com/russross/blackfriday/v2.Reference
**github.com/russross/blackfriday/v2.reference
**github.com/urfave/cli.CommandCategory
**go.opencensus.io/metric/metricdata.Exemplar
**go.opencensus.io/metric/metricdata.Metric
**go.opencensus.io/metric/metricdata.TimeSeries
**go.opencensus.io/resource.Resource
**go.opencensus.io/stats.measureDescriptor
**go.opencensus.io/stats/view.Data
**go.opencensus.io/stats/view.Row
**go.opencensus.io/stats/view.View
**go.opencensus.io/stats/view.getViewByNameResp
**go.opencensus.io/stats/view.measureRef
**go.opencensus.io/stats/view.retrieveDataResp
**go.opencensus.io/stats/view.viewInternal
**go.opencensus.io/tag.Map
**go.opencensus.io/trace.SpanData
**go.opencensus.io/trace.bucket
**go.opencensus.io/trace.spanStore
**go.opentelemetry.io/otel/internal/global.meter
**go.opentelemetry.io/otel/internal/global.tracer
**golang.org/x/net/http2.ClientConn
**golang.org/x/net/http2.addConnCall
**golang.org/x/net/http2.clientStream
**golang.org/x/net/http2.dialCall
**golang.org/x/net/http2.fakeTimer
**golang.org/x/net/http2.testBlockedGoroutine
**golang.org/x/net/internal/timeseries.tsLevel
**golang.org/x/net/trace.bucketData
**golang.org/x/net/trace.eventFamily
**golang.org/x/net/trace.eventLog
**golang.org/x/net/trace.family
**golang.org/x/net/trace.trace
**golang.org/x/net/trace.traceSet
**golang.org/x/oauth2.DeviceAuthResponse
**golang.org/x/oauth2.RetrieveError
**golang.org/x/time/rate.Limiter
**google.golang.org/api/googleapi.Error
**google.golang.org/api/iamcredentials/v1.SignBlobResponse
**google.golang.org/api/iterator.PageInfo
**google.golang.org/api/storage/v1.AnywhereCache
**google.golang.org/api/storage/v1.AnywhereCaches
**google.golang.org/api/storage/v1.AnywhereCachesService
**google.golang.org/api/storage/v1.Bucket
**google.golang.org/api/storage/v1.BucketAccessControl
**google.golang.org/api/storage/v1.BucketAccessControls
**google.golang.org/api/storage/v1.BucketCors
**google.golang.org/api/storage/v1.BucketLifecycleRule
**google.golang.org/api/storage/v1.Buckets
**google.golang.org/api/storage/v1.Channel
**google.golang.org/api/storage/v1.ComposeRequestSourceObjects
**google.golang.org/api/storage/v1.Folder
**google.golang.org/api/storage/v1.Folders
**google.golang.org/api/storage/v1.GoogleLongrunningListOperationsResponse
**google.golang.org/api/storage/v1.GoogleLongrunningOperation
**google.golang.org/api/storage/v1.HmacKey
**google.golang.org/api/storage/v1.HmacKeyMetadata
**google.golang.org/api/storage/v1.HmacKeysMetadata
**google.golang.org/api/storage/v1.ManagedFolder
**google.golang.org/api/storage/v1.ManagedFolders
**google.golang.org/api/storage/v1.Notification
**google.golang.org/api/storage/v1.Notifications
**google.golang.org/api/storage/v1.Object
**google.golang.org/api/storage/v1.ObjectAccessControl
**google.golang.org/api/storage/v1.ObjectAccessControls
**google.golang.org/api/storage/v1.Objects
**google.golang.org/api/storage/v1.Policy
**google.golang.org/api/storage/v1.PolicyBindings
**google.golang.org/api/storage/v1.RewriteResponse
**google.golang.org/api/storage/v1.ServiceAccount
**google.golang.org/api/storage/v1.TestIamPermissionsResponse
**google.golang.org/genproto/googleapis/api/annotations.ClientLibrarySettings
**google.golang.org/genproto/googleapis/api/annotations.HttpRule
**google.golang.org/genproto/googleapis/api/annotations.MethodSettings
**google.golang.org/genproto/googleapis/api/annotations.RoutingParameter
**google.golang.org/genproto/googleapis/api/distribution.Distribution_Exemplar
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.Decl_FunctionDecl_Overload
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.EvalState_Result
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.Explain_ExprStep
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.Expr
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.ExprValue
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.Expr_CreateStruct_Entry
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.MapValue_Entry
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.SourceInfo_Extension
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.Type
**google.golang.org/genproto/googleapis/api/expr/v1alpha1.Value
**google.golang.org/genproto/googleapis/api/label.LabelDescriptor
**google.golang.org/genproto/googleapis/api/metric.MetricDescriptor
**google.golang.org/genproto/googleapis/api/monitoredres.MonitoredResource
**google.golang.org/genproto/googleapis/api/monitoredres.MonitoredResourceDescriptor
**google.golang.org/genproto/googleapis/rpc/errdetails.BadRequest_FieldViolation
**google.golang.org/genproto/googleapis/rpc/errdetails.Help_Link
**google.golang.org/genproto/googleapis/rpc/errdetails.PreconditionFailure_Violation
**google.golang.org/genproto/googleapis/rpc/errdetails.QuotaFailure_Violation
**google.golang.org/genproto/googleapis/rpc/status.Status
**google.golang.org/grpc.ClientConn
**google.golang.org/grpc.MethodDesc
**google.golang.org/grpc.Server
**google.golang.org/grpc.StreamDesc
**google.golang.org/grpc.refCountedProducer
**google.golang.org/grpc.serviceInfo
**google.golang.org/grpc/attributes.Attributes
**google.golang.org/grpc/balancer/grpclb.subConnCacheEntry
**google.golang.org/grpc/balancer/grpclb/grpc_lb_v1.ClientStatsPerToken
**google.golang.org/grpc/balancer/grpclb/grpc_lb_v1.Server
**google.golang.org/grpc/balancer/rls.backoffState
**google.golang.org/grpc/balancer/rls.cacheEntry
**google.golang.org/grpc/balancer/rls.childPolicyWrapper
**google.golang.org/grpc/balancer/weightedroundrobin.weightedSubConn
**google.golang.org/grpc/balancer/weightedtarget/weightedaggregator.weightedPickerState
**google.golang.org/grpc/binarylog/grpc_binarylog_v1.MetadataEntry
**google.golang.org/grpc/credentials/alts/internal/proto/grpc_gcp.Identity
**google.golang.org/grpc/credentials/alts/internal/proto/grpc_gcp.ServerHandshakeParameters
**google.golang.org/grpc/credentials/tls/certprovider.BuildableConfig
**google.golang.org/grpc/credentials/tls/certprovider.wrappedProvider
**google.golang.org/grpc/grpclog.componentData
**google.golang.org/grpc/internal/balancergroup.subBalancerWrapper
**google.golang.org/grpc/internal/binarylog.MethodLoggerConfig
**google.golang.org/grpc/internal/cache.cacheEntry
**google.golang.org/grpc/internal/channelz.Channel
**google.golang.org/grpc/internal/channelz.EphemeralSocketMetrics
**google.golang.org/grpc/internal/channelz.Server
**google.golang.org/grpc/internal/channelz.Socket
**google.golang.org/grpc/internal/channelz.SubChannel
**google.golang.org/grpc/internal/channelz.traceEvent
**google.golang.org/grpc/internal/proto/grpc_lookup_v1.GrpcKeyBuilder
**google.golang.org/grpc/internal/proto/grpc_lookup_v1.GrpcKeyBuilder_Name
**google.golang.org/grpc/internal/proto/grpc_lookup_v1.HttpKeyBuilder
**google.golang.org/grpc/internal/proto/grpc_lookup_v1.NameMatcher
**google.golang.org/grpc/internal/transport.Stream
**google.golang.org/grpc/internal/transport.outStream
**google.golang.org/grpc/internal/wrr.weightedItem
**google.golang.org/grpc/internal/xds/rbac.engine
**google.golang.org/grpc/internal/xds/rbac.policyMatcher
**google.golang.org/grpc/resolver.addressMapEntry
**google.golang.org/grpc/serviceconfig.ParseResult
**google.golang.org/grpc/xds/internal/balancer/cdsbalancer.watcherState
**google.golang.org/grpc/xds/internal/balancer/clusterimpl.LBConfig
**google.golang.org/grpc/xds/internal/balancer/clusterimpl.dropper
**google.golang.org/grpc/xds/internal/balancer/clustermanager.subBalancerState
**google.golang.org/grpc/xds/internal/balancer/clusterresolver.LBConfig
**google.golang.org/grpc/xds/internal/balancer/clusterresolver.resourceUpdate
**google.golang.org/grpc/xds/internal/balancer/outlierdetection.LBConfig
**google.golang.org/grpc/xds/internal/balancer/outlierdetection.addressInfo
**google.golang.org/grpc/xds/internal/balancer/outlierdetection.subConnWrapper
**google.golang.org/grpc/xds/internal/balancer/priority.Child
**google.golang.org/grpc/xds/internal/balancer/priority.childBalancer
**google.golang.org/grpc/xds/internal/balancer/ringhash.ringEntry
**google.golang.org/grpc/xds/internal/balancer/ringhash.subConn
**google.golang.org/grpc/xds/internal/balancer/wrrlocality.LBConfig
**google.golang.org/grpc/xds/internal/resolver.clusterInfo
**google.golang.org/grpc/xds/internal/xdsclient.ClusterRequestsCounter
**google.golang.org/grpc/xds/internal/xdsclient.authority
**google.golang.org/grpc/xds/internal/xdsclient.clientRefCounted
**google.golang.org/grpc/xds/internal/xdsclient.resourceState
**google.golang.org/grpc/xds/internal/xdsclient/bootstrap.Authority
**google.golang.org/grpc/xds/internal/xdsclient/bootstrap.Config
**google.golang.org/grpc/xds/internal/xdsclient/bootstrap.ServerConfig
**google.golang.org/grpc/xds/internal/xdsclient/load.Data
**google.golang.org/grpc/xds/internal/xdsclient/load.perClusterStore
**google.golang.org/grpc/xds/internal/xdsclient/xdsresource.FilterChain
**google.golang.org/grpc/xds/internal/xdsclient/xdsresource.HashPolicy
**google.golang.org/grpc/xds/internal/xdsclient/xdsresource.HeaderMatcher
**google.golang.org/grpc/xds/internal/xdsclient/xdsresource.Route
**google.golang.org/grpc/xds/internal/xdsclient/xdsresource.VirtualHost
**google.golang.org/grpc/xds/internal/xdsclient/xdsresource.destPrefixEntry
**google.golang.org/grpc/xds/internal/xdsclient/xdsresource.sourcePrefixEntry
**google.golang.org/grpc/xds/internal/xdsclient/xdsresource.sourcePrefixes
**google.golang.org/protobuf/internal/filedesc.Enum
**google.golang.org/protobuf/internal/filedesc.EnumValue
**google.golang.org/protobuf/internal/filedesc.Extension
**google.golang.org/protobuf/internal/filedesc.Field
**google.golang.org/protobuf/internal/filedesc.Message
**google.golang.org/protobuf/internal/filedesc.Method
**google.golang.org/protobuf/internal/filedesc.Oneof
**google.golang.org/protobuf/internal/filedesc.Service
**google.golang.org/protobuf/internal/impl.coderFieldInfo
**google.golang.org/protobuf/internal/impl.extensionMap
**google.golang.org/protobuf/internal/impl.fieldInfo
**google.golang.org/protobuf/internal/impl.oneofInfo
**google.golang.org/protobuf/types/descriptorpb.DescriptorProto
**google.golang.org/protobuf/types/descriptorpb.DescriptorProto_ExtensionRange
**google.golang.org/protobuf/types/descriptorpb.DescriptorProto_ReservedRange
**google.golang.org/protobuf/types/descriptorpb.EnumDescriptorProto
**google.golang.org/protobuf/types/descriptorpb.EnumDescriptorProto_EnumReservedRange
**google.golang.org/protobuf/types/descriptorpb.EnumValueDescriptorProto
**google.golang.org/protobuf/types/descriptorpb.ExtensionRangeOptions_Declaration
**google.golang.org/protobuf/types/descriptorpb.FeatureSetDefaults_FeatureSetEditionDefault
**google.golang.org/protobuf/types/descriptorpb.FieldDescriptorProto
**google.golang.org/protobuf/types/descriptorpb.FieldOptions_EditionDefault
**google.golang.org/protobuf/types/descriptorpb.FileDescriptorProto
**google.golang.org/protobuf/types/descriptorpb.GeneratedCodeInfo_Annotation
**google.golang.org/protobuf/types/descriptorpb.MethodDescriptorProto
**google.golang.org/protobuf/types/descriptorpb.OneofDescriptorProto
**google.golang.org/protobuf/types/descriptorpb.ServiceDescriptorProto
**google.golang.org/protobuf/types/descriptorpb.SourceCodeInfo_Location
**google.golang.org/protobuf/types/descriptorpb.UninterpretedOption
**google.golang.org/protobuf/types/descriptorpb.UninterpretedOption_NamePart
**google.golang.org/protobuf/types/known/anypb.Any
**google.golang.org/protobuf/types/known/durationpb.Duration
**google.golang.org/protobuf/types/known/structpb.Value
**gopkg.in/yaml%2ev3.Node
**gopkg.in/yaml%2ev3.structInfo
**gopkg.in/yaml%2ev3.yaml_version_directive_t
**html/template.Template
**int
**int32
**int64
**internal/abi.ITab
**internal/abi.InterfaceType
**internal/abi.Type
**internal/intern.Value
**internal/singleflight.call
**log.Logger
**math/big.Int
**math/big.nat
**mime/multipart.FileHeader
**net.DNSError
**net.IPNet
**net.MX
**net.NS
**net.OpError
**net.SRV
**net.TCPConn
**net/http.Cookie
**net/http.Request
**net/http.Response
**net/http.http2ClientConn
**net/http.http2addConnCall
**net/http.http2clientStream
**net/http.http2dialCall
**net/http.http2fakeTimer
**net/http.http2testBlockedGoroutine
**net/http.pattern
**net/http.persistConn
**net/http.wantConn
**net/http/httptrace.ClientTrace
**net/rpc.Call
**net/url.URL
**os.File
**os/signal.handler
**reflect.rtype
**regexp.onePassProg
**regexp.thread
**regexp/syntax.Regexp
**runtime._defer
**runtime.arenaHint
**runtime.bmap
**runtime.dbgVar
**runtime.g
**runtime.initTask
**runtime.m
**runtime.mSpanList
**runtime.mcache
**runtime.moduledata
**runtime.mspan
**runtime.notInHeap
**runtime.p
**runtime.profBuf
**runtime.special
**runtime.stackWorkBuf
**runtime.sudog
**runtime/pprof.Profile
**runtime/pprof.profMapEntry
**string
**strings.trieNode
**struct { ExpiresIn int64 "json:\"expires_in\""; VerificationURL string "json:\"verification_url\""; Alias = *golang.org/x/oauth2.Alias2 }
**sync.Pool
**sync.entry
**sync/atomic.Int32
**text/template.Template
**text/template/parse.CommandNode
**text/template/parse.Tree
**text/template/parse.VariableNode
**time.Location
**time.Ticker
**time.Timer
**uint32
**uint64
**uint8
**unicode.RangeTable
**unsafe.Pointer
**vendor/golang.org/x/text/unicode/norm.formInfo
*<-chan time.Time
*[0]*cloud.google.com/go/storage/internal/apiv2/storagepb.ComposeObjectRequest_SourceObject
*[0]*crypto/x509.Certificate
*[0]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing
*[0]*github.com/urfave/cli.CommandCategory
*[0]*go.opencensus.io/metric/metricdata.Metric
*[0]*go.opencensus.io/metric/metricdata.TimeSeries
*[0]*net/http.Cookie
*[0]bool
*[0]encoding/json.field
*[0]encoding/xml.Attr
*[0]error
*[0]float64
*[0]github.com/googleapis/gax-go/v2.CallOption
*[0]github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.DirInode
*[0]github.com/urfave/cli.Command
*[0]go.opencensus.io/metric/metricdata.Bucket
*[0]go.opencensus.io/metric/metricdata.LabelKey
*[0]go.opencensus.io/metric/metricdata.LabelValue
*[0]go.opentelemetry.io/otel/trace.SpanStartOption
*[0]google.golang.org/grpc.CallOption
*[0]google.golang.org/grpc/resolver.Address
*[0]google.golang.org/grpc/xds/internal/xdsclient/xdsresource.Locality
*[0]gopkg.in/natefinch/lumberjack%2ev2.logInfo
*[0]int
*[0]int32
*[0]int64
*[0]interface {}
*[0]io.Closer
*[0]io/fs.DirEntry
*[0]io/fs.FileInfo
*[0]reflect.fieldScan
*[0]runtime.Frame
*[0]string
*[0]uint16
*[0]uint8
*[0]uintptr
*[1024]uint8
*[1048576]runtime.inlinedCall
*[10]*golang.org/x/net/trace.trace
*[10]go.opentelemetry.io/otel/attribute.KeyValue
*[10]google.golang.org/protobuf/internal/descfmt.methodAndName
*[10]interface {}
*[10]string
*[10]uint8
*[1125899906842623]uint8
*[11]*go.opencensus.io/stats/view.View
*[11]interface {}
*[11]uintptr
*[12]*crypto/tls.CipherSuite
*[12]interface {}
*[131072]uint16
*[132]crypto/internal/nistec.p521Table
*[133]uint8
*[13]*crypto/tls.CipherSuite
*[13]float64
*[13]interface {}
*[14]uint8
*[15]runtime.traceArg
*[15]uint8
*[16384]uint8
*[16]int32
*[16]uint32
*[16]uint64
*[16]uint8
*[16]uintptr
*[171]uint8
*[17]float64
*[17]uint8
*[17]uintptr
*[18]uint8
*[19]google.golang.org/protobuf/internal/descfmt.methodAndName
*[19]int
*[19]uint8
*[1]*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Point
*[1]*crypto/internal/edwards25519.Point
*[1]*crypto/x509.Certificate
*[1]*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Point
*[1]*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission
*[1]*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal
*[1]*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC
*[1]*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfig
*[1]*github.com/google/s2a-go/internal/proto/common_go_proto.Identity
*[1]*github.com/google/s2a-go/internal/proto/s2a_go_proto.AuthenticationMechanism
*[1]*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.AuthenticationMechanism
*[1]*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object
*[1]*os.File
*[1][]*crypto/x509.Certificate
*[1][]google.golang.org/grpc/xds/internal/xdsclient/xdsresource.Locality
*[1][]uint8
*[1]chan<- internal/singleflight.Result
*[1]cloud.google.com/go/storage.storageOption
*[1]crypto/tls.Certificate
*[1]crypto/tls.SignatureScheme
*[1]crypto/tls.keyShare
*[1]crypto/tls.pskIdentity
*[1]crypto/tls.ticketKey
*[1]crypto/x509.ExtKeyUsage
*[1]crypto/x509/pkix.AttributeTypeAndValue
*[1]encoding/json.field
*[1]error
*[1]float64
*[1]github.com/aws/aws-sdk-go/internal/ini.AST
*[1]github.com/googleapis/gax-go/v2.CallOption
*[1]github.com/urfave/cli.Command
*[1]github.com/urfave/cli.Flag
*[1]go.opencensus.io/metric/metricdata.Point
*[1]go.opencensus.io/stats.Measurement
*[1]go.opencensus.io/tag.Key
*[1]go.opencensus.io/tag.Mutator
*[1]go.opencensus.io/trace.Attribute
*[1]go.opencensus.io/trace.StartOption
*[1]go.opentelemetry.io/otel/attribute.KeyValue
*[1]go.opentelemetry.io/otel/metric.AddOption
*[1]go.opentelemetry.io/otel/metric.MeterOption
*[1]go.opentelemetry.io/otel/metric.RecordOption
*[1]go.opentelemetry.io/otel/trace.EventOption
*[1]go.opentelemetry.io/otel/trace.SpanStartOption
*[1]go.opentelemetry.io/otel/trace.TracerOption
*[1]golang.org/x/net/http2.Setting
*[1]golang.org/x/oauth2.AuthCodeOption
*[1]google.golang.org/api/googleapi.MediaOption
*[1]google.golang.org/api/option.ClientOption
*[1]google.golang.org/grpc.CallOption
*[1]google.golang.org/grpc.DialOption
*[1]google.golang.org/grpc.StreamClientInterceptor
*[1]google.golang.org/grpc.UnaryClientInterceptor
*[1]google.golang.org/grpc/codes.Code
*[1]google.golang.org/grpc/resolver.Address
*[1]google.golang.org/grpc/resolver.Builder
*[1]google.golang.org/grpc/xds/internal/xdsclient/bootstrap.channelCreds
*[1]google.golang.org/protobuf/internal/descfmt.methodAndName
*[1]int
*[1]int64
*[1]interface {}
*[1]io.Writer
*[1]map[string]encoding/json.RawMessage
*[1]map[string]interface {}
*[1]math/big.Word
*[1]net.Addr
*[1]net.IPAddr
*[1]os.Signal
*[1]reflect.Value
*[1]reflect.fieldScan
*[1]runtime.Frame
*[1]string
*[1]text/template.variable
*[1]text/template/parse.Node
*[1]time.zone
*[1]time.zoneTrans
*[1]uint16
*[1]uint32
*[1]uint64
*[1]uint8
*[1]uintptr
*[1]unsafe.Pointer
*[1]vendor/golang.org/x/net/dns/dnsmessage.Type
*[1]vendor/golang.org/x/net/http/httpproxy.matcher
*[2048]uint8
*[21]interface {}
*[21]uint8
*[22]uintptr
*[256]*golang.org/x/net/http2/hpack.node
*[256]*vendor/golang.org/x/net/http2/hpack.node
*[256]golang.org/x/net/http2/hpack.node
*[256]runtime.guintptr
*[256]uint32
*[256]uint64
*[256]uint8
*[256]vendor/golang.org/x/net/http2/hpack.node
*[268435456]uintptr
*[26]*crypto/internal/nistec.p256OrdElement
*[26]int
*[281474976710655]uint32
*[28]uint8
*[29]uint8
*[2]*crypto/internal/edwards25519.Point
*[2]*string
*[2]crypto/tls.SignatureScheme
*[2]encoding/asn1.encoder
*[2]error
*[2]float32
*[2]float64
*[2]github.com/googleapis/gax-go/v2.CallOption
*[2]github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ComposeSource
*[2]github.com/russross/blackfriday/v2.Option
*[2]go.opencensus.io/stats.Options
*[2]go.opencensus.io/tag.Key
*[2]go.opencensus.io/tag.Mutator
*[2]go.opencensus.io/trace.Attribute
*[2]go.opencensus.io/trace.StartOption
*[2]go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.Option
*[2]go.opentelemetry.io/otel/attribute.KeyValue
*[2]go.opentelemetry.io/otel/metric.Float64HistogramOption
*[2]go.opentelemetry.io/otel/metric.Int64CounterOption
*[2]go.opentelemetry.io/otel/metric.Int64HistogramOption
*[2]go.opentelemetry.io/otel/metric.MeterOption
*[2]go.opentelemetry.io/otel/trace.SpanStartOption
*[2]golang.org/x/net/http2.Setting
*[2]golang.org/x/oauth2.AuthCodeOption
*[2]google.golang.org/api/googleapi.Field
*[2]google.golang.org/api/internal/gensupport.typeReader
*[2]google.golang.org/api/option.ClientOption
*[2]google.golang.org/grpc.DialOption
*[2]google.golang.org/grpc/codes.Code
*[2]google.golang.org/grpc/connectivity.State
*[2]google.golang.org/grpc/metadata.MD
*[2]google.golang.org/protobuf/encoding/protowire.Number
*[2]google.golang.org/protobuf/internal/descfmt.methodAndName
*[2]google.golang.org/protobuf/reflect/protoreflect.EnumNumber
*[2]int
*[2]int32
*[2]int64
*[2]interface {}
*[2]io.Reader
*[2]io.Writer
*[2]map[string]interface {}
*[2]net/http.http2Setting
*[2]net/http.socksAuthMethod
*[2]reflect.StructField
*[2]runtime.Frame
*[2]string
*[2]struct { net.laddr net.TCPAddr; net.value int }
*[2]syscall._C_int
*[2]uint16
*[2]uint64
*[2]uint8
*[2]uintptr
*[2]vendor/golang.org/x/net/dns/dnsmessage.Type
*[30]uint8
*[30]uintptr
*[316]int
*[32768]uint8
*[32]crypto/internal/edwards25519.affineLookupTable
*[32]int32
*[32]uint8
*[32]uintptr
*[33]uint8
*[33]uintptr
*[34]float64
*[36]uint8
*[39]string
*[3]*go.opencensus.io/stats/view.View
*[3][]uint8
*[3]cloud.google.com/go/storage.RetryOption
*[3]contrib.go.opencensus.io/exporter/ocagent.ExporterOption
*[3]crypto/tls.SignatureScheme
*[3]github.com/google/s2a-go/internal/proto/common_go_proto.Ciphersuite
*[3]go.opencensus.io/stats.Options
*[3]go.opencensus.io/tag.Key
*[3]go.opentelemetry.io/otel/attribute.KeyValue
*[3]google.golang.org/protobuf/internal/descfmt.methodAndName
*[3]int
*[3]interface {}
*[3]io.Writer
*[3]reflect.StructField
*[3]runtime.traceArg
*[3]string
*[3]text/template/parse.item
*[3]uint64
*[3]uint8
*[3]uintptr
*[4096]uint8
*[40]float64
*[4194304]*runtime.heapArena
*[42]golang.org/x/sys/cpu.option
*[42]vendor/golang.org/x/sys/cpu.option
*[43]crypto/internal/nistec.p256AffineTable
*[45]github.com/urfave/cli.Flag
*[46912496118442]runtime.elfSym
*[48]uint8
*[49]uint8
*[4]*go.opencensus.io/stats/view.View
*[4]crypto/elliptic.Curve
*[4]crypto/tls.SignatureScheme
*[4]go.opentelemetry.io/otel/attribute.KeyValue
*[4]golang.org/x/net/http2/hpack.HeaderField
*[4]golang.org/x/net/trace.event
*[4]google.golang.org/api/option.ClientOption
*[4]google.golang.org/protobuf/internal/descfmt.methodAndName
*[4]int
*[4]int64
*[4]interface {}
*[4]runtime.traceArg
*[4]string
*[4]uint64
*[4]uint8
*[4]uintptr
*[50]uint8
*[512]uint8
*[54]uint8
*[562949953421311]uint16
*[56]crypto/internal/nistec.p224Table
*[57]string
*[57]uint8
*[5]*go.opencensus.io/stats/view.View
*[5]go.opencensus.io/stats.Measurement
*[5]go.opentelemetry.io/otel/attribute.KeyValue
*[5]google.golang.org/grpc/codes.Code
*[5]int
*[5]interface {}
*[5]string
*[5]uint32
*[5]uint8
*[5]uintptr
*[60]uint32
*[64]uint8
*[65536]runtime.scase
*[65]uint8
*[66]uint8
*[67]uint8
*[6]go.opencensus.io/tag.Mutator
*[6]go.opentelemetry.io/otel/attribute.KeyValue
*[6]interface {}
*[6]internal/cpu.option
*[6]string
*[6]uint64
*[6]uint8
*[6]uintptr
*[70368744177663]runtime.elfDyn
*[75]uint8
*[7]crypto/tls.SignatureScheme
*[7]go.opentelemetry.io/otel/attribute.KeyValue
*[7]google.golang.org/protobuf/internal/descfmt.methodAndName
*[7]interface {}
*[7]string
*[7]uint8
*[8192]runtime.pallocData
*[8192]uint8
*[8]go.opentelemetry.io/otel/attribute.KeyValue
*[8]golang.org/x/net/idna.joinState
*[8]google.golang.org/api/option.ClientOption
*[8]interface {}
*[8]runtime.pcvalueCacheEnt
*[8]string
*[8]struct { gopkg.in/yaml%2ev3.v interface {}; gopkg.in/yaml%2ev3.tag string; gopkg.in/yaml%2ev3.l []string }
*[8]uint32
*[8]uint8
*[8]vendor/golang.org/x/net/idna.joinState
*[96]crypto/internal/nistec.p384Table
*[96]crypto/internal/nistec/fiat.P224Element
*[96]uint8
*[97]uint8
*[9]*golang.org/x/net/trace.traceBucket
*[9]go.opentelemetry.io/otel/attribute.KeyValue
*[9]interface {}
*[9]uint64
*[9]uint8
*[9]uintptr
*[]*cloud.google.com/go/longrunning/autogen/longrunningpb.Operation
*[]*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeries
*[]*cloud.google.com/go/storage/control/apiv2/controlpb.Folder
*[]*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket
*[]*cloud.google.com/go/storage/internal/apiv2/storagepb.HmacKeyMetadata
*[]*cloud.google.com/go/storage/internal/apiv2/storagepb.NotificationConfig
*[]*cloud.google.com/go/storage/internal/apiv2/storagepb.Object
*[]*crypto/x509.Certificate
*[]*golang.org/x/net/http2.ClientConn
*[]*google.golang.org/genproto/googleapis/api/metric.MetricDescriptor
*[]*google.golang.org/genproto/googleapis/api/monitoredres.MonitoredResourceDescriptor
*[]*google.golang.org/grpc/xds/internal/xdsclient/bootstrap.ServerConfig
*[]*mime/multipart.FileHeader
*[]*net.IPNet
*[]*net/http.Cookie
*[]*net/http.Request
*[]*net/http.http2ClientConn
*[]*net/http.pattern
*[]*net/http.persistConn
*[]*net/url.URL
*[]*runtime.bmap
*[]*runtime.moduledata
*[][]*crypto/x509.Certificate
*[][][]uint8
*[][]int
*[][]string
*[][]uint8
*[]bool
*[]complex128
*[]complex64
*[]encoding/json.field
*[]error
*[]float32
*[]float64
*[]func()
*[]github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.DirInode
*[]go.shape.bool
*[]go.shape.complex128
*[]go.shape.complex64
*[]go.shape.float32
*[]go.shape.float64
*[]go.shape.int
*[]go.shape.int16
*[]go.shape.int32
*[]go.shape.int64
*[]go.shape.int8
*[]go.shape.string
*[]go.shape.uint
*[]go.shape.uint16
*[]go.shape.uint32
*[]go.shape.uint64
*[]go.shape.uintptr
*[]golang.org/x/net/http2.Setting
*[]golang.org/x/net/http2/hpack.HeaderField
*[]google.golang.org/api/option.ClientOption
*[]google.golang.org/grpc.jsonMC
*[]google.golang.org/grpc.jsonName
*[]google.golang.org/grpc/internal/resolver/dns.rawChoice
*[]google.golang.org/grpc/resolver.Address
*[]google.golang.org/grpc/xds/internal/xdsclient/xdsresource.Locality
*[]google.golang.org/protobuf/internal/impl.pointer
*[]google.golang.org/protobuf/internal/order.mapEntry
*[]google.golang.org/protobuf/internal/order.messageField
*[]google.golang.org/protobuf/reflect/protoreflect.FileDescriptor
*[]gopkg.in/yaml%2ev3.yaml_tag_directive_t
*[]int
*[]int16
*[]int32
*[]int64
*[]int8
*[]interface {}
*[]io.Closer
*[]map[string]encoding/json.RawMessage
*[]net.IP
*[]net.IPAddr
*[]net.nssCriterion
*[]net.nssSource
*[]net/http.muxEntry
*[]reflect.Value
*[]runtime.ancestorInfo
*[]runtime.untracedG4
*[]string
*[]syscall.Iovec
*[]text/tabwriter.cell
*[]uint
*[]uint16
*[]uint32
*[]uint64
*[]uint8
*[]uintptr
*[]unsafe.Pointer
*[]vendor/golang.org/x/net/http2/hpack.HeaderField
*bool
*bucket<*encoding/gob.typeInfo,bool>
*bucket<*github.com/census-instrumentation/opencensus-proto/gen-go/resource/v1.Resource,*google.golang.org/genproto/googleapis/api/monitoredres.Monitored
Resource>
*bucket<*go.opencensus.io/stats/view.viewInternal,struct {}>
*bucket<*go.opencensus.io/stats/view.viewInternal,time.Time>
*bucket<*golang.org/x/net/http2.ClientConn,[]string>
*bucket<*golang.org/x/net/trace.trace,bool>
*bucket<*google.golang.org/grpc.addrConn,struct {}>
*bucket<*google.golang.org/grpc/xds/internal/balancer/ringhash.subConn,google.golang.org/grpc/connectivity.State>
*bucket<*gopkg.in/yaml%2ev3.Node,bool>
*bucket<*net/http.http2ClientConn,[]string>
*bucket<*net/http.persistConn,*container/list.Element>
*bucket<*reflect.structType,bool>
*bucket<*reflect.structType,int>
*bucket<*regexp/syntax.Regexp,int64>
*bucket<*regexp/syntax.Regexp,int>
*bucket<*regexp/syntax.Regexp,regexp/syntax.printFlags>
*bucket<*sync.Cond,int>
*bucket<*text/template/parse.ActionNode,[]string>
*bucket<*text/template/parse.TemplateNode,string>
*bucket<*text/template/parse.TextNode,[]uint8>
*bucket<*uint8,[]uint8>
*bucket<[8]uint8,chan struct {}>
*bucket<chan<- os.Signal,*os/signal.handler>
*bucket<context.canceler,struct {}>
*bucket<crypto.Hash,[]uint8>
*bucket<crypto.Hash,encoding/asn1.RawValue>
*bucket<crypto/tls.alert,string>
*bucket<crypto/x509.sum224,bool>
*bucket<encoding/gob.typeId,**encoding/gob.decEngine>
*bucket<encoding/gob.typeId,*encoding/gob.decOp>
*bucket<encoding/gob.typeId,*encoding/gob.wireType>
*bucket<encoding/gob.typeId,bool>
*bucket<encoding/gob.typeId,encoding/gob.decOp>
*bucket<float64,float64>
*bucket<float64,struct {}>
*bucket<github.com/aws/aws-sdk-go/aws/endpoints.defaultKey,github.com/aws/aws-sdk-go/aws/endpoints.endpoint>
*bucket<github.com/aws/aws-sdk-go/aws/endpoints.endpointKey,github.com/aws/aws-sdk-go/aws/endpoints.endpoint>
*bucket<github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RequestMethod,struct {}>
*bucket<github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig_TimerType,struct {}>
*bucket<github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SubjectAltNameMatcher_SanType,struct {}>
*bucket<github.com/envoyproxy/go-control-plane/envoy/type/v3.StatusCode,struct {}>
*bucket<github.com/golang/groupcache/lru.Key,bool>
*bucket<github.com/googlecloudplatform/gcsfuse/v2/internal/contentcache.CacheObjectKey,*github.com/googlecloudplatform/gcsfuse/v2/internal/contentcache.C
acheObject>
*bucket<github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name,*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core>
*bucket<github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name,*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing>
*bucket<github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name,github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.DirInode>
*bucket<github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name,github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GenerationBackedInod
e>
*bucket<github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name,github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Inode>
*bucket<github.com/jacobsa/fuse/fuseops.HandleID,interface {}>
*bucket<github.com/jacobsa/fuse/fuseops.InodeID,github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Inode>
*bucket<go.opencensus.io/metric/metricproducer.Producer,struct {}>
*bucket<go.opencensus.io/stats/view.AggType,string>
*bucket<go.opencensus.io/stats/view.Exporter,struct {}>
*bucket<go.opencensus.io/tag.Key,go.opencensus.io/tag.tagContent>
*bucket<go.opencensus.io/trace.Exporter,struct {}>
*bucket<go.opencensus.io/trace.SpanInterface,struct {}>
*bucket<go.opentelemetry.io/otel/codes.Code,string>
*bucket<go.opentelemetry.io/otel/internal/global.il,*go.opentelemetry.io/otel/internal/global.meter>
*bucket<go.opentelemetry.io/otel/internal/global.il,*go.opentelemetry.io/otel/internal/global.tracer>
*bucket<go.shape.string,go.shape.*uint8>
*bucket<go.shape.string,go.shape.bool>
*bucket<golang.org/x/net/http2.ErrCode,google.golang.org/grpc/codes.Code>
*bucket<golang.org/x/net/http2.ErrCode,string>
*bucket<golang.org/x/net/http2.Flags,string>
*bucket<golang.org/x/net/http2.FrameType,golang.org/x/net/http2.frameParser>
*bucket<golang.org/x/net/http2.FrameType,map[golang.org/x/net/http2.Flags]string>
*bucket<golang.org/x/net/http2.FrameType,string>
*bucket<golang.org/x/net/http2.SettingID,bool>
*bucket<golang.org/x/net/http2.SettingID,string>
*bucket<golang.org/x/net/http2/hpack.pairNameValue,uint64>
*bucket<google.golang.org/grpc/balancer.ProducerBuilder,*google.golang.org/grpc.refCountedProducer>
*bucket<google.golang.org/grpc/balancer.SubConn,*google.golang.org/grpc/balancer/weightedroundrobin.weightedSubConn>
*bucket<google.golang.org/grpc/balancer.SubConn,*google.golang.org/grpc/internal/balancergroup.subBalancerWrapper>
*bucket<google.golang.org/grpc/balancer.SubConn,*google.golang.org/grpc/xds/internal/balancer/outlierdetection.subConnWrapper>
*bucket<google.golang.org/grpc/balancer.SubConn,*google.golang.org/grpc/xds/internal/balancer/ringhash.subConn>
*bucket<google.golang.org/grpc/balancer.SubConn,*sync/atomic.Int32>
*bucket<google.golang.org/grpc/balancer.SubConn,bool>
*bucket<google.golang.org/grpc/balancer.SubConn,google.golang.org/grpc/balancer/base.SubConnInfo>
*bucket<google.golang.org/grpc/balancer.SubConn,google.golang.org/grpc/connectivity.State>
*bucket<google.golang.org/grpc/balancer.SubConn,google.golang.org/grpc/resolver.Address>
*bucket<google.golang.org/grpc/balancer/rls.cacheKey,*container/list.Element>
*bucket<google.golang.org/grpc/balancer/rls.cacheKey,*google.golang.org/grpc/balancer/rls.backoffState>
*bucket<google.golang.org/grpc/balancer/rls.cacheKey,*google.golang.org/grpc/balancer/rls.cacheEntry>
*bucket<google.golang.org/grpc/codes.Code,bool>
*bucket<google.golang.org/grpc/codes.Code,struct {}>
*bucket<google.golang.org/grpc/credentials/tls/certprovider.storeKey,*google.golang.org/grpc/credentials/tls/certprovider.wrappedProvider>
*bucket<google.golang.org/grpc/internal/channelz.RefChannelType,string>
*bucket<google.golang.org/grpc/internal/grpcsync.Subscriber,bool>
*bucket<google.golang.org/grpc/internal/transport.ServerTransport,bool>
*bucket<google.golang.org/grpc/orca.OOBListener,struct {}>
*bucket<google.golang.org/grpc/resolver.Address,*google.golang.org/grpc/balancer/grpclb.subConnCacheEntry>
*bucket<google.golang.org/grpc/resolver.Address,google.golang.org/grpc/balancer.SubConn>
*bucket<google.golang.org/grpc/resolver.Address,google.golang.org/grpc/resolver.addressMapEntryList>
*bucket<google.golang.org/grpc/resolver.Address,struct {}>
*bucket<google.golang.org/grpc/xds/internal.LocalityID,string>
*bucket<google.golang.org/grpc/xds/internal/balancer/clusterresolver.discoveryMechanismKey,bool>
*bucket<google.golang.org/grpc/xds/internal/balancer/clusterresolver.discoveryMechanismKey,google.golang.org/grpc/xds/internal/balancer/clusterresolver.d
iscoveryMechanismAndResolver>
*bucket<google.golang.org/grpc/xds/internal/xdsclient.clusterNameAndServiceName,*google.golang.org/grpc/xds/internal/xdsclient.ClusterRequestsCounter>
*bucket<google.golang.org/grpc/xds/internal/xdsclient/xdsresource.ResourceWatcher,bool>
*bucket<google.golang.org/grpc/xds/internal/xdsclient/xdsresource.Type,map[string]*google.golang.org/grpc/xds/internal/xdsclient.resourceState>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,*google.golang.org/protobuf/internal/filedesc.Field>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,*google.golang.org/protobuf/internal/impl.coderFieldInfo>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,*google.golang.org/protobuf/internal/impl.fieldInfo>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,google.golang.org/protobuf/reflect/protoreflect.ExtensionType>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,google.golang.org/protobuf/reflect/protoreflect.FieldDescriptor>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,google.golang.org/protobuf/reflect/protoreflect.RawFields>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,interface {}>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,reflect.StructField>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,reflect.Type>
*bucket<google.golang.org/protobuf/encoding/protowire.Number,struct {}>
*bucket<google.golang.org/protobuf/internal/filedesc.Edition,*google.golang.org/protobuf/types/descriptorpb.FeatureSet>
*bucket<google.golang.org/protobuf/internal/filedesc.Edition,google.golang.org/protobuf/internal/filedesc.EditionFeatures>
*bucket<google.golang.org/protobuf/internal/filedesc.pathKey,[]int>
*bucket<google.golang.org/protobuf/internal/filedesc.pathKey,int>
*bucket<google.golang.org/protobuf/reflect/protoreflect.EnumNumber,*google.golang.org/protobuf/internal/filedesc.EnumValue>
*bucket<google.golang.org/protobuf/reflect/protoreflect.FullName,google.golang.org/protobuf/reflect/protoregistry.extensionsByNumber>
*bucket<google.golang.org/protobuf/reflect/protoreflect.FullName,interface {}>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Kind,google.golang.org/protobuf/encoding/protowire.Type>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Kind,reflect.Type>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/filedesc.Enum>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/filedesc.EnumValue>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/filedesc.Extension>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/filedesc.Field>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/filedesc.Message>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/filedesc.Method>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/filedesc.Oneof>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/filedesc.Service>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,*google.golang.org/protobuf/internal/impl.oneofInfo>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,google.golang.org/protobuf/reflect/protoreflect.FieldDescriptor>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,int>
*bucket<google.golang.org/protobuf/reflect/protoreflect.Name,reflect.StructField>
*bucket<int,*google.golang.org/grpc/xds/internal/xdsclient/xdsresource.FilterChain>
*bucket<int,*sync.Pool>
*bucket<int,[]google.golang.org/grpc/xds/internal/xdsclient/xdsresource.Locality>
*bucket<int,google.golang.org/grpc/codes.Code>
*bucket<int,int>
*bucket<int,string>
*bucket<int32,*go.opencensus.io/trace.bucket>
*bucket<int32,*google.golang.org/grpc/credentials/alts/internal/proto/grpc_gcp.ServerHandshakeParameters>
*bucket<int32,bool>
*bucket<int32,google.golang.org/protobuf/internal/impl.ExtensionField>
*bucket<int32,google.golang.org/protobuf/reflect/protoreflect.ProtoMessage>
*bucket<int32,string>
*bucket<int32,unsafe.Pointer>
*bucket<int64,*google.golang.org/genproto/googleapis/api/expr/v1alpha1.Expr>
*bucket<int64,*google.golang.org/genproto/googleapis/api/expr/v1alpha1.Reference>
*bucket<int64,*google.golang.org/genproto/googleapis/api/expr/v1alpha1.Type>
*bucket<int64,*google.golang.org/grpc/internal/channelz.Channel>
*bucket<int64,*google.golang.org/grpc/internal/channelz.Server>
*bucket<int64,*google.golang.org/grpc/internal/channelz.Socket>
*bucket<int64,*google.golang.org/grpc/internal/channelz.SubChannel>
*bucket<int64,int32>
*bucket<int64,string>
*bucket<int64,struct {}>
*bucket<interface {},*container/list.Element>
*bucket<interface {},*google.golang.org/grpc/internal/cache.cacheEntry>
*bucket<interface {},*sync.entry>
*bucket<interface {},[]uintptr>
*bucket<interface {},bool>
*bucket<interface {},interface {}>
*bucket<interface {},struct {}>
*bucket<internal/abi.TypeOff,*internal/abi.Type>
*bucket<internal/intern.key,*internal/intern.Value>
*bucket<internal/intern.key,uintptr>
*bucket<net.Listener,bool>
*bucket<net.hostLookupOrder,string>
*bucket<net/http.ConnState,string>
*bucket<net/http.cancelKey,func(error)>
*bucket<net/http.connectMethodKey,[]*net/http.persistConn>
*bucket<net/http.connectMethodKey,int>
*bucket<net/http.connectMethodKey,net/http.wantConnQueue>
*bucket<net/http.http2ErrCode,string>
*bucket<net/http.http2Flags,string>
*bucket<net/http.http2FrameType,map[net/http.http2Flags]string>
*bucket<net/http.http2FrameType,net/http.http2frameParser>
*bucket<net/http.http2FrameType,string>
*bucket<net/http.http2SettingID,bool>
*bucket<net/http.http2SettingID,string>
*bucket<net/http.routingIndexKey,[]*net/http.pattern>
*bucket<reflect.Kind,encoding/gob.decHelper>
*bucket<reflect.Kind,encoding/gob.encHelper>
*bucket<reflect.Kind,reflect.Value>
*bucket<reflect.Type,*encoding/gob.decOp>
*bucket<reflect.Type,*encoding/gob.encOp>
*bucket<reflect.Type,*encoding/gob.typeInfo>
*bucket<reflect.Type,*google.golang.org/protobuf/internal/impl.coderFieldInfo>
*bucket<reflect.Type,*gopkg.in/yaml%2ev3.structInfo>
*bucket<reflect.Type,bool>
*bucket<reflect.Type,encoding/gob.gobType>
*bucket<reflect.Type,encoding/gob.typeId>
*bucket<reflect.Type,google.golang.org/protobuf/encoding/protowire.Number>
*bucket<reflect.Type,google.golang.org/protobuf/reflect/protoreflect.MessageDescriptor>
*bucket<reflect.Type,int>
*bucket<reflect.Type,map[encoding/gob.typeId]**encoding/gob.decEngine>
*bucket<reflect.visit,bool>
*bucket<runtime._typePair,struct {}>
*bucket<string,*cloud.google.com/go/storage.Notification>
*bucket<string,*cloud.google.com/go/trace/apiv2/tracepb.AttributeValue>
*bucket<string,*container/list.Element>
*bucket<string,*crypto/tls.Certificate>
*bucket<string,*encoding/json.field>
*bucket<string,*flag.Flag>
*bucket<string,*github.com/aws/aws-sdk-go/internal/sync/singleflight.call>
*bucket<string,*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.AttributeValue>
*bucket<string,*github.com/cncf/xds/go/xds/core/v3.ContextParams>
*bucket<string,*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_OnMatch>
*bucket<string,*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_OnMatch>
*bucket<string,*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgs_Value>
*bucket<string,*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TypedExtensionConfig>
*bucket<string,*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint>
*bucket<string,*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Policy>
*bucket<string,*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/file/downloader.Job>
*bucket<string,*github.com/russross/blackfriday/v2.reference>
*bucket<string,*go.opencensus.io/stats.measureDescriptor>
*bucket<string,*go.opencensus.io/stats/view.measureRef>
*bucket<string,*go.opencensus.io/stats/view.viewInternal>
*bucket<string,*go.opencensus.io/trace.spanStore>
*bucket<string,*golang.org/x/net/http2.addConnCall>
*bucket<string,*golang.org/x/net/http2.dialCall>
*bucket<string,*golang.org/x/net/trace.eventFamily>
*bucket<string,*golang.org/x/net/trace.family>
*bucket<string,*golang.org/x/net/trace.traceSet>
*bucket<string,*google.golang.org/grpc.ClientConn>
*bucket<string,*google.golang.org/grpc.MethodDesc>
*bucket<string,*google.golang.org/grpc.StreamDesc>
*bucket<string,*google.golang.org/grpc.serviceInfo>
*bucket<string,*google.golang.org/grpc/balancer/rls.childPolicyWrapper>
*bucket<string,*google.golang.org/grpc/balancer/weightedtarget/weightedaggregator.weightedPickerState>
*bucket<string,*google.golang.org/grpc/credentials/tls/certprovider.BuildableConfig>
*bucket<string,*google.golang.org/grpc/grpclog.componentData>
*bucket<string,*google.golang.org/grpc/internal/balancergroup.subBalancerWrapper>
*bucket<string,*google.golang.org/grpc/internal/binarylog.MethodLoggerConfig>
*bucket<string,*google.golang.org/grpc/internal/xds/rbac.policyMatcher>
*bucket<string,*google.golang.org/grpc/xds/internal/balancer/cdsbalancer.watcherState>
*bucket<string,*google.golang.org/grpc/xds/internal/balancer/clusterimpl.LBConfig>
*bucket<string,*google.golang.org/grpc/xds/internal/balancer/clustermanager.subBalancerState>
*bucket<string,*google.golang.org/grpc/xds/internal/balancer/outlierdetection.LBConfig>
*bucket<string,*google.golang.org/grpc/xds/internal/balancer/outlierdetection.addressInfo>
*bucket<string,*google.golang.org/grpc/xds/internal/balancer/priority.Child>
*bucket<string,*google.golang.org/grpc/xds/internal/balancer/priority.childBalancer>
*bucket<string,*google.golang.org/grpc/xds/internal/resolver.clusterInfo>
*bucket<string,*google.golang.org/grpc/xds/internal/xdsclient.authority>
*bucket<string,*google.golang.org/grpc/xds/internal/xdsclient.clientRefCounted>
*bucket<string,*google.golang.org/grpc/xds/internal/xdsclient.resourceState>
*bucket<string,*google.golang.org/grpc/xds/internal/xdsclient/bootstrap.Authority>
*bucket<string,*google.golang.org/grpc/xds/internal/xdsclient/load.perClusterStore>
*bucket<string,*google.golang.org/grpc/xds/internal/xdsclient/xdsresource.destPrefixEntry>
*bucket<string,*google.golang.org/grpc/xds/internal/xdsclient/xdsresource.sourcePrefixEntry>
*bucket<string,*google.golang.org/protobuf/internal/filedesc.Field>
*bucket<string,*google.golang.org/protobuf/types/known/anypb.Any>
*bucket<string,*google.golang.org/protobuf/types/known/structpb.Struct>
*bucket<string,*google.golang.org/protobuf/types/known/structpb.Value>
*bucket<string,*gopkg.in/yaml%2ev3.Node>
*bucket<string,*html/template.Template>
*bucket<string,*internal/singleflight.call>
*bucket<string,*net/http.http2addConnCall>
*bucket<string,*net/http.http2dialCall>
*bucket<string,*net/http.routingNode>
*bucket<string,*runtime/pprof.Profile>
*bucket<string,*string>
*bucket<string,*text/template.Template>
*bucket<string,*text/template/parse.Tree>
*bucket<string,*unicode.RangeTable>
*bucket<string,[2]int32>
*bucket<string,[]*golang.org/x/net/http2.ClientConn>
*bucket<string,[]*mime/multipart.FileHeader>
*bucket<string,[]*net/http.Cookie>
*bucket<string,[]*net/http.http2ClientConn>
*bucket<string,[]google.golang.org/grpc/resolver.Address>
*bucket<string,[]google.golang.org/protobuf/reflect/protoreflect.FileDescriptor>
*bucket<string,[]int>
*bucket<string,[]net.nssSource>
*bucket<string,[]string>
*bucket<string,bool>
*bucket<string,contrib.go.opencensus.io/exporter/stackdriver.labelValue>
*bucket<string,encoding/json.RawMessage>
*bucket<string,error>
*bucket<string,float64>
*bucket<string,func(github.com/aws/aws-sdk-go/private/protocol.ResponseMetadata) error>
*bucket<string,func(string, *crypto/tls.Conn) net/http.RoundTripper>
*bucket<string,func(uintptr) uintptr>
*bucket<string,github.com/aws/aws-sdk-go/aws/endpoints.region>
*bucket<string,github.com/aws/aws-sdk-go/aws/endpoints.service>
*bucket<string,github.com/googlecloudplatform/gcsfuse/v2/internal/cache/lru.ValueType>
*bucket<string,github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.Type>
*bucket<string,github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket>
*bucket<string,go.opencensus.io/internal.PerMethodSummary>
*bucket<string,go.opencensus.io/stats/view.AggregationData>
*bucket<string,go.opentelemetry.io/otel/codes.Code>
*bucket<string,go/token.Token>
*bucket<string,golang.org/x/oauth2/internal.AuthStyle>
*bucket<string,google.golang.org/grpc.ServiceInfo>
*bucket<string,google.golang.org/grpc/authz/audit.LoggerBuilder>
*bucket<string,google.golang.org/grpc/balancer.Builder>
*bucket<string,google.golang.org/grpc/balancer.Picker>
*bucket<string,google.golang.org/grpc/balancer/rls/internal/keys.builder>
*bucket<string,google.golang.org/grpc/balancer/weightedtarget.Target>
*bucket<string,google.golang.org/grpc/codes.Code>
*bucket<string,google.golang.org/grpc/credentials/alts/internal/conn.ALTSRecordFunc>
*bucket<string,google.golang.org/grpc/credentials/tls/certprovider.Builder>
*bucket<string,google.golang.org/grpc/encoding.Codec>
*bucket<string,google.golang.org/grpc/encoding.Compressor>
*bucket<string,google.golang.org/grpc/internal/serviceconfig.MethodConfig>
*bucket<string,google.golang.org/grpc/resolver.Builder>
*bucket<string,google.golang.org/grpc/xds/bootstrap.Credentials>
*bucket<string,google.golang.org/grpc/xds/internal/balancer/clustermanager.childConfig>
*bucket<string,google.golang.org/grpc/xds/internal/clusterspecifier.BalancerConfig>
*bucket<string,google.golang.org/grpc/xds/internal/clusterspecifier.ClusterSpecifier>
*bucket<string,google.golang.org/grpc/xds/internal/httpfilter.Filter>
*bucket<string,google.golang.org/grpc/xds/internal/httpfilter.FilterConfig>
*bucket<string,google.golang.org/grpc/xds/internal/resolver.xdsChildConfig>
*bucket<string,google.golang.org/grpc/xds/internal/xdsclient.resourceDataErrTuple>
*bucket<string,google.golang.org/grpc/xds/internal/xdsclient/load.LocalityData>
*bucket<string,google.golang.org/grpc/xds/internal/xdsclient/load.ServerLoadData>
*bucket<string,google.golang.org/grpc/xds/internal/xdsclient/xdslbregistry.Converter>
*bucket<string,google.golang.org/grpc/xds/internal/xdsclient/xdsresource.Type>
*bucket<string,google.golang.org/grpc/xds/internal/xdsclient/xdsresource.UpdateWithMD>
*bucket<string,google.golang.org/grpc/xds/internal/xdsclient/xdsresource.WeightedCluster>
*bucket<string,google.golang.org/protobuf/reflect/protoreflect.FieldDescriptor>
*bucket<string,gopkg.in/yaml%2ev3.fieldInfo>
*bucket<string,gopkg.in/yaml%2ev3.resolveMapItem>
*bucket<string,html/template.contentType>
*bucket<string,html/template.context>
*bucket<string,html/template.element>
*bucket<string,int32>
*bucket<string,int64>
*bucket<string,int>
*bucket<string,interface {}>
*bucket<string,map[google.golang.org/grpc/internal/transport.ServerTransport]bool>
*bucket<string,map[string]*google.golang.org/grpc/xds/internal/xdsclient/load.perClusterStore>
*bucket<string,map[string]bool>
*bucket<string,map[string]google.golang.org/grpc/xds/internal/xdsclient/xdsresource.UpdateWithMD>
*bucket<string,map[string]int>
*bucket<string,map[string]string>
*bucket<string,net.byName>
*bucket<string,net/http.RoundTripper>
*bucket<string,net/http.muxEntry>
*bucket<string,reflect.Value>
*bucket<string,regexp/syntax.charGroup>
*bucket<string,runtime.metricData>
*bucket<string,string>
*bucket<string,struct {}>
*bucket<string,text/template/parse.itemType>
*bucket<string,uint16>
*bucket<string,uint64>
*bucket<time.Duration,int>
*bucket<uint16,bool>
*bucket<uint16,struct {}>
*bucket<uint32,*golang.org/x/net/http2.clientStream>
*bucket<uint32,*google.golang.org/grpc/internal/transport.Stream>
*bucket<uint32,*google.golang.org/grpc/internal/transport.outStream>
*bucket<uint32,*net/http.http2clientStream>
*bucket<uint32,[]*internal/abi.Type>
*bucket<uint32,int32>
*bucket<uint32,map[string]bool>
*bucket<uint32,uint64>
*bucket<uint64,*net/rpc.Call>
*bucket<uint64,bool>
*bucket<uint64,func()>
*bucket<uint64,struct {}>
*bucket<uint8,uint8>
*bucket<uintptr,*runtime/pprof.profMapEntry>
*bucket<uintptr,runtime/pprof.locInfo>
*bucket<unsafe.Pointer,int32>
*bucket<vendor/golang.org/x/net/dns/dnsmessage.Class,string>
*bucket<vendor/golang.org/x/net/dns/dnsmessage.RCode,string>
*bucket<vendor/golang.org/x/net/dns/dnsmessage.section,string>
*bucket<vendor/golang.org/x/net/http2/hpack.pairNameValue,uint64>
*bufio.Reader
*bufio.Scanner
*bufio.Writer
*bytes.Buffer
*bytes.Reader
*bytes.asciiSet
*chan struct {}
*chan<- github.com/aws/aws-sdk-go/internal/sync/singleflight.Result
*chan<- internal/singleflight.Result
*cloud.google.com/go/auth.AuthorizationHandlerOptions
*cloud.google.com/go/auth.CachedTokenProviderOptions
*cloud.google.com/go/auth.Credentials
*cloud.google.com/go/auth.CredentialsOptions
*cloud.google.com/go/auth.CredentialsPropertyFunc
*cloud.google.com/go/auth.Error
*cloud.google.com/go/auth.Options2LO
*cloud.google.com/go/auth.Options3LO
*cloud.google.com/go/auth.PKCEOptions
*cloud.google.com/go/auth.Token
*cloud.google.com/go/auth.cachedTokenProvider
*cloud.google.com/go/auth.tokenJSON
*cloud.google.com/go/auth.tokenProvider2LO
*cloud.google.com/go/auth.tokenProvider3LO
*cloud.google.com/go/auth.tokenProviderWithHandler
*cloud.google.com/go/auth/credentials.DetectOptions
*cloud.google.com/go/auth/credentials.computeProvider
*cloud.google.com/go/auth/credentials.metadataTokenResp
*cloud.google.com/go/auth/credentials.selfSignedTokenProvider
*cloud.google.com/go/auth/credentials/internal/externalaccount.AwsSecurityCredentials
*cloud.google.com/go/auth/credentials/internal/externalaccount.Options
*cloud.google.com/go/auth/credentials/internal/externalaccount.RequestOptions
*cloud.google.com/go/auth/credentials/internal/externalaccount.awsRequest
*cloud.google.com/go/auth/credentials/internal/externalaccount.awsRequestHeader
*cloud.google.com/go/auth/credentials/internal/externalaccount.awsRequestSigner
*cloud.google.com/go/auth/credentials/internal/externalaccount.awsSubjectProvider
*cloud.google.com/go/auth/credentials/internal/externalaccount.executableResponse
*cloud.google.com/go/auth/credentials/internal/externalaccount.executableSubjectProvider
*cloud.google.com/go/auth/credentials/internal/externalaccount.fileSubjectProvider
*cloud.google.com/go/auth/credentials/internal/externalaccount.nonCacheableError
*cloud.google.com/go/auth/credentials/internal/externalaccount.programmaticProvider
*cloud.google.com/go/auth/credentials/internal/externalaccount.runtimeEnvironment
*cloud.google.com/go/auth/credentials/internal/externalaccount.tokenProvider
*cloud.google.com/go/auth/credentials/internal/externalaccount.urlSubjectProvider
*cloud.google.com/go/auth/credentials/internal/externalaccountuser.Options
*cloud.google.com/go/auth/credentials/internal/externalaccountuser.tokenProvider
*cloud.google.com/go/auth/credentials/internal/gdch.Options
*cloud.google.com/go/auth/credentials/internal/gdch.gdchProvider
*cloud.google.com/go/auth/credentials/internal/impersonate.Options
*cloud.google.com/go/auth/credentials/internal/impersonate.impersonateTokenResponse
*cloud.google.com/go/auth/credentials/internal/stsexchange.ClientAuthentication
*cloud.google.com/go/auth/credentials/internal/stsexchange.Options
*cloud.google.com/go/auth/credentials/internal/stsexchange.TokenRequest
*cloud.google.com/go/auth/credentials/internal/stsexchange.TokenResponse
*cloud.google.com/go/auth/grpctransport.InternalOptions
*cloud.google.com/go/auth/grpctransport.Options
*cloud.google.com/go/auth/grpctransport.grpcCredentialsProvider
*cloud.google.com/go/auth/grpctransport.multiError
*cloud.google.com/go/auth/grpctransport.roundRobinConnPool
*cloud.google.com/go/auth/grpctransport.singleConnPool
*cloud.google.com/go/auth/httptransport.InternalOptions
*cloud.google.com/go/auth/httptransport.Options
*cloud.google.com/go/auth/httptransport.apiKeyTransport
*cloud.google.com/go/auth/httptransport.authTransport
*cloud.google.com/go/auth/httptransport.headerTransport
*cloud.google.com/go/auth/httptransport.httpFormat
*cloud.google.com/go/auth/internal.ComputeUniverseDomainProvider
*cloud.google.com/go/auth/internal.StaticProperty
*cloud.google.com/go/auth/internal/credsfile.ClientCredentialsFile
*cloud.google.com/go/auth/internal/credsfile.Config3LO
*cloud.google.com/go/auth/internal/credsfile.CredentialSource
*cloud.google.com/go/auth/internal/credsfile.ExecutableConfig
*cloud.google.com/go/auth/internal/credsfile.ExternalAccountAuthorizedUserFile
*cloud.google.com/go/auth/internal/credsfile.ExternalAccountFile
*cloud.google.com/go/auth/internal/credsfile.Format
*cloud.google.com/go/auth/internal/credsfile.GDCHServiceAccountFile
*cloud.google.com/go/auth/internal/credsfile.ImpersonatedServiceAccountFile
*cloud.google.com/go/auth/internal/credsfile.ServiceAccountFile
*cloud.google.com/go/auth/internal/credsfile.ServiceAccountImpersonationInfo
*cloud.google.com/go/auth/internal/credsfile.UserCredentialsFile
*cloud.google.com/go/auth/internal/credsfile.fileTypeChecker
*cloud.google.com/go/auth/internal/jwt.Claims
*cloud.google.com/go/auth/internal/jwt.Header
*cloud.google.com/go/auth/internal/transport.Options
*cloud.google.com/go/auth/internal/transport.metadataMTLSAutoConfig
*cloud.google.com/go/auth/internal/transport.mtlsConfig
*cloud.google.com/go/auth/internal/transport.reuseMTLSConfigSource
*cloud.google.com/go/auth/internal/transport.s2aAddresses
*cloud.google.com/go/auth/internal/transport.transportConfig
*cloud.google.com/go/auth/internal/transport/cert.ecpSource
*cloud.google.com/go/auth/internal/transport/cert.secureConnectMetadata
*cloud.google.com/go/auth/internal/transport/cert.secureConnectSource
*cloud.google.com/go/auth/oauth2adapt.oauth2Error
*cloud.google.com/go/auth/oauth2adapt.tokenProviderAdapter
*cloud.google.com/go/auth/oauth2adapt.tokenSourceAdapter
*cloud.google.com/go/compute/metadata.Client
*cloud.google.com/go/compute/metadata.Error
*cloud.google.com/go/compute/metadata.NotDefinedError
*cloud.google.com/go/compute/metadata.cachedValue
*cloud.google.com/go/compute/metadata.defaultBackoff
*cloud.google.com/go/compute/metadata.metadataRetryer
*cloud.google.com/go/iam.Handle
*cloud.google.com/go/iam.Handle3
*cloud.google.com/go/iam.Policy
*cloud.google.com/go/iam.Policy3
*cloud.google.com/go/iam.RoleName
*cloud.google.com/go/iam/apiv1/iampb.AuditConfig
*cloud.google.com/go/iam/apiv1/iampb.AuditConfigDelta
*cloud.google.com/go/iam/apiv1/iampb.AuditConfigDelta_Action
*cloud.google.com/go/iam/apiv1/iampb.AuditLogConfig
*cloud.google.com/go/iam/apiv1/iampb.AuditLogConfig_LogType
*cloud.google.com/go/iam/apiv1/iampb.Binding
*cloud.google.com/go/iam/apiv1/iampb.BindingDelta
*cloud.google.com/go/iam/apiv1/iampb.BindingDelta_Action
*cloud.google.com/go/iam/apiv1/iampb.GetIamPolicyRequest
*cloud.google.com/go/iam/apiv1/iampb.GetPolicyOptions
*cloud.google.com/go/iam/apiv1/iampb.Policy
*cloud.google.com/go/iam/apiv1/iampb.PolicyDelta
*cloud.google.com/go/iam/apiv1/iampb.SetIamPolicyRequest
*cloud.google.com/go/iam/apiv1/iampb.TestIamPermissionsRequest
*cloud.google.com/go/iam/apiv1/iampb.TestIamPermissionsResponse
*cloud.google.com/go/internal.wrappedCallErr
*cloud.google.com/go/longrunning.Operation
*cloud.google.com/go/longrunning/autogen.OperationIterator
*cloud.google.com/go/longrunning/autogen.OperationsCallOptions
*cloud.google.com/go/longrunning/autogen.OperationsClient
*cloud.google.com/go/longrunning/autogen.operationsGRPCClient
*cloud.google.com/go/longrunning/autogen/longrunningpb.CancelOperationRequest
*cloud.google.com/go/longrunning/autogen/longrunningpb.DeleteOperationRequest
*cloud.google.com/go/longrunning/autogen/longrunningpb.GetOperationRequest
*cloud.google.com/go/longrunning/autogen/longrunningpb.ListOperationsRequest
*cloud.google.com/go/longrunning/autogen/longrunningpb.ListOperationsResponse
*cloud.google.com/go/longrunning/autogen/longrunningpb.Operation
*cloud.google.com/go/longrunning/autogen/longrunningpb.OperationInfo
*cloud.google.com/go/longrunning/autogen/longrunningpb.Operation_Error
*cloud.google.com/go/longrunning/autogen/longrunningpb.Operation_Response
*cloud.google.com/go/longrunning/autogen/longrunningpb.WaitOperationRequest
*cloud.google.com/go/longrunning/autogen/longrunningpb.operationsClient
*cloud.google.com/go/monitoring/apiv3/v2.MetricCallOptions
*cloud.google.com/go/monitoring/apiv3/v2.MetricClient
*cloud.google.com/go/monitoring/apiv3/v2.MetricDescriptorIterator
*cloud.google.com/go/monitoring/apiv3/v2.MonitoredResourceDescriptorIterator
*cloud.google.com/go/monitoring/apiv3/v2.TimeSeriesIterator
*cloud.google.com/go/monitoring/apiv3/v2.metricGRPCClient
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Aggregation
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Aggregation_Aligner
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Aggregation_Reducer
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_AlertStrategy
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_AlertStrategy_NotificationChannelStrategy
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_AlertStrategy_NotificationRateLimit
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_ConditionCombinerType
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_ConditionAbsent
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_ConditionMatchedLog
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_ConditionMonitoringQueryLanguage
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_ConditionPrometheusQueryLanguage
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_ConditionThreshold
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_EvaluationMissingData
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_LogMatch
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_MetricAbsence
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_MetricThreshold
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_MetricThreshold_ForecastOptions
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_MonitoringQueryLanguageCondition
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_PrometheusQueryLanguageCondition
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_Trigger
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_Trigger_Count
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Condition_Trigger_Percent
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Documentation
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.AlertPolicy_Severity
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.BasicSli
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.BasicSli_Availability
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.BasicSli_AvailabilityCriteria
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.BasicSli_Latency
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.BasicSli_LatencyCriteria
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ComparisonType
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateAlertPolicyRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateGroupRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateMetricDescriptorRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateNotificationChannelRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateServiceLevelObjectiveRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateServiceRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateSnoozeRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateTimeSeriesError
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateTimeSeriesRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateTimeSeriesSummary
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateTimeSeriesSummary_Error
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.CreateUptimeCheckConfigRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DeleteAlertPolicyRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DeleteGroupRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DeleteMetricDescriptorRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DeleteNotificationChannelRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DeleteServiceLevelObjectiveRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DeleteServiceRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DeleteUptimeCheckConfigRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DistributionCut
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.DroppedLabels
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetAlertPolicyRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetGroupRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetMetricDescriptorRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetMonitoredResourceDescriptorRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetNotificationChannelDescriptorRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetNotificationChannelRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetNotificationChannelVerificationCodeRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetNotificationChannelVerificationCodeResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetServiceLevelObjectiveRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetServiceRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetSnoozeRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GetUptimeCheckConfigRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Group
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.GroupResourceType
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.InternalChecker
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.InternalChecker_State
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.LabelValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.LabelValue_BoolValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.LabelValue_Int64Value
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.LabelValue_StringValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListAlertPoliciesRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListAlertPoliciesResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListGroupMembersRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListGroupMembersResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListGroupsRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListGroupsRequest_AncestorsOfGroup
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListGroupsRequest_ChildrenOfGroup
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListGroupsRequest_DescendantsOfGroup
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListGroupsResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListMetricDescriptorsRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListMetricDescriptorsResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListMonitoredResourceDescriptorsRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListMonitoredResourceDescriptorsResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListNotificationChannelDescriptorsRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListNotificationChannelDescriptorsResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListNotificationChannelsRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListNotificationChannelsResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListServiceLevelObjectivesRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListServiceLevelObjectivesResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListServicesRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListServicesResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListSnoozesRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListSnoozesResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListTimeSeriesRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListTimeSeriesRequest_TimeSeriesView
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListTimeSeriesResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListUptimeCheckConfigsRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListUptimeCheckConfigsResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListUptimeCheckIpsRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ListUptimeCheckIpsResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.MutationRecord
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.NotificationChannel
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.NotificationChannelDescriptor
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.NotificationChannel_VerificationStatus
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Point
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.QueryError
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.QueryErrorList
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.QueryTimeSeriesRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.QueryTimeSeriesResponse
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Range
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.RequestBasedSli
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.RequestBasedSli_DistributionCut
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.RequestBasedSli_GoodTotalRatio
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.SendNotificationChannelVerificationCodeRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelIndicator
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelIndicator_BasicSli
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelIndicator_RequestBased
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelIndicator_WindowsBased
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelObjective
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelObjective_CalendarPeriod
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelObjective_RollingPeriod
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceLevelObjective_View
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.ServiceTier
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_AppEngine
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_AppEngine_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_CloudEndpoints
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_CloudEndpoints_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_ClusterIstio
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_ClusterIstio_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_Custom
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_Custom_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_IstioCanonicalService
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_IstioCanonicalService_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_MeshIstio
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_MeshIstio_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Service_Telemetry
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Snooze
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.Snooze_Criteria
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.SpanContext
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TextLocator
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TextLocator_Position
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeInterval
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeries
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesData
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesData_PointData
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesDescriptor
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesDescriptor_ValueDescriptor
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TimeSeriesRatio
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TypedValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TypedValue_BoolValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TypedValue_DistributionValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TypedValue_DoubleValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TypedValue_Int64Value
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.TypedValue_StringValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UpdateAlertPolicyRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UpdateGroupRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UpdateNotificationChannelRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UpdateServiceLevelObjectiveRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UpdateServiceRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UpdateSnoozeRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UpdateUptimeCheckConfigRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_CheckerType
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ContentMatcher
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ContentMatcher_ContentMatcherOption
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ContentMatcher_JsonPathMatcher
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ContentMatcher_JsonPathMatcher_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_BasicAuthentication
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_ContentType
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_RequestMethod
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_ResponseStatusCode
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusValue
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_MonitoredResource
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_PingConfig
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ResourceGroup
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_ResourceGroup_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_TcpCheck
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckConfig_TcpCheck_
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckIp
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.UptimeCheckRegion
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.VerifyNotificationChannelRequest
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli_GoodBadMetricFilter
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli_GoodTotalRatioThreshold
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli_MetricMeanInRange
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli_MetricRange
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli_MetricSumInRange
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli_PerformanceThreshold
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli_PerformanceThreshold_BasicSliPerformance
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.WindowsBasedSli_PerformanceThreshold_Performance
*cloud.google.com/go/monitoring/apiv3/v2/monitoringpb.metricServiceClient
*cloud.google.com/go/pubsub/apiv1/pubsubpb.AcknowledgeRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.BigQueryConfig
*cloud.google.com/go/pubsub/apiv1/pubsubpb.BigQueryConfig_State
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CloudStorageConfig
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CloudStorageConfig_AvroConfig
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CloudStorageConfig_AvroConfig_
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CloudStorageConfig_State
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CloudStorageConfig_TextConfig
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CloudStorageConfig_TextConfig_
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CommitSchemaRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CreateSchemaRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.CreateSnapshotRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.DeadLetterPolicy
*cloud.google.com/go/pubsub/apiv1/pubsubpb.DeleteSchemaRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.DeleteSchemaRevisionRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.DeleteSnapshotRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.DeleteSubscriptionRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.DeleteTopicRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.DetachSubscriptionRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.DetachSubscriptionResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.Encoding
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ExpirationPolicy
*cloud.google.com/go/pubsub/apiv1/pubsubpb.GetSchemaRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.GetSnapshotRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.GetSubscriptionRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.GetTopicRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.IngestionDataSourceSettings
*cloud.google.com/go/pubsub/apiv1/pubsubpb.IngestionDataSourceSettings_AwsKinesis
*cloud.google.com/go/pubsub/apiv1/pubsubpb.IngestionDataSourceSettings_AwsKinesis_
*cloud.google.com/go/pubsub/apiv1/pubsubpb.IngestionDataSourceSettings_AwsKinesis_State
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListSchemaRevisionsRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListSchemaRevisionsResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListSchemasRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListSchemasResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListSnapshotsRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListSnapshotsResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListSubscriptionsRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListSubscriptionsResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListTopicSnapshotsRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListTopicSnapshotsResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListTopicSubscriptionsRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListTopicSubscriptionsResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListTopicsRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ListTopicsResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.MessageStoragePolicy
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ModifyAckDeadlineRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ModifyPushConfigRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PublishRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PublishResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PubsubMessage
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PullRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PullResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PushConfig
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PushConfig_NoWrapper
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PushConfig_NoWrapper_
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PushConfig_OidcToken
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PushConfig_OidcToken_
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PushConfig_PubsubWrapper
*cloud.google.com/go/pubsub/apiv1/pubsubpb.PushConfig_PubsubWrapper_
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ReceivedMessage
*cloud.google.com/go/pubsub/apiv1/pubsubpb.RetryPolicy
*cloud.google.com/go/pubsub/apiv1/pubsubpb.RollbackSchemaRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.Schema
*cloud.google.com/go/pubsub/apiv1/pubsubpb.SchemaSettings
*cloud.google.com/go/pubsub/apiv1/pubsubpb.SchemaView
*cloud.google.com/go/pubsub/apiv1/pubsubpb.Schema_Type
*cloud.google.com/go/pubsub/apiv1/pubsubpb.SeekRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.SeekRequest_Snapshot
*cloud.google.com/go/pubsub/apiv1/pubsubpb.SeekRequest_Time
*cloud.google.com/go/pubsub/apiv1/pubsubpb.SeekResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.Snapshot
*cloud.google.com/go/pubsub/apiv1/pubsubpb.StreamingPullRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.StreamingPullResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.StreamingPullResponse_AcknowledgeConfirmation
*cloud.google.com/go/pubsub/apiv1/pubsubpb.StreamingPullResponse_ModifyAckDeadlineConfirmation
*cloud.google.com/go/pubsub/apiv1/pubsubpb.StreamingPullResponse_SubscriptionProperties
*cloud.google.com/go/pubsub/apiv1/pubsubpb.Subscription
*cloud.google.com/go/pubsub/apiv1/pubsubpb.Subscription_State
*cloud.google.com/go/pubsub/apiv1/pubsubpb.Topic
*cloud.google.com/go/pubsub/apiv1/pubsubpb.Topic_State
*cloud.google.com/go/pubsub/apiv1/pubsubpb.UpdateSnapshotRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.UpdateSubscriptionRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.UpdateTopicRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ValidateMessageRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ValidateMessageRequest_Name
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ValidateMessageRequest_Schema
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ValidateMessageResponse
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ValidateSchemaRequest
*cloud.google.com/go/pubsub/apiv1/pubsubpb.ValidateSchemaResponse
*cloud.google.com/go/storage.ACLHandle
*cloud.google.com/go/storage.ACLRule
*cloud.google.com/go/storage.Autoclass
*cloud.google.com/go/storage.BucketAttrs
*cloud.google.com/go/storage.BucketAttrsToUpdate
*cloud.google.com/go/storage.BucketConditions
*cloud.google.com/go/storage.BucketEncryption
*cloud.google.com/go/storage.BucketHandle
*cloud.google.com/go/storage.BucketIterator
*cloud.google.com/go/storage.BucketLogging
*cloud.google.com/go/storage.BucketPolicyOnly
*cloud.google.com/go/storage.BucketWebsite
*cloud.google.com/go/storage.CORS
*cloud.google.com/go/storage.Client
*cloud.google.com/go/storage.Composer
*cloud.google.com/go/storage.Conditions
*cloud.google.com/go/storage.Copier
*cloud.google.com/go/storage.CustomPlacementConfig
*cloud.google.com/go/storage.HMACKey
*cloud.google.com/go/storage.HMACKeyAttrsToUpdate
*cloud.google.com/go/storage.HMACKeyHandle
*cloud.google.com/go/storage.HMACKeyOption
*cloud.google.com/go/storage.HMACKeysIterator
*cloud.google.com/go/storage.Lifecycle
*cloud.google.com/go/storage.LifecycleAction
*cloud.google.com/go/storage.LifecycleRule
*cloud.google.com/go/storage.Notification
*cloud.google.com/go/storage.ObjectAttrs
*cloud.google.com/go/storage.ObjectAttrsToUpdate
*cloud.google.com/go/storage.ObjectHandle
*cloud.google.com/go/storage.ObjectIterator
*cloud.google.com/go/storage.ObjectRetention
*cloud.google.com/go/storage.PolicyV4Fields
*cloud.google.com/go/storage.PostPolicyV4
*cloud.google.com/go/storage.PostPolicyV4Condition
*cloud.google.com/go/storage.PostPolicyV4Options
*cloud.google.com/go/storage.ProjectTeam
*cloud.google.com/go/storage.Projection
*cloud.google.com/go/storage.PublicAccessPrevention
*cloud.google.com/go/storage.Query
*cloud.google.com/go/storage.RPO
*cloud.google.com/go/storage.Reader
*cloud.google.com/go/storage.ReaderObjectAttrs
*cloud.google.com/go/storage.RetentionPolicy
*cloud.google.com/go/storage.RetryOption
*cloud.google.com/go/storage.SignedURLOptions
*cloud.google.com/go/storage.UniformBucketLevelAccess
*cloud.google.com/go/storage.Writer
*cloud.google.com/go/storage.bytesCodec
*cloud.google.com/go/storage.clientOption
*cloud.google.com/go/storage.composeObjectRequest
*cloud.google.com/go/storage.composeSourceObj
*cloud.google.com/go/storage.gRPCReader
*cloud.google.com/go/storage.gRPCWriter
*cloud.google.com/go/storage.grpcStorageClient
*cloud.google.com/go/storage.hmacKeyDesc
*cloud.google.com/go/storage.httpReader
*cloud.google.com/go/storage.httpStorageClient
*cloud.google.com/go/storage.iamClient
*cloud.google.com/go/storage.idempotentOption
*cloud.google.com/go/storage.newRangeReaderParams
*cloud.google.com/go/storage.openWriterParams
*cloud.google.com/go/storage.pathStyle
*cloud.google.com/go/storage.readStreamResponse
*cloud.google.com/go/storage.retryConfig
*cloud.google.com/go/storage.retryOption
*cloud.google.com/go/storage.rewriteObjectRequest
*cloud.google.com/go/storage.rewriteObjectResponse
*cloud.google.com/go/storage.settings
*cloud.google.com/go/storage.singleValueCondition
*cloud.google.com/go/storage.sourceObject
*cloud.google.com/go/storage.storageConfig
*cloud.google.com/go/storage.storageOption
*cloud.google.com/go/storage.updateObjectParams
*cloud.google.com/go/storage.userProjectOption
*cloud.google.com/go/storage.withBackoff
*cloud.google.com/go/storage.withErrorFunc
*cloud.google.com/go/storage.withPolicy
*cloud.google.com/go/storage.withReadAPI
*cloud.google.com/go/storage/control/apiv2.FolderIterator
*cloud.google.com/go/storage/control/apiv2.RenameFolderOperation
*cloud.google.com/go/storage/control/apiv2.StorageControlCallOptions
*cloud.google.com/go/storage/control/apiv2.StorageControlClient
*cloud.google.com/go/storage/control/apiv2.storageControlGRPCClient
*cloud.google.com/go/storage/control/apiv2/controlpb.CommonLongRunningOperationMetadata
*cloud.google.com/go/storage/control/apiv2/controlpb.CreateFolderRequest
*cloud.google.com/go/storage/control/apiv2/controlpb.DeleteFolderRequest
*cloud.google.com/go/storage/control/apiv2/controlpb.Folder
*cloud.google.com/go/storage/control/apiv2/controlpb.GetFolderRequest
*cloud.google.com/go/storage/control/apiv2/controlpb.GetStorageLayoutRequest
*cloud.google.com/go/storage/control/apiv2/controlpb.ListFoldersRequest
*cloud.google.com/go/storage/control/apiv2/controlpb.ListFoldersResponse
*cloud.google.com/go/storage/control/apiv2/controlpb.PendingRenameInfo
*cloud.google.com/go/storage/control/apiv2/controlpb.RenameFolderMetadata
*cloud.google.com/go/storage/control/apiv2/controlpb.RenameFolderRequest
*cloud.google.com/go/storage/control/apiv2/controlpb.StorageLayout
*cloud.google.com/go/storage/control/apiv2/controlpb.StorageLayout_CustomPlacementConfig
*cloud.google.com/go/storage/control/apiv2/controlpb.StorageLayout_HierarchicalNamespace
*cloud.google.com/go/storage/control/apiv2/controlpb.storageControlClient
*cloud.google.com/go/storage/internal/apiv2.BucketIterator
*cloud.google.com/go/storage/internal/apiv2.CallOptions
*cloud.google.com/go/storage/internal/apiv2.Client
*cloud.google.com/go/storage/internal/apiv2.HmacKeyMetadataIterator
*cloud.google.com/go/storage/internal/apiv2.NotificationConfigIterator
*cloud.google.com/go/storage/internal/apiv2.ObjectIterator
*cloud.google.com/go/storage/internal/apiv2.gRPCClient
*cloud.google.com/go/storage/internal/apiv2/storagepb.BidiWriteObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.BidiWriteObjectRequest_ChecksummedData
*cloud.google.com/go/storage/internal/apiv2/storagepb.BidiWriteObjectRequest_UploadId
*cloud.google.com/go/storage/internal/apiv2/storagepb.BidiWriteObjectRequest_WriteObjectSpec
*cloud.google.com/go/storage/internal/apiv2/storagepb.BidiWriteObjectResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.BidiWriteObjectResponse_PersistedSize
*cloud.google.com/go/storage/internal/apiv2/storagepb.BidiWriteObjectResponse_Resource
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket
*cloud.google.com/go/storage/internal/apiv2/storagepb.BucketAccessControl
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Autoclass
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Billing
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Cors
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_CustomPlacementConfig
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Encryption
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_HierarchicalNamespace
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_IamConfig
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_IamConfig_UniformBucketLevelAccess
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Lifecycle
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Lifecycle_Rule
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Lifecycle_Rule_Action
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Lifecycle_Rule_Condition
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Logging
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_RetentionPolicy
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_SoftDeletePolicy
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Versioning
*cloud.google.com/go/storage/internal/apiv2/storagepb.Bucket_Website
*cloud.google.com/go/storage/internal/apiv2/storagepb.CancelResumableWriteRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.CancelResumableWriteResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.ChecksummedData
*cloud.google.com/go/storage/internal/apiv2/storagepb.CommonObjectRequestParams
*cloud.google.com/go/storage/internal/apiv2/storagepb.ComposeObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.ComposeObjectRequest_SourceObject
*cloud.google.com/go/storage/internal/apiv2/storagepb.ComposeObjectRequest_SourceObject_ObjectPreconditions
*cloud.google.com/go/storage/internal/apiv2/storagepb.ContentRange
*cloud.google.com/go/storage/internal/apiv2/storagepb.CreateBucketRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.CreateHmacKeyRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.CreateHmacKeyResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.CreateNotificationConfigRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.CustomerEncryption
*cloud.google.com/go/storage/internal/apiv2/storagepb.DeleteBucketRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.DeleteHmacKeyRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.DeleteNotificationConfigRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.DeleteObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.GetBucketRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.GetHmacKeyRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.GetNotificationConfigRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.GetObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.GetServiceAccountRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.HmacKeyMetadata
*cloud.google.com/go/storage/internal/apiv2/storagepb.ListBucketsRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.ListBucketsResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.ListHmacKeysRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.ListHmacKeysResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.ListNotificationConfigsRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.ListNotificationConfigsResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.ListObjectsRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.ListObjectsResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.LockBucketRetentionPolicyRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.NotificationConfig
*cloud.google.com/go/storage/internal/apiv2/storagepb.Object
*cloud.google.com/go/storage/internal/apiv2/storagepb.ObjectAccessControl
*cloud.google.com/go/storage/internal/apiv2/storagepb.ObjectChecksums
*cloud.google.com/go/storage/internal/apiv2/storagepb.Owner
*cloud.google.com/go/storage/internal/apiv2/storagepb.ProjectTeam
*cloud.google.com/go/storage/internal/apiv2/storagepb.QueryWriteStatusRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.QueryWriteStatusResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.QueryWriteStatusResponse_PersistedSize
*cloud.google.com/go/storage/internal/apiv2/storagepb.QueryWriteStatusResponse_Resource
*cloud.google.com/go/storage/internal/apiv2/storagepb.ReadObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.ReadObjectResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.RestoreObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.RewriteObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.RewriteResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.ServiceAccount
*cloud.google.com/go/storage/internal/apiv2/storagepb.ServiceConstants
*cloud.google.com/go/storage/internal/apiv2/storagepb.ServiceConstants_Values
*cloud.google.com/go/storage/internal/apiv2/storagepb.StartResumableWriteRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.StartResumableWriteResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.Storage_BidiWriteObjectClient
*cloud.google.com/go/storage/internal/apiv2/storagepb.Storage_ReadObjectClient
*cloud.google.com/go/storage/internal/apiv2/storagepb.Storage_WriteObjectClient
*cloud.google.com/go/storage/internal/apiv2/storagepb.UpdateBucketRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.UpdateHmacKeyRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.UpdateObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.WriteObjectRequest
*cloud.google.com/go/storage/internal/apiv2/storagepb.WriteObjectRequest_ChecksummedData
*cloud.google.com/go/storage/internal/apiv2/storagepb.WriteObjectRequest_UploadId
*cloud.google.com/go/storage/internal/apiv2/storagepb.WriteObjectRequest_WriteObjectSpec
*cloud.google.com/go/storage/internal/apiv2/storagepb.WriteObjectResponse
*cloud.google.com/go/storage/internal/apiv2/storagepb.WriteObjectResponse_PersistedSize
*cloud.google.com/go/storage/internal/apiv2/storagepb.WriteObjectResponse_Resource
*cloud.google.com/go/storage/internal/apiv2/storagepb.WriteObjectSpec
*cloud.google.com/go/storage/internal/apiv2/storagepb.storageBidiWriteObjectClient
*cloud.google.com/go/storage/internal/apiv2/storagepb.storageBidiWriteObjectServer
*cloud.google.com/go/storage/internal/apiv2/storagepb.storageClient
*cloud.google.com/go/storage/internal/apiv2/storagepb.storageReadObjectClient
*cloud.google.com/go/storage/internal/apiv2/storagepb.storageReadObjectServer
*cloud.google.com/go/storage/internal/apiv2/storagepb.storageWriteObjectClient
*cloud.google.com/go/storage/internal/apiv2/storagepb.storageWriteObjectServer
*cloud.google.com/go/trace/apiv2.CallOptions
*cloud.google.com/go/trace/apiv2.Client
*cloud.google.com/go/trace/apiv2.gRPCClient
*cloud.google.com/go/trace/apiv2/tracepb.AttributeValue
*cloud.google.com/go/trace/apiv2/tracepb.AttributeValue_BoolValue
*cloud.google.com/go/trace/apiv2/tracepb.AttributeValue_IntValue
*cloud.google.com/go/trace/apiv2/tracepb.AttributeValue_StringValue
*cloud.google.com/go/trace/apiv2/tracepb.BatchWriteSpansRequest
*cloud.google.com/go/trace/apiv2/tracepb.Module
*cloud.google.com/go/trace/apiv2/tracepb.Span
*cloud.google.com/go/trace/apiv2/tracepb.Span_Attributes
*cloud.google.com/go/trace/apiv2/tracepb.Span_Link
*cloud.google.com/go/trace/apiv2/tracepb.Span_Link_Type
*cloud.google.com/go/trace/apiv2/tracepb.Span_Links
*cloud.google.com/go/trace/apiv2/tracepb.Span_SpanKind
*cloud.google.com/go/trace/apiv2/tracepb.Span_TimeEvent
*cloud.google.com/go/trace/apiv2/tracepb.Span_TimeEvent_Annotation
*cloud.google.com/go/trace/apiv2/tracepb.Span_TimeEvent_Annotation_
*cloud.google.com/go/trace/apiv2/tracepb.Span_TimeEvent_MessageEvent
*cloud.google.com/go/trace/apiv2/tracepb.Span_TimeEvent_MessageEvent_
*cloud.google.com/go/trace/apiv2/tracepb.Span_TimeEvent_MessageEvent_Type
*cloud.google.com/go/trace/apiv2/tracepb.Span_TimeEvents
*cloud.google.com/go/trace/apiv2/tracepb.StackTrace
*cloud.google.com/go/trace/apiv2/tracepb.StackTrace_StackFrame
*cloud.google.com/go/trace/apiv2/tracepb.StackTrace_StackFrames
*cloud.google.com/go/trace/apiv2/tracepb.TruncatableString
*cloud.google.com/go/trace/apiv2/tracepb.traceServiceClient
*complex128
*complex64
*compress/flate.CorruptInputError
*compress/flate.InternalError
*compress/flate.Writer
*compress/flate.byFreq
*compress/flate.byLiteral
*compress/flate.compressionLevel
*compress/flate.compressor
*compress/flate.decompressor
*compress/flate.deflateFast
*compress/flate.dictDecoder
*compress/flate.dictWriter
*compress/flate.hcode
*compress/flate.huffmanBitWriter
*compress/flate.huffmanDecoder
*compress/flate.huffmanEncoder
*compress/flate.levelInfo
*compress/flate.literalNode
*compress/flate.tableEntry
*compress/flate.token
*compress/gzip.Reader
*compress/gzip.Writer
*container/list.Element
*container/list.List
*context.CancelFunc
*context.Context
*context.backgroundCtx
*context.cancelCtx
*context.deadlineExceededError
*context.emptyCtx
*context.stopCtx
*context.timerCtx
*context.todoCtx
*context.valueCtx
*context.withoutCancelCtx
*contrib.go.opencensus.io/exporter/ocagent.Exporter
*contrib.go.opencensus.io/exporter/ocagent.ExporterOption
*contrib.go.opencensus.io/exporter/ocagent.addressSetter
*contrib.go.opencensus.io/exporter/ocagent.reconnectionPeriod
*contrib.go.opencensus.io/exporter/ocagent.serviceNameSetter
*contrib.go.opencensus.io/exporter/stackdriver.Exporter
*contrib.go.opencensus.io/exporter/stackdriver.Labels
*contrib.go.opencensus.io/exporter/stackdriver.labelValue
*contrib.go.opencensus.io/exporter/stackdriver.metricsBatcher
*contrib.go.opencensus.io/exporter/stackdriver.overflowLogger
*contrib.go.opencensus.io/exporter/stackdriver.response
*contrib.go.opencensus.io/exporter/stackdriver.statsExporter
*contrib.go.opencensus.io/exporter/stackdriver.traceExporter
*contrib.go.opencensus.io/exporter/stackdriver.worker
*contrib.go.opencensus.io/exporter/stackdriver/monitoredresource.Interface
*contrib.go.opencensus.io/exporter/stackdriver/monitoredresource/gcp.GCEInstance
*contrib.go.opencensus.io/exporter/stackdriver/monitoredresource/gcp.GKEContainer
*contrib.go.opencensus.io/exporter/stackdriver/monitoredresource/gcp.Interface
*contrib.go.opencensus.io/exporter/stackdriver/monitoredresource/gcp.gcpMetadata
*crypto.Hash
*crypto/aes.KeySizeError
*crypto/aes.aesCipher
*crypto/aes.aesCipherAsm
*crypto/aes.aesCipherGCM
*crypto/aes.gcmAsm
*crypto/cipher.StreamReader
*crypto/cipher.cbc
*crypto/cipher.cbcDecrypter
*crypto/cipher.cbcEncrypter
*crypto/cipher.ctr
*crypto/cipher.gcm
*crypto/cipher.gcmFieldElement
*crypto/des.KeySizeError
*crypto/des.desCipher
*crypto/des.tripleDESCipher
*crypto/dsa.PublicKey
*crypto/ecdh.PrivateKey
*crypto/ecdh.PublicKey
*crypto/ecdh.nistCurve[*crypto/internal/nistec.P256Point]
*crypto/ecdh.nistCurve[*crypto/internal/nistec.P384Point]
*crypto/ecdh.nistCurve[*crypto/internal/nistec.P521Point]
*crypto/ecdh.nistCurve[go.shape.*uint8]
*crypto/ecdh.x25519Curve
*crypto/ecdsa.PrivateKey
*crypto/ecdsa.PublicKey
*crypto/ecdsa.boringPriv
*crypto/ecdsa.boringPub
*crypto/ecdsa.nistCurve[*crypto/internal/nistec.P224Point]
*crypto/ecdsa.nistCurve[*crypto/internal/nistec.P256Point]
*crypto/ecdsa.nistCurve[*crypto/internal/nistec.P384Point]
*crypto/ecdsa.nistCurve[*crypto/internal/nistec.P521Point]
*crypto/ecdsa.nistCurve[go.shape.*uint8]
*crypto/ecdsa.zr
*crypto/ed25519.Options
*crypto/ed25519.PrivateKey
*crypto/ed25519.PublicKey
*crypto/elliptic.Curve
*crypto/elliptic.CurveParams
*crypto/elliptic.nistCurve[*crypto/internal/nistec.P224Point]
*crypto/elliptic.nistCurve[*crypto/internal/nistec.P256Point]
*crypto/elliptic.nistCurve[*crypto/internal/nistec.P384Point]
*crypto/elliptic.nistCurve[*crypto/internal/nistec.P521Point]
*crypto/elliptic.nistCurve[go.shape.*uint8]
*crypto/elliptic.p256Curve
*crypto/hmac.hmac
*crypto/internal/bigmod.Modulus
*crypto/internal/bigmod.Nat
*crypto/internal/boring.PrivateKeyECDH
*crypto/internal/boring.PrivateKeyECDSA
*crypto/internal/boring.PrivateKeyRSA
*crypto/internal/boring.PublicKeyECDH
*crypto/internal/boring.PublicKeyECDSA
*crypto/internal/boring.PublicKeyRSA
*crypto/internal/boring/bcache.Cache[crypto/ecdsa.PrivateKey,crypto/ecdsa.boringPriv]
*crypto/internal/boring/bcache.Cache[crypto/ecdsa.PublicKey,crypto/ecdsa.boringPub]
*crypto/internal/boring/bcache.Cache[crypto/rsa.PrivateKey,crypto/rsa.boringPriv]
*crypto/internal/boring/bcache.Cache[crypto/rsa.PublicKey,crypto/rsa.boringPub]
*crypto/internal/boring/bcache.Cache[go.shape.struct { N *math/big.Int; E int },go.shape.struct { crypto/rsa.key *crypto/internal/boring.PublicKeyRSA; cr
ypto/rsa.orig crypto/rsa.PublicKey }]
*crypto/internal/boring/bcache.Cache[go.shape.struct { crypto/ecdsa.PublicKey; D *math/big.Int },go.shape.struct { crypto/ecdsa.key *crypto/internal/bori
ng.PrivateKeyECDSA; crypto/ecdsa.orig crypto/ecdsa.PrivateKey }]
*crypto/internal/boring/bcache.Cache[go.shape.struct { crypto/elliptic.Curve; X *math/big.Int; Y *math/big.Int },go.shape.struct { crypto/ecdsa.key *cryp
to/internal/boring.PublicKeyECDSA; crypto/ecdsa.orig crypto/ecdsa.PublicKey }]
*crypto/internal/boring/bcache.Cache[go.shape.struct { crypto/rsa.PublicKey; D *math/big.Int; Primes []*math/big.Int; Precomputed crypto/rsa.PrecomputedV
alues },go.shape.struct { crypto/rsa.key *crypto/internal/boring.PrivateKeyRSA; crypto/rsa.orig crypto/rsa.PrivateKey }]
*crypto/internal/boring/bcache.cacheEntry[crypto/ecdsa.PrivateKey,crypto/ecdsa.boringPriv]
*crypto/internal/boring/bcache.cacheEntry[crypto/ecdsa.PublicKey,crypto/ecdsa.boringPub]
*crypto/internal/boring/bcache.cacheEntry[crypto/rsa.PrivateKey,crypto/rsa.boringPriv]
*crypto/internal/boring/bcache.cacheEntry[crypto/rsa.PublicKey,crypto/rsa.boringPub]
*crypto/internal/boring/bcache.cacheEntry[go.shape.struct { N *math/big.Int; E int },go.shape.struct { crypto/rsa.key *crypto/internal/boring.PublicKeyRS
A; crypto/rsa.orig crypto/rsa.PublicKey }]
*crypto/internal/boring/bcache.cacheEntry[go.shape.struct { crypto/ecdsa.PublicKey; D *math/big.Int },go.shape.struct { crypto/ecdsa.key *crypto/internal
/boring.PrivateKeyECDSA; crypto/ecdsa.orig crypto/ecdsa.PrivateKey }]
*crypto/internal/boring/bcache.cacheEntry[go.shape.struct { crypto/elliptic.Curve; X *math/big.Int; Y *math/big.Int },go.shape.struct { crypto/ecdsa.key 
*crypto/internal/boring.PublicKeyECDSA; crypto/ecdsa.orig crypto/ecdsa.PublicKey }]
*crypto/internal/boring/bcache.cacheEntry[go.shape.struct { crypto/rsa.PublicKey; D *math/big.Int; Primes []*math/big.Int; Precomputed crypto/rsa.Precomp
utedValues },go.shape.struct { crypto/rsa.key *crypto/internal/boring.PrivateKeyRSA; crypto/rsa.orig crypto/rsa.PrivateKey }]
*crypto/internal/boring/bcache.cacheTable[crypto/ecdsa.PrivateKey,crypto/ecdsa.boringPriv]
*crypto/internal/boring/bcache.cacheTable[crypto/ecdsa.PublicKey,crypto/ecdsa.boringPub]
*crypto/internal/boring/bcache.cacheTable[crypto/rsa.PrivateKey,crypto/rsa.boringPriv]
*crypto/internal/boring/bcache.cacheTable[crypto/rsa.PublicKey,crypto/rsa.boringPub]
*crypto/internal/boring/bcache.cacheTable[go.shape.struct { N *math/big.Int; E int },go.shape.struct { crypto/rsa.key *crypto/internal/boring.PublicKeyRS
A; crypto/rsa.orig crypto/rsa.PublicKey }]
*crypto/internal/boring/bcache.cacheTable[go.shape.struct { crypto/ecdsa.PublicKey; D *math/big.Int },go.shape.struct { crypto/ecdsa.key *crypto/internal
/boring.PrivateKeyECDSA; crypto/ecdsa.orig crypto/ecdsa.PrivateKey }]
*crypto/internal/boring/bcache.cacheTable[go.shape.struct { crypto/elliptic.Curve; X *math/big.Int; Y *math/big.Int },go.shape.struct { crypto/ecdsa.key 
*crypto/internal/boring.PublicKeyECDSA; crypto/ecdsa.orig crypto/ecdsa.PublicKey }]
*crypto/internal/boring/bcache.cacheTable[go.shape.struct { crypto/rsa.PublicKey; D *math/big.Int; Primes []*math/big.Int; Precomputed crypto/rsa.Precomp
utedValues },go.shape.struct { crypto/rsa.key *crypto/internal/boring.PrivateKeyRSA; crypto/rsa.orig crypto/rsa.PrivateKey }]
*crypto/internal/edwards25519.Point
*crypto/internal/edwards25519.Scalar
*crypto/internal/edwards25519.affineCached
*crypto/internal/edwards25519.affineLookupTable
*crypto/internal/edwards25519.fiatScalarMontgomeryDomainFieldElement
*crypto/internal/edwards25519.fiatScalarNonMontgomeryDomainFieldElement
*crypto/internal/edwards25519.nafLookupTable5
*crypto/internal/edwards25519.nafLookupTable8
*crypto/internal/edwards25519.projCached
*crypto/internal/edwards25519.projP1xP1
*crypto/internal/edwards25519.projP2
*crypto/internal/edwards25519/field.Element
*crypto/internal/nistec.P224Point
*crypto/internal/nistec.P256Point
*crypto/internal/nistec.P384Point
*crypto/internal/nistec.P521Point
*crypto/internal/nistec.p224Table
*crypto/internal/nistec.p256AffineTable
*crypto/internal/nistec.p256Element
*crypto/internal/nistec.p256OrdElement
*crypto/internal/nistec.p384Table
*crypto/internal/nistec.p521Table
*crypto/internal/nistec/fiat.P224Element
*crypto/internal/nistec/fiat.P384Element
*crypto/internal/nistec/fiat.P521Element
*crypto/internal/nistec/fiat.p224MontgomeryDomainFieldElement
*crypto/internal/nistec/fiat.p224NonMontgomeryDomainFieldElement
*crypto/internal/nistec/fiat.p384MontgomeryDomainFieldElement
*crypto/internal/nistec/fiat.p384NonMontgomeryDomainFieldElement
*crypto/internal/nistec/fiat.p521MontgomeryDomainFieldElement
*crypto/internal/nistec/fiat.p521NonMontgomeryDomainFieldElement
*crypto/md5.digest
*crypto/rand.hideAgainReader
*crypto/rand.reader
*crypto/rc4.Cipher
*crypto/rc4.KeySizeError
*crypto/rsa.CRTValue
*crypto/rsa.OAEPOptions
*crypto/rsa.PKCS1v15DecryptOptions
*crypto/rsa.PSSOptions
*crypto/rsa.PrivateKey
*crypto/rsa.PublicKey
*crypto/rsa.boringPriv
*crypto/rsa.boringPub
*crypto/sha1.digest
*crypto/sha256.digest
*crypto/sha512.digest
*crypto/tls.AlertError
*crypto/tls.Certificate
*crypto/tls.CertificateRequestInfo
*crypto/tls.CertificateVerificationError
*crypto/tls.CipherSuite
*crypto/tls.ClientAuthType
*crypto/tls.ClientHelloInfo
*crypto/tls.ClientSessionState
*crypto/tls.Config
*crypto/tls.Conn
*crypto/tls.ConnectionState
*crypto/tls.CurveID
*crypto/tls.Dialer
*crypto/tls.QUICEncryptionLevel
*crypto/tls.QUICEvent
*crypto/tls.RecordHeaderError
*crypto/tls.SessionState
*crypto/tls.SignatureScheme
*crypto/tls.activeCert
*crypto/tls.aead
*crypto/tls.alert
*crypto/tls.atLeastReader
*crypto/tls.cacheEntry
*crypto/tls.certCache
*crypto/tls.certificateMsg
*crypto/tls.certificateMsgTLS13
*crypto/tls.certificateRequestMsg
*crypto/tls.certificateRequestMsgTLS13
*crypto/tls.certificateStatusMsg
*crypto/tls.certificateVerifyMsg
*crypto/tls.cipherSuite
*crypto/tls.cipherSuiteTLS13
*crypto/tls.clientHandshakeState
*crypto/tls.clientHandshakeStateTLS13
*crypto/tls.clientHelloMsg
*crypto/tls.clientKeyExchangeMsg
*crypto/tls.cthWrapper
*crypto/tls.ecdheKeyAgreement
*crypto/tls.encryptedExtensionsMsg
*crypto/tls.endOfEarlyDataMsg
*crypto/tls.finishedHash
*crypto/tls.finishedMsg
*crypto/tls.halfConn
*crypto/tls.helloRequestMsg
*crypto/tls.keyAgreement
*crypto/tls.keyShare
*crypto/tls.keyUpdateMsg
*crypto/tls.marshalingFunction
*crypto/tls.newSessionTicketMsg
*crypto/tls.newSessionTicketMsgTLS13
*crypto/tls.permanentError
*crypto/tls.prefixNonceAEAD
*crypto/tls.pskIdentity
*crypto/tls.quicState
*crypto/tls.rsaKeyAgreement
*crypto/tls.serverHandshakeState
*crypto/tls.serverHandshakeStateTLS13
*crypto/tls.serverHelloDoneMsg
*crypto/tls.serverHelloMsg
*crypto/tls.serverKeyExchangeMsg
*crypto/tls.ticketKey
*crypto/tls.xorNonceAEAD
*crypto/x509.CertPool
*crypto/x509.Certificate
*crypto/x509.CertificateInvalidError
*crypto/x509.ConstraintViolationError
*crypto/x509.ExtKeyUsage
*crypto/x509.HostnameError
*crypto/x509.InsecureAlgorithmError
*crypto/x509.OID
*crypto/x509.PublicKeyAlgorithm
*crypto/x509.SignatureAlgorithm
*crypto/x509.SystemRootsError
*crypto/x509.UnhandledCriticalExtension
*crypto/x509.UnknownAuthorityError
*crypto/x509.VerifyOptions
*crypto/x509.ecPrivateKey
*crypto/x509.lazyCert
*crypto/x509.pkcs1AdditionalRSAPrime
*crypto/x509.pkcs1PrivateKey
*crypto/x509.pkcs1PublicKey
*crypto/x509.pkcs8
*crypto/x509.potentialParent
*crypto/x509.pssParameters
*crypto/x509.publicKeyInfo
*crypto/x509.rfc2821Mailbox
*crypto/x509/pkix.AlgorithmIdentifier
*crypto/x509/pkix.AttributeTypeAndValue
*crypto/x509/pkix.CertificateList
*crypto/x509/pkix.Extension
*crypto/x509/pkix.Name
*crypto/x509/pkix.RDNSequence
*crypto/x509/pkix.RelativeDistinguishedNameSET
*crypto/x509/pkix.RevokedCertificate
*encoding/asn1.BitString
*encoding/asn1.Enumerated
*encoding/asn1.Flag
*encoding/asn1.ObjectIdentifier
*encoding/asn1.RawValue
*encoding/asn1.StructuralError
*encoding/asn1.SyntaxError
*encoding/asn1.bitStringEncoder
*encoding/asn1.byteEncoder
*encoding/asn1.bytesEncoder
*encoding/asn1.encoder
*encoding/asn1.fieldParameters
*encoding/asn1.int64Encoder
*encoding/asn1.invalidUnmarshalError
*encoding/asn1.multiEncoder
*encoding/asn1.oidEncoder
*encoding/asn1.setEncoder
*encoding/asn1.stringEncoder
*encoding/asn1.tagAndLength
*encoding/asn1.taggedEncoder
*encoding/base64.CorruptInputError
*encoding/base64.Encoding
*encoding/binary.bigEndian
*encoding/binary.decoder
*encoding/binary.littleEndian
*encoding/gob.CommonType
*encoding/gob.Decoder
*encoding/gob.Encoder
*encoding/gob.arrayType
*encoding/gob.decBuffer
*encoding/gob.decEngine
*encoding/gob.decHelper
*encoding/gob.decInstr
*encoding/gob.decOp
*encoding/gob.decoderState
*encoding/gob.encBuffer
*encoding/gob.encEngine
*encoding/gob.encHelper
*encoding/gob.encInstr
*encoding/gob.encOp
*encoding/gob.encoderState
*encoding/gob.fieldType
*encoding/gob.gobEncoderType
*encoding/gob.gobType
*encoding/gob.mapType
*encoding/gob.sliceType
*encoding/gob.structType
*encoding/gob.typeId
*encoding/gob.typeInfo
*encoding/gob.userTypeInfo
*encoding/gob.wireType
*encoding/hex.InvalidByteError
*encoding/json.Decoder
*encoding/json.Encoder
*encoding/json.InvalidUnmarshalError
*encoding/json.MarshalerError
*encoding/json.Number
*encoding/json.RawMessage
*encoding/json.SyntaxError
*encoding/json.UnmarshalTypeError
*encoding/json.UnsupportedTypeError
*encoding/json.UnsupportedValueError
*encoding/json.decodeState
*encoding/json.encodeState
*encoding/json.encoderFunc
*encoding/json.errorContext
*encoding/json.field
*encoding/json.jsonError
*encoding/json.reflectWithString
*encoding/json.scanner
*encoding/json.structEncoder
*encoding/pem.Block
*encoding/xml.Attr
*encoding/xml.CharData
*encoding/xml.Comment
*encoding/xml.Decoder
*encoding/xml.Directive
*encoding/xml.Encoder
*encoding/xml.EndElement
*encoding/xml.Name
*encoding/xml.ProcInst
*encoding/xml.StartElement
*encoding/xml.SyntaxError
*encoding/xml.TagPathError
*encoding/xml.UnmarshalError
*encoding/xml.UnsupportedTypeError
*encoding/xml.fieldInfo
*encoding/xml.parentStack
*encoding/xml.printer
*encoding/xml.stack
*encoding/xml.typeInfo
*error
*errors.errorString
*flag.Flag
*flag.FlagSet
*flag.boolFuncValue
*flag.boolValue
*flag.durationValue
*flag.float64Value
*flag.funcValue
*flag.int64Value
*flag.intValue
*flag.stringValue
*flag.textValue
*flag.uint64Value
*flag.uintValue
*float32
*float64
*fmt.buffer
*fmt.fmt
*fmt.pp
*fmt.readRune
*fmt.ss
*fmt.ssave
*fmt.stringReader
*fmt.wrapError
*fmt.wrapErrors
*func()
*func() bool
*func() error
*func() go.shape.bool
*func() google.golang.org/protobuf/reflect/protoreflect.ProtoMessage
*func() hash.Hash
*func(*google.golang.org/grpc.csAttempt) error
*func(context.Context, string, string) (net.Conn, error)
*func(error)
*func(github.com/aws/aws-sdk-go/private/protocol.ResponseMetadata) error
*func(google.golang.org/grpc.ServiceRegistrar) (func(), error)
*func(string) func()
*func(string, *crypto/tls.Conn) net/http.RoundTripper
*func(string, string)
*func(uint32, []bool) bool
*func(uintptr) uintptr
*github.com/aws/aws-sdk-go/aws.LogLevelType
*github.com/aws/aws-sdk-go/aws/awserr.baseError
*github.com/aws/aws-sdk-go/aws/awserr.errorList
*github.com/aws/aws-sdk-go/aws/credentials.Credentials
*github.com/aws/aws-sdk-go/aws/credentials.StaticProvider
*github.com/aws/aws-sdk-go/aws/credentials.Value
*github.com/aws/aws-sdk-go/aws/endpoints.credentialScope
*github.com/aws/aws-sdk-go/aws/endpoints.endpoint
*github.com/aws/aws-sdk-go/aws/endpoints.endpointKey
*github.com/aws/aws-sdk-go/aws/endpoints.endpointVariant
*github.com/aws/aws-sdk-go/aws/endpoints.region
*github.com/aws/aws-sdk-go/aws/endpoints.service
*github.com/aws/aws-sdk-go/aws/request.NamedHandler
*github.com/aws/aws-sdk-go/aws/request.Operation
*github.com/aws/aws-sdk-go/aws/request.Paginator
*github.com/aws/aws-sdk-go/aws/request.Request
*github.com/aws/aws-sdk-go/aws/request.offsetReader
*github.com/aws/aws-sdk-go/aws/signer/v4.mapRule
*github.com/aws/aws-sdk-go/internal/ini.AST
*github.com/aws/aws-sdk-go/internal/sdkrand.lockedSource
*github.com/aws/aws-sdk-go/internal/sync/singleflight.Result
*github.com/aws/aws-sdk-go/internal/sync/singleflight.call
*github.com/aws/aws-sdk-go/private/protocol.ResponseMetadata
*github.com/aws/aws-sdk-go/service/sso.InvalidRequestException
*github.com/aws/aws-sdk-go/service/sso.ResourceNotFoundException
*github.com/aws/aws-sdk-go/service/sso.TooManyRequestsException
*github.com/aws/aws-sdk-go/service/sso.UnauthorizedException
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/common/v1.LibraryInfo
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/common/v1.LibraryInfo_Language
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/common/v1.Node
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/common/v1.ProcessIdentifier
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/common/v1.ServiceInfo
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/metrics/v1.ExportMetricsServiceRequest
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/metrics/v1.ExportMetricsServiceResponse
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/metrics/v1.metricsServiceClient
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/metrics/v1.metricsServiceExportClient
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/metrics/v1.metricsServiceExportServer
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.CurrentLibraryConfig
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.ExportTraceServiceRequest
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.ExportTraceServiceResponse
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.UpdatedLibraryConfig
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.traceServiceClient
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.traceServiceConfigClient
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.traceServiceConfigServer
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.traceServiceExportClient
*github.com/census-instrumentation/opencensus-proto/gen-go/agent/trace/v1.traceServiceExportServer
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.DistributionValue
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.DistributionValue_Bucket
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.DistributionValue_BucketOptions
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.DistributionValue_BucketOptions_Explicit
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.DistributionValue_BucketOptions_Explicit_
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.DistributionValue_Exemplar
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.LabelKey
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.LabelValue
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Metric
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.MetricDescriptor
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.MetricDescriptor_Type
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Point
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Point_DistributionValue
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Point_DoubleValue
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Point_Int64Value
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.Point_SummaryValue
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.SummaryValue
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.SummaryValue_Snapshot
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.SummaryValue_Snapshot_ValueAtPercentile
*github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1.TimeSeries
*github.com/census-instrumentation/opencensus-proto/gen-go/resource/v1.Resource
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.AttributeValue
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.AttributeValue_BoolValue
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.AttributeValue_DoubleValue
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.AttributeValue_IntValue
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.AttributeValue_StringValue
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.ConstantSampler
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.ConstantSampler_ConstantDecision
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Module
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.ProbabilitySampler
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.RateLimitingSampler
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_Attributes
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_Link
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_Link_Type
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_Links
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_SpanKind
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_TimeEvent
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_TimeEvent_Annotation
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_TimeEvent_Annotation_
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_TimeEvent_MessageEvent
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_TimeEvent_MessageEvent_
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_TimeEvent_MessageEvent_Type
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_TimeEvents
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_Tracestate
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Span_Tracestate_Entry
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.StackTrace
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.StackTrace_StackFrame
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.StackTrace_StackFrames
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.Status
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.TraceConfig
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.TraceConfig_ConstantSampler
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.TraceConfig_ProbabilitySampler
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.TraceConfig_RateLimitingSampler
*github.com/census-instrumentation/opencensus-proto/gen-go/trace/v1.TruncatableString
*github.com/cespare/xxhash/v2.sliceHeader
*github.com/cncf/xds/go/udpa/annotations.FieldMigrateAnnotation
*github.com/cncf/xds/go/udpa/annotations.FieldSecurityAnnotation
*github.com/cncf/xds/go/udpa/annotations.FileMigrateAnnotation
*github.com/cncf/xds/go/udpa/annotations.MigrateAnnotation
*github.com/cncf/xds/go/udpa/annotations.PackageVersionStatus
*github.com/cncf/xds/go/udpa/annotations.StatusAnnotation
*github.com/cncf/xds/go/udpa/annotations.VersioningAnnotation
*github.com/cncf/xds/go/udpa/type/v1.TypedStruct
*github.com/cncf/xds/go/udpa/type/v1.TypedStructValidationError
*github.com/cncf/xds/go/xds/annotations/v3.FieldMigrateAnnotation
*github.com/cncf/xds/go/xds/annotations/v3.FieldSecurityAnnotation
*github.com/cncf/xds/go/xds/annotations/v3.FieldStatusAnnotation
*github.com/cncf/xds/go/xds/annotations/v3.FileMigrateAnnotation
*github.com/cncf/xds/go/xds/annotations/v3.FileStatusAnnotation
*github.com/cncf/xds/go/xds/annotations/v3.MessageStatusAnnotation
*github.com/cncf/xds/go/xds/annotations/v3.MigrateAnnotation
*github.com/cncf/xds/go/xds/annotations/v3.PackageVersionStatus
*github.com/cncf/xds/go/xds/annotations/v3.StatusAnnotation
*github.com/cncf/xds/go/xds/annotations/v3.VersioningAnnotation
*github.com/cncf/xds/go/xds/core/v3.Authority
*github.com/cncf/xds/go/xds/core/v3.AuthorityValidationError
*github.com/cncf/xds/go/xds/core/v3.CidrRange
*github.com/cncf/xds/go/xds/core/v3.CidrRangeValidationError
*github.com/cncf/xds/go/xds/core/v3.CollectionEntry
*github.com/cncf/xds/go/xds/core/v3.CollectionEntryValidationError
*github.com/cncf/xds/go/xds/core/v3.CollectionEntry_InlineEntry
*github.com/cncf/xds/go/xds/core/v3.CollectionEntry_InlineEntryValidationError
*github.com/cncf/xds/go/xds/core/v3.CollectionEntry_InlineEntry_
*github.com/cncf/xds/go/xds/core/v3.CollectionEntry_Locator
*github.com/cncf/xds/go/xds/core/v3.ContextParams
*github.com/cncf/xds/go/xds/core/v3.Resource
*github.com/cncf/xds/go/xds/core/v3.ResourceLocator
*github.com/cncf/xds/go/xds/core/v3.ResourceLocatorValidationError
*github.com/cncf/xds/go/xds/core/v3.ResourceLocator_Directive
*github.com/cncf/xds/go/xds/core/v3.ResourceLocator_DirectiveValidationError
*github.com/cncf/xds/go/xds/core/v3.ResourceLocator_Directive_Alt
*github.com/cncf/xds/go/xds/core/v3.ResourceLocator_Directive_Entry
*github.com/cncf/xds/go/xds/core/v3.ResourceLocator_ExactContext
*github.com/cncf/xds/go/xds/core/v3.ResourceLocator_Scheme
*github.com/cncf/xds/go/xds/core/v3.ResourceName
*github.com/cncf/xds/go/xds/core/v3.ResourceNameValidationError
*github.com/cncf/xds/go/xds/core/v3.ResourceValidationError
*github.com/cncf/xds/go/xds/core/v3.TypedExtensionConfig
*github.com/cncf/xds/go/xds/core/v3.TypedExtensionConfigValidationError
*github.com/cncf/xds/go/xds/data/orca/v3.OrcaLoadReport
*github.com/cncf/xds/go/xds/data/orca/v3.OrcaLoadReportValidationError
*github.com/cncf/xds/go/xds/service/orca/v3.OrcaLoadReportRequest
*github.com/cncf/xds/go/xds/service/orca/v3.OrcaLoadReportRequestValidationError
*github.com/cncf/xds/go/xds/service/orca/v3.openRcaServiceClient
*github.com/cncf/xds/go/xds/service/orca/v3.openRcaServiceStreamCoreMetricsClient
*github.com/cncf/xds/go/xds/service/orca/v3.openRcaServiceStreamCoreMetricsServer
*github.com/cncf/xds/go/xds/type/matcher/v3.CelMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.CelMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.DoubleRangeMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.DoubleRangeMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.DoubleRangeMatcher_RangeMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.DoubleRangeMatcher_RangeMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.HttpAttributesCelMatchInput
*github.com/cncf/xds/go/xds/type/matcher/v3.IPMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.IPMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.IPMatcher_IPRangeMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.IPMatcher_IPRangeMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Int32RangeMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.Int32RangeMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Int32RangeMatcher_RangeMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.Int32RangeMatcher_RangeMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Int64RangeMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.Int64RangeMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Int64RangeMatcher_RangeMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.Int64RangeMatcher_RangeMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.ListStringMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.ListStringMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher
*github.com/cncf/xds/go/xds/type/matcher/v3.MatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherListValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_FieldMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_FieldMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_PredicateValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_AndMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_NotMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_OrMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_PredicateList
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_PredicateListValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicate
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicateValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicate_
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicate_CustomMatch
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicate_ValueMatch
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherTree
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherTreeValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherTree_
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherTree_CustomMatch
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherTree_ExactMatchMap
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherTree_MatchMap
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherTree_MatchMapValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_MatcherTree_PrefixMatchMap
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_OnMatch
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_OnMatchValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_OnMatch_Action
*github.com/cncf/xds/go/xds/type/matcher/v3.Matcher_OnMatch_Matcher
*github.com/cncf/xds/go/xds/type/matcher/v3.RegexMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.RegexMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.RegexMatcher_GoogleRE2
*github.com/cncf/xds/go/xds/type/matcher/v3.RegexMatcher_GoogleRe2
*github.com/cncf/xds/go/xds/type/matcher/v3.ServerNameMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.ServerNameMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.ServerNameMatcher_DomainMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.ServerNameMatcher_DomainMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.StringMatcher
*github.com/cncf/xds/go/xds/type/matcher/v3.StringMatcherValidationError
*github.com/cncf/xds/go/xds/type/matcher/v3.StringMatcher_Contains
*github.com/cncf/xds/go/xds/type/matcher/v3.StringMatcher_Exact
*github.com/cncf/xds/go/xds/type/matcher/v3.StringMatcher_Prefix
*github.com/cncf/xds/go/xds/type/matcher/v3.StringMatcher_SafeRegex
*github.com/cncf/xds/go/xds/type/matcher/v3.StringMatcher_Suffix
*github.com/cncf/xds/go/xds/type/v3.CelExpression
*github.com/cncf/xds/go/xds/type/v3.CelExpressionValidationError
*github.com/cncf/xds/go/xds/type/v3.CelExpression_CheckedExpr
*github.com/cncf/xds/go/xds/type/v3.CelExpression_ParsedExpr
*github.com/cncf/xds/go/xds/type/v3.CelExtractString
*github.com/cncf/xds/go/xds/type/v3.CelExtractStringValidationError
*github.com/cncf/xds/go/xds/type/v3.DoubleRange
*github.com/cncf/xds/go/xds/type/v3.Int32Range
*github.com/cncf/xds/go/xds/type/v3.Int64Range
*github.com/cncf/xds/go/xds/type/v3.TypedStruct
*github.com/cncf/xds/go/xds/type/v3.TypedStructValidationError
*github.com/cpuguy83/go-md2man/v2/md2man.roffRenderer
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.BootstrapConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.BootstrapConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.BootstrapConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.Certificate
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateDetails
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateDetailsMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateDetailsValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateDetails_OcspDetails
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateDetails_OcspDetailsMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateDetails_OcspDetailsValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificateValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.Certificates
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificatesMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CertificatesValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClientResourceStatus
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClusterStatus
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClusterStatusMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClusterStatusValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.Clusters
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump_DynamicCluster
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump_DynamicClusterMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump_DynamicClusterValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump_StaticCluster
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump_StaticClusterMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersConfigDump_StaticClusterValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ClustersValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CommandLineOptions
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CommandLineOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CommandLineOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CommandLineOptions_DrainStrategy
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CommandLineOptions_IpVersion
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.CommandLineOptions_Mode
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EcdsConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EcdsConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EcdsConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EcdsConfigDump_EcdsFilterConfig
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EcdsConfigDump_EcdsFilterConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EcdsConfigDump_EcdsFilterConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump_DynamicEndpointConfig
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump_DynamicEndpointConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump_DynamicEndpointConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump_StaticEndpointConfig
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump_StaticEndpointConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.EndpointsConfigDump_StaticEndpointConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.HostHealthStatus
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.HostStatus
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.HostStatusMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.HostStatusValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenerStatus
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenerStatusMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenerStatusValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.Listeners
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_DynamicListener
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_DynamicListenerMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_DynamicListenerState
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_DynamicListenerStateMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_DynamicListenerStateValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_DynamicListenerValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_StaticListener
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_StaticListenerMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersConfigDump_StaticListenerValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ListenersValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.Memory
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.MutexStats
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump_DynamicRouteConfig
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump_DynamicRouteConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump_DynamicRouteConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump_StaticRouteConfig
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump_StaticRouteConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.RoutesConfigDump_StaticRouteConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump_DynamicScopedRouteConfigs
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump_DynamicScopedRouteConfigsMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump_DynamicScopedRouteConfigsValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump_InlineScopedRouteConfigs
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump_InlineScopedRouteConfigsMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ScopedRoutesConfigDump_InlineScopedRouteConfigsValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDumpMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDumpValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump_DynamicSecret
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump_DynamicSecretMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump_DynamicSecretValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump_StaticSecret
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump_StaticSecretMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SecretsConfigDump_StaticSecretValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ServerInfo
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ServerInfoMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ServerInfoValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.ServerInfo_State
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SimpleMetric
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SimpleMetric_Type
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SubjectAlternateName
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SubjectAlternateNameMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SubjectAlternateNameValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SubjectAlternateName_Dns
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SubjectAlternateName_IpAddress
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.SubjectAlternateName_Uri
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.TapRequest
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.TapRequestMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.TapRequestValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.UnreadyTargetsDumps
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.UnreadyTargetsDumpsMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.UnreadyTargetsDumpsValidationError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.UnreadyTargetsDumps_UnreadyTargetsDump
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.UpdateFailureState
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.UpdateFailureStateMultiError
*github.com/envoyproxy/go-control-plane/envoy/admin/v3.UpdateFailureStateValidationError
*github.com/envoyproxy/go-control-plane/envoy/annotations.ResourceAnnotation
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLog
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_AndFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_DurationFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_ExtensionFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_GrpcStatusFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_HeaderFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_LogTypeFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_MetadataFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_NotHealthCheckFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_OrFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_ResponseFlagFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_RuntimeFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_StatusCodeFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogFilter_TraceableFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLogValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AccessLog_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AndFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AndFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.AndFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ComparisonFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ComparisonFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ComparisonFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ComparisonFilter_Op
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.DurationFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.DurationFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.DurationFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ExtensionFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ExtensionFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ExtensionFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ExtensionFilter_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.GrpcStatusFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.GrpcStatusFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.GrpcStatusFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.GrpcStatusFilter_Status
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.HeaderFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.HeaderFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.HeaderFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.LogTypeFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.LogTypeFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.LogTypeFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.MetadataFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.MetadataFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.MetadataFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.NotHealthCheckFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.OrFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.OrFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.OrFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ResponseFlagFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ResponseFlagFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.ResponseFlagFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.RuntimeFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.RuntimeFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.RuntimeFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.StatusCodeFilter
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.StatusCodeFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.StatusCodeFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3.TraceableFilter
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Admin
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.AdminMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.AdminValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.BootstrapMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.BootstrapValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_ApplicationLogConfig
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_ApplicationLogConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_ApplicationLogConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_ApplicationLogConfig_LogFormat
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_ApplicationLogConfig_LogFormatMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_ApplicationLogConfig_LogFormatValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_ApplicationLogConfig_LogFormat_JsonFormat
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_ApplicationLogConfig_LogFormat_TextFormat
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_DeferredStatOptions
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_DynamicResources
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_DynamicResourcesMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_DynamicResourcesValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_GrpcAsyncClientManagerConfig
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_GrpcAsyncClientManagerConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_GrpcAsyncClientManagerConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_StaticResources
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_StaticResourcesMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_StaticResourcesValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Bootstrap_StatsFlushOnAdmin
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.ClusterManager
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.ClusterManagerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.ClusterManagerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.ClusterManager_OutlierDetection
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.ClusterManager_OutlierDetectionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.ClusterManager_OutlierDetectionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.CustomInlineHeader
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.CustomInlineHeaderMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.CustomInlineHeaderValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.CustomInlineHeader_InlineHeaderType
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.FatalAction
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.FatalActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.FatalActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.LayeredRuntime
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.LayeredRuntimeMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.LayeredRuntimeValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Runtime
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_AdminLayer
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_AdminLayer_
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_DiskLayer
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_DiskLayer_
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_RtdsLayer
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_RtdsLayerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_RtdsLayerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_RtdsLayer_
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeLayer_StaticLayer
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.RuntimeValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Watchdog
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.WatchdogMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.WatchdogValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Watchdog_WatchdogAction
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Watchdog_WatchdogActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Watchdog_WatchdogActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Watchdog_WatchdogAction_WatchdogEvent
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.Watchdogs
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.WatchdogsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3.WatchdogsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakers
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakersMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakersValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakers_Thresholds
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakers_ThresholdsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakers_ThresholdsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakers_Thresholds_RetryBudget
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakers_Thresholds_RetryBudgetMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.CircuitBreakers_Thresholds_RetryBudgetValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.ClusterCollection
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.ClusterCollectionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.ClusterCollectionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.ClusterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.ClusterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_ClusterProtocolSelection
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_ClusterType
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_ConsistentHashingLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_ConsistentHashingLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_ConsistentHashingLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_LocalityWeightedLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_LocalityWeightedLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_ZoneAwareLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_ZoneAwareLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_ZoneAwareLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CommonLbConfig_ZoneAwareLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CustomClusterType
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CustomClusterTypeMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_CustomClusterTypeValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_DiscoveryType
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_DnsLookupFamily
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_EdsClusterConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_EdsClusterConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_EdsClusterConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfig_LbSubsetFallbackPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfig_LbSubsetSelector
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfig_LbSubsetSelectorMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfig_LbSubsetSelectorValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LeastRequestLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LeastRequestLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LeastRequestLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_LeastRequestLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_MaglevLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_MaglevLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_MaglevLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_MaglevLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_OriginalDstLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_OriginalDstLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_OriginalDstLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_OriginalDstLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_PreconnectPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_PreconnectPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_PreconnectPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RefreshRate
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RefreshRateMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RefreshRateValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RingHashLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RingHashLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RingHashLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RingHashLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RingHashLbConfig_HashFunction
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RoundRobinLbConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RoundRobinLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RoundRobinLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_RoundRobinLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_SlowStartConfig
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_SlowStartConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_SlowStartConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_TransportSocketMatch
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_TransportSocketMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_TransportSocketMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Cluster_Type
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.Filter
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.FilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.FilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.LoadBalancingPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.LoadBalancingPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.LoadBalancingPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.LoadBalancingPolicy_Policy
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.LoadBalancingPolicy_PolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.LoadBalancingPolicy_PolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.OutlierDetection
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.OutlierDetectionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.OutlierDetectionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.TrackClusterStats
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.UpstreamConnectionOptions
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.UpstreamConnectionOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3.UpstreamConnectionOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatch_GenericTextMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatch_GenericTextMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatch_GenericTextMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatch_GenericTextMatch_BinaryMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpGenericBodyMatch_GenericTextMatch_StringMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpHeadersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpHeadersMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.HttpHeadersMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicateMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicateValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_AndMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_AnyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_HttpRequestGenericBodyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_HttpRequestHeadersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_HttpRequestTrailersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_HttpResponseGenericBodyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_HttpResponseHeadersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_HttpResponseTrailersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_MatchSet
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_MatchSetMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_MatchSetValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_NotMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatchPredicate_OrMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.MatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherListMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherListValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_FieldMatcher
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_FieldMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_FieldMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_PredicateMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_PredicateValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_AndMatcher
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_NotMatcher
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_OrMatcher
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_PredicateList
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_PredicateListMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_PredicateListValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicate
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicateMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicateValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicate_
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicate_CustomMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherList_Predicate_SinglePredicate_ValueMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTree
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTreeMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTreeValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTree_
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTree_CustomMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTree_ExactMatchMap
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTree_MatchMap
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTree_MatchMapMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTree_MatchMapValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_MatcherTree_PrefixMatchMap
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_OnMatch
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_OnMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_OnMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_OnMatch_Action
*github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3.Matcher_OnMatch_Matcher
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Address
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AddressMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AddressValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Address_EnvoyInternalAddress
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Address_Pipe
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Address_SocketAddress
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AggregatedConfigSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AlternateProtocolsCacheOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AlternateProtocolsCacheOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AlternateProtocolsCacheOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AlternateProtocolsCacheOptions_AlternateProtocolsCacheEntry
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AlternateProtocolsCacheOptions_AlternateProtocolsCacheEntryMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AlternateProtocolsCacheOptions_AlternateProtocolsCacheEntryValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ApiConfigSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ApiConfigSourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ApiConfigSourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ApiConfigSource_ApiType
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ApiVersion
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AsyncDataSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AsyncDataSourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AsyncDataSourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AsyncDataSource_Local
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.AsyncDataSource_Remote
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BackoffStrategy
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BackoffStrategyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BackoffStrategyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BindConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BindConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BindConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BuildVersion
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BuildVersionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.BuildVersionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.CidrRange
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.CidrRangeMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.CidrRangeValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSource_Ads
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSource_ApiConfigSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSource_Path
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSource_PathConfigSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ConfigSource_Self
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ControlPlane
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DataSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DataSourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DataSourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DataSource_EnvironmentVariable
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DataSource_Filename
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DataSource_InlineBytes
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DataSource_InlineString
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DnsResolutionConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DnsResolutionConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DnsResolutionConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.DnsResolverOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.EnvoyInternalAddress
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.EnvoyInternalAddressMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.EnvoyInternalAddressValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.EnvoyInternalAddress_ServerListenerName
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.EventServiceConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.EventServiceConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.EventServiceConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.EventServiceConfig_GrpcService
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Extension
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtensionConfigSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtensionConfigSourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtensionConfigSourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtensionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtensionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtraSourceAddress
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtraSourceAddressMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ExtraSourceAddressValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcMethodList
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcMethodListMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcMethodListValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcMethodList_Service
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcMethodList_ServiceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcMethodList_ServiceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcProtocolOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcProtocolOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcServiceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcServiceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_EnvoyGrpc
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_EnvoyGrpcMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_EnvoyGrpcValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_EnvoyGrpc_
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpcMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpcValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentialsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentialsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_AccessToken
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_FromPlugin
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_GoogleComputeEngine
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_GoogleIAMCredentials
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_GoogleIam
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_GoogleRefreshToken
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_MetadataCredentialsFromPlugin
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_MetadataCredentialsFromPluginMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_MetadataCredentialsFromPluginValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_MetadataCredentialsFromPlugin_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_ServiceAccountJWTAccessCredentials
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_ServiceAccountJwtAccess
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_StsService
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_StsServiceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_StsServiceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_CallCredentials_StsService_
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgs
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgs_Value
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgs_ValueMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgs_ValueValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgs_Value_IntValue
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelArgs_Value_StringValue
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelCredentials
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelCredentialsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelCredentialsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelCredentials_GoogleDefault
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelCredentials_LocalCredentials
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_ChannelCredentials_SslCredentials
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_GoogleLocalCredentials
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_SslCredentials
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_SslCredentialsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.GrpcService_GoogleGrpc_SslCredentialsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderMap
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderMapMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderMapValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValue
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValueMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValueOption
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValueOptionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValueOptionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValueOption_HeaderAppendAction
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HeaderValueValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheckMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheckValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_CustomHealthCheck
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_CustomHealthCheckMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_CustomHealthCheckValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_CustomHealthCheck_
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_CustomHealthCheck_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_GrpcHealthCheck
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_GrpcHealthCheckMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_GrpcHealthCheckValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_GrpcHealthCheck_
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_HttpHealthCheck
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_HttpHealthCheckMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_HttpHealthCheckValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_HttpHealthCheck_
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_Payload
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_PayloadMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_PayloadValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_Payload_Binary
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_Payload_Text
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_RedisHealthCheck
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_TcpHealthCheck
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_TcpHealthCheckMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_TcpHealthCheckValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_TcpHealthCheck_
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthCheck_TlsOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthStatus
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthStatusSet
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthStatusSetMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HealthStatusSetValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptions_HeaderKeyFormat
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptions_HeaderKeyFormatMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptions_HeaderKeyFormatValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords_
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http1ProtocolOptions_HeaderKeyFormat_StatefulFormatter
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http2ProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http2ProtocolOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http2ProtocolOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http2ProtocolOptions_SettingsParameter
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http2ProtocolOptions_SettingsParameterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http2ProtocolOptions_SettingsParameterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http3ProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http3ProtocolOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Http3ProtocolOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpProtocolOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpProtocolOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpProtocolOptions_HeadersWithUnderscoresAction
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpService
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpServiceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpServiceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpUri
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpUriMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpUriValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.HttpUri_Cluster
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.JsonFormatOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.KeepaliveSettings
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.KeepaliveSettingsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.KeepaliveSettingsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Locality
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Metadata
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.MetadataMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.MetadataValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Node
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.NodeMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.NodeValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Node_UserAgentBuildVersion
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Node_UserAgentVersion
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.PathConfigSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.PathConfigSourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.PathConfigSourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.Pipe
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.PipeMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.PipeValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ProxyProtocolConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ProxyProtocolConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ProxyProtocolConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ProxyProtocolConfig_Version
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ProxyProtocolPassThroughTLVs
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ProxyProtocolPassThroughTLVsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ProxyProtocolPassThroughTLVsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.ProxyProtocolPassThroughTLVs_PassTLVsMatchType
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QueryParameter
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QueryParameterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QueryParameterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QuicKeepAliveSettings
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QuicKeepAliveSettingsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QuicKeepAliveSettingsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QuicProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QuicProtocolOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.QuicProtocolOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RateLimitSettings
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RateLimitSettingsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RateLimitSettingsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RemoteDataSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RemoteDataSourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RemoteDataSourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RequestMethod
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RetryPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RetryPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RetryPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RoutingPriority
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeDouble
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeDoubleMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeDoubleValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeFeatureFlag
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeFeatureFlagMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeFeatureFlagValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeFractionalPercent
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeFractionalPercentMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeFractionalPercentValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimePercent
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimePercentMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimePercentValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeUInt32
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeUInt32MultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.RuntimeUInt32ValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SchemeHeaderTransformation
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SchemeHeaderTransformationMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SchemeHeaderTransformationValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SchemeHeaderTransformation_SchemeToOverwrite
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SelfConfigSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SelfConfigSourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SelfConfigSourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketAddress
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketAddressMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketAddressValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketAddress_NamedPort
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketAddress_PortValue
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketAddress_Protocol
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOption
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOptionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOptionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOption_BufValue
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOption_IntValue
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOption_SocketState
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOptionsOverride
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOptionsOverrideMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SocketOptionsOverrideValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SubstitutionFormatString
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SubstitutionFormatStringMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SubstitutionFormatStringValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SubstitutionFormatString_JsonFormat
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SubstitutionFormatString_TextFormat
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.SubstitutionFormatString_TextFormatSource
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TcpKeepalive
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TcpKeepaliveMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TcpKeepaliveValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TcpProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TrafficDirection
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TransportSocket
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TransportSocketMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TransportSocketValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TransportSocket_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TypedExtensionConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TypedExtensionConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.TypedExtensionConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.UdpSocketConfig
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.UdpSocketConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.UdpSocketConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.UpstreamHttpProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.UpstreamHttpProtocolOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.UpstreamHttpProtocolOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.WatchedDirectory
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.WatchedDirectoryMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/core/v3.WatchedDirectoryValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignment
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignmentMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignmentValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignment_Policy
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignment_PolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignment_PolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignment_Policy_DropOverload
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignment_Policy_DropOverloadMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterLoadAssignment_Policy_DropOverloadValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterStats
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterStatsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterStatsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterStats_DroppedRequests
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterStats_DroppedRequestsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.ClusterStats_DroppedRequestsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.EndpointLoadMetricStats
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.EndpointMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.EndpointValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint_AdditionalAddress
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint_AdditionalAddressMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint_AdditionalAddressValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint_HealthCheckConfig
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint_HealthCheckConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.Endpoint_HealthCheckConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LbEndpoint
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LbEndpointMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LbEndpointValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LbEndpoint_Endpoint
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LbEndpoint_EndpointName
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LedsClusterLocalityConfig
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LedsClusterLocalityConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LedsClusterLocalityConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpoints
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpointsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpointsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpoints_LbEndpointList
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpoints_LbEndpointListMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpoints_LbEndpointListValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpoints_LedsClusterLocalityConfig
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.LocalityLbEndpoints_LoadBalancerEndpoints
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.UpstreamEndpointStats
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.UpstreamEndpointStatsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.UpstreamEndpointStatsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.UpstreamLocalityStats
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.UpstreamLocalityStatsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3.UpstreamLocalityStatsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ActiveRawUdpListenerConfig
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.AdditionalAddress
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.AdditionalAddressMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.AdditionalAddressValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ApiListener
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ApiListenerManager
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ApiListenerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ApiListenerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Filter
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChain
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChainMatch
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChainMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChainMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChainMatch_ConnectionSourceType
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChainMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChainValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChain_OnDemandConfiguration
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChain_OnDemandConfigurationMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterChain_OnDemandConfigurationValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.FilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Filter_ConfigDiscovery
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Filter_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerCollection
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerCollectionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerCollectionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilter
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicateMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicateValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate_AndMatch
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate_AnyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate_DestinationPortRange
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate_MatchSet
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate_MatchSetMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate_MatchSetValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate_NotMatch
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterChainMatchPredicate_OrMatch
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilter_ConfigDiscovery
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerFilter_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerManager
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ListenerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_ConnectionBalanceConfig
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_ConnectionBalanceConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_ConnectionBalanceConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_ConnectionBalanceConfig_ExactBalance
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_ConnectionBalanceConfig_ExactBalance_
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_ConnectionBalanceConfig_ExtendBalance
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_DeprecatedV1
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_DeprecatedV1MultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_DeprecatedV1ValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_DrainType
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_InternalListener
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.Listener_InternalListenerConfig
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.QuicProtocolOptions
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.QuicProtocolOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.QuicProtocolOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.UdpListenerConfig
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.UdpListenerConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.UdpListenerConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/listener/v3.ValidationListenerManager
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.DogStatsdSink
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.DogStatsdSinkMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.DogStatsdSinkValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.DogStatsdSink_Address
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.HistogramBucketSettings
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.HistogramBucketSettingsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.HistogramBucketSettingsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.HistogramEmitMode
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.HystrixSink
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.MetricsServiceConfig
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.MetricsServiceConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.MetricsServiceConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsConfig
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsMatcher
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsMatcher_ExclusionList
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsMatcher_InclusionList
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsMatcher_RejectAll
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsSink
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsSinkMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsSinkValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsSink_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsdSink
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsdSinkMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsdSinkValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsdSink_Address
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.StatsdSink_TcpClusterName
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.TagSpecifier
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.TagSpecifierMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.TagSpecifierValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.TagSpecifier_FixedValue
*github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3.TagSpecifier_Regex
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.BufferFactoryConfig
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.BufferFactoryConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.BufferFactoryConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.LoadShedPoint
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.LoadShedPointMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.LoadShedPointValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.OverloadAction
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.OverloadActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.OverloadActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.OverloadManager
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.OverloadManagerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.OverloadManagerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ResourceMonitor
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ResourceMonitorMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ResourceMonitorValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ResourceMonitor_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig_ScaleTimer
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig_ScaleTimerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig_ScaleTimerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig_ScaleTimer_MinScale
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig_ScaleTimer_MinTimeout
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaleTimersOverloadActionConfig_TimerType
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaledTrigger
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaledTriggerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ScaledTriggerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ThresholdTrigger
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ThresholdTriggerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.ThresholdTriggerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.Trigger
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.TriggerMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.TriggerValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.Trigger_Scaled
*github.com/envoyproxy/go-control-plane/envoy/config/overload/v3.Trigger_Threshold
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Action
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.ActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.ActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.PermissionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.PermissionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_AndRules
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_Any
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_DestinationIp
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_DestinationPort
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_DestinationPortRange
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_Header
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_Matcher
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_Metadata
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_NotRule
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_OrRules
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_RequestedServerName
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_Set
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_SetMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_SetValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Permission_UrlPath
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Policy
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.PolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.PolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.PrincipalMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.PrincipalValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_AndIds
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_Any
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_Authenticated
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_AuthenticatedMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_AuthenticatedValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_Authenticated_
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_DirectRemoteIp
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_FilterState
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_Header
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_Metadata
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_NotId
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_OrIds
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_RemoteIp
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_Set
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_SetMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_SetValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_SourceIp
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.Principal_UrlPath
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBACMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBACValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_Action
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_AuditLoggingOptions
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_AuditLoggingOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_AuditLoggingOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_AuditLoggingOptions_AuditCondition
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_AuditLoggingOptions_AuditLoggerConfig
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_AuditLoggingOptions_AuditLoggerConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3.RBAC_AuditLoggingOptions_AuditLoggerConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ClusterSpecifierPlugin
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ClusterSpecifierPluginMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ClusterSpecifierPluginValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.CorsPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.CorsPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.CorsPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.CorsPolicy_FilterEnabled
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Decorator
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.DecoratorMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.DecoratorValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.DirectResponseAction
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.DirectResponseActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.DirectResponseActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.FilterAction
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.FilterActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.FilterActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.FilterConfig
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.FilterConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.FilterConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher_ContainsMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher_ExactMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher_PrefixMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher_PresentMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher_RangeMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher_SafeRegexMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher_StringMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HeaderMatcher_SuffixMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HedgePolicy
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HedgePolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.HedgePolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.InternalRedirectPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.InternalRedirectPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.InternalRedirectPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.NonForwardingAction
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.QueryParameterMatcher
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.QueryParameterMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.QueryParameterMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.QueryParameterMatcher_PresentMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.QueryParameterMatcher_StringMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimitMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimitValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_ActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_ActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_DestinationCluster
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_DestinationCluster_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_DynamicMetaData
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_DynamicMetaDataMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_DynamicMetaDataValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_DynamicMetadata
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_Extension
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_GenericKey
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_GenericKeyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_GenericKeyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_GenericKey_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_HeaderValueMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_HeaderValueMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_HeaderValueMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_HeaderValueMatch_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_MaskedRemoteAddress
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_MaskedRemoteAddressMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_MaskedRemoteAddressValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_MaskedRemoteAddress_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_MetaData
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_MetaDataMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_MetaDataValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_MetaData_Source
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_Metadata
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_QueryParameterValueMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_QueryParameterValueMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_QueryParameterValueMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_QueryParameterValueMatch_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_RemoteAddress
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_RemoteAddress_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_RequestHeaders
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_RequestHeadersMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_RequestHeadersValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_RequestHeaders_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_SourceCluster
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Action_SourceCluster_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Override
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_OverrideMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_OverrideValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Override_DynamicMetadata
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Override_DynamicMetadataMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Override_DynamicMetadataValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RateLimit_Override_DynamicMetadata_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectAction
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectAction_HttpsRedirect
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectAction_PathRedirect
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectAction_PrefixRewrite
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectAction_RedirectResponseCode
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectAction_RegexRewrite
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RedirectAction_SchemeRedirect
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RateLimitedRetryBackOff
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RateLimitedRetryBackOffMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RateLimitedRetryBackOffValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_ResetHeader
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_ResetHeaderFormat
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_ResetHeaderMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_ResetHeaderValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryBackOff
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryBackOffMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryBackOffValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryHostPredicate
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryHostPredicateMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryHostPredicateValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryHostPredicate_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryPriority
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryPriorityMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryPriorityValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RetryPolicy_RetryPriority_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Route
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteActionMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteActionValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_AutoHostRewrite
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_Cluster
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_ClusterHeader
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_ClusterNotFoundResponseCode
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_ClusterSpecifierPlugin
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_ConnectionProperties
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_ConnectionProperties_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_Cookie
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_CookieAttribute
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_CookieAttributeMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_CookieAttributeValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_CookieMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_CookieValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_Cookie_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_FilterState
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_FilterStateMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_FilterStateValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_FilterState_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_Header
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_HeaderMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_HeaderValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_Header_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_QueryParameter
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_QueryParameterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_QueryParameterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HashPolicy_QueryParameter_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HostRewriteHeader
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HostRewriteLiteral
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_HostRewritePathRegex
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_InlineClusterSpecifierPlugin
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_InternalRedirectAction
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_MaxStreamDuration
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_MaxStreamDurationMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_MaxStreamDurationValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_RequestMirrorPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_RequestMirrorPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_RequestMirrorPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_UpgradeConfig
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_UpgradeConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_UpgradeConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_UpgradeConfig_ConnectConfig
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_UpgradeConfig_ConnectConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_UpgradeConfig_ConnectConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteAction_WeightedClusters
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteConfiguration
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteConfigurationMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteConfigurationValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteList
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteListMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteListValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_ConnectMatcher
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_ConnectMatcher_
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_GrpcRouteMatchOptions
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_Path
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_PathMatchPolicy
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_PathSeparatedPrefix
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_Prefix
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_SafeRegex
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_TlsContextMatchOptions
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_TlsContextMatchOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMatch_TlsContextMatchOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.RouteValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Route_DirectResponse
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Route_FilterAction
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Route_NonForwardingAction
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Route_Redirect
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Route_Route
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfigurationMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfigurationValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration_Key
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration_KeyMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration_KeyValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration_Key_Fragment
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration_Key_FragmentMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration_Key_FragmentValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.ScopedRouteConfiguration_Key_Fragment_StringKey
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Tracing
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.TracingMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.TracingValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.Vhds
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VhdsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VhdsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualCluster
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualClusterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualClusterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualHost
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualHostMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualHostValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.VirtualHost_TlsRequirementType
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedCluster
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedClusterMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedClusterValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedCluster_ClusterWeight
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedCluster_ClusterWeightMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedCluster_ClusterWeightValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedCluster_ClusterWeight_HostRewriteLiteral
*github.com/envoyproxy/go-control-plane/envoy/config/route/v3.WeightedCluster_HeaderName
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.BufferedAdminSink
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.BufferedAdminSinkMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.BufferedAdminSinkValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.FilePerTapSink
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.FilePerTapSinkMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.FilePerTapSinkValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatch_GenericTextMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatch_GenericTextMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatch_GenericTextMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatch_GenericTextMatch_BinaryMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpGenericBodyMatch_GenericTextMatch_StringMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpHeadersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpHeadersMatchMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.HttpHeadersMatchValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicateMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicateValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_AndMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_AnyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_HttpRequestGenericBodyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_HttpRequestHeadersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_HttpRequestTrailersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_HttpResponseGenericBodyMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_HttpResponseHeadersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_HttpResponseTrailersMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_MatchSet
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_MatchSetMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_MatchSetValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_NotMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.MatchPredicate_OrMatch
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputConfig
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSink
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSinkMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSinkValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSink_BufferedAdmin
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSink_CustomSink
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSink_FilePerTap
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSink_Format
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSink_StreamingAdmin
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.OutputSink_StreamingGrpc
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.StreamingAdminSink
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.StreamingGrpcSink
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.StreamingGrpcSinkMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.StreamingGrpcSinkValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.TapConfig
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.TapConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/tap/v3.TapConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.ClientConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.ClientConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.ClientConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.ClientConfig_BackendToken
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.DatadogConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.DatadogConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.DatadogConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.DynamicOtConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.DynamicOtConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.DynamicOtConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.LightstepConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.LightstepConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.LightstepConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.LightstepConfig_PropagationMode
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.OpenCensusConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.OpenCensusConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.OpenCensusConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.OpenCensusConfig_TraceContext
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.OpenTelemetryConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.OpenTelemetryConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.OpenTelemetryConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.SkyWalkingConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.SkyWalkingConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.SkyWalkingConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.TraceServiceConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.TraceServiceConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.TraceServiceConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.Tracing
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.TracingMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.TracingValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.Tracing_Http
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.Tracing_HttpMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.Tracing_HttpValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.Tracing_Http_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.XRayConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.XRayConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.XRayConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.XRayConfig_SegmentFields
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.XRayConfig_SegmentFieldsMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.XRayConfig_SegmentFieldsValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.ZipkinConfig
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.ZipkinConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.ZipkinConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/config/trace/v3.ZipkinConfig_CollectorEndpointVersion
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.AccessLogCommon
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.AccessLogCommonMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.AccessLogCommonValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.AccessLogType
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.ConnectionProperties
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPAccessLogEntry
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPAccessLogEntryMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPAccessLogEntryValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPAccessLogEntry_HTTPVersion
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPRequestProperties
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPRequestPropertiesMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPRequestPropertiesValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPResponseProperties
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPResponsePropertiesMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.HTTPResponsePropertiesValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.ResponseFlags
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.ResponseFlagsMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.ResponseFlagsValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.ResponseFlags_Unauthorized
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.ResponseFlags_Unauthorized_Reason
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TCPAccessLogEntry
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TCPAccessLogEntryMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TCPAccessLogEntryValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSPropertiesMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSPropertiesValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificateProperties
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificatePropertiesMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificatePropertiesValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificateProperties_SubjectAltName
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificateProperties_SubjectAltNameMultiError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificateProperties_SubjectAltNameValidationError
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificateProperties_SubjectAltName_Dns
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_CertificateProperties_SubjectAltName_Uri
*github.com/envoyproxy/go-control-plane/envoy/data/accesslog/v3.TLSProperties_TLSVersion
*github.com/envoyproxy/go-control-plane/envoy/extensions/clusters/aggregate/v3.ClusterConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/clusters/aggregate/v3.ClusterConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/clusters/aggregate/v3.ClusterConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultDelay
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultDelayMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultDelayValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultDelay_FaultDelayType
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultDelay_FixedDelay
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultDelay_HeaderDelay
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultDelay_HeaderDelay_
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimit
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimitMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimitValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimit_FixedLimit
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimit_FixedLimitMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimit_FixedLimitValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimit_FixedLimit_
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimit_HeaderLimit
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3.FaultRateLimit_HeaderLimit_
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.FaultAbort
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.FaultAbortMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.FaultAbortValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.FaultAbort_GrpcStatus
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.FaultAbort_HeaderAbort
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.FaultAbort_HeaderAbort_
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.FaultAbort_HttpStatus
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.HTTPFault
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.HTTPFaultMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3.HTTPFaultValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rbac/v3.RBAC
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rbac/v3.RBACMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rbac/v3.RBACPerRoute
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rbac/v3.RBACPerRouteMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rbac/v3.RBACPerRouteValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rbac/v3.RBACValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3.Router
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3.RouterMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3.RouterValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3.Router_UpstreamAccessLogOptions
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3.Router_UpstreamAccessLogOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3.Router_UpstreamAccessLogOptionsValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.EnvoyMobileHttpConnectionManager
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.EnvoyMobileHttpConnectionManagerMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.EnvoyMobileHttpConnectionManagerValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManagerMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManagerValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_CodecType
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_ForwardClientCertDetails
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_HcmAccessLogOptions
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_HcmAccessLogOptionsMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_HcmAccessLogOptionsValidationEr
ror
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_InternalAddressConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_InternalAddressConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_InternalAddressConfigValidation
Error
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_PathNormalizationOptions
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_PathNormalizationOptionsMultiEr
ror
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_PathNormalizationOptionsValidat
ionError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_PathWithEscapedSlashesAction
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_ProxyStatusConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_ProxyStatusConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_ProxyStatusConfigValidationErro
r
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_ProxyStatusConfig_LiteralProxyN
ame
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_ProxyStatusConfig_UseNodeId
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_Rds
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_RouteConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_ScopedRoutes
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_ServerHeaderTransformation
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_SetCurrentClientCertDetails
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_SetCurrentClientCertDetailsMult
iError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_SetCurrentClientCertDetailsVali
dationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_StripAnyHostPort
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_Tracing
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_TracingMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_TracingValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_Tracing_OperationName
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_UpgradeConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_UpgradeConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpConnectionManager_UpgradeConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpFilter
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpFilterMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpFilterValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpFilter_ConfigDiscovery
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.HttpFilter_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.LocalReplyConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.LocalReplyConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.LocalReplyConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.Rds
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.RdsMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.RdsValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.RequestIDExtension
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.RequestIDExtensionMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.RequestIDExtensionValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ResponseMapper
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ResponseMapperMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ResponseMapperValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRds
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRdsMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRdsValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRouteConfigurationsList
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRouteConfigurationsListMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRouteConfigurationsListValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutesMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutesValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilderMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilderValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilderMultiErro
r
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilderValidatio
nError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractor
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractorMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractorValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractor_
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractor_Element
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractor_Index
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractor_KvElement
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractor_KvElementMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderVa
lueExtractor_KvElementValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopedRds
*github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3.ScopedRoutes_ScopedRouteConfigurationsList
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/client_side_weighted_round_robin/v3.ClientSideWeightedRoundRobin
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/client_side_weighted_round_robin/v3.ClientSideWeightedRoundRobinMultiErr
or
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/client_side_weighted_round_robin/v3.ClientSideWeightedRoundRobinValidati
onError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.ConsistentHashingLbConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.ConsistentHashingLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.ConsistentHashingLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfig_LocalityWeightedLbConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfig_LocalityWeightedLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfig_ZoneAwareLbConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfig_ZoneAwareLbConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfig_ZoneAwareLbConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.LocalityLbConfig_ZoneAwareLbConfig_
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.SlowStartConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.SlowStartConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3.SlowStartConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/least_request/v3.LeastRequest
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/least_request/v3.LeastRequestMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/least_request/v3.LeastRequestValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/pick_first/v3.PickFirst
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/ring_hash/v3.RingHash
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/ring_hash/v3.RingHashMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/ring_hash/v3.RingHashValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/ring_hash/v3.RingHash_HashFunction
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/wrr_locality/v3.WrrLocality
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/wrr_locality/v3.WrrLocalityMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/wrr_locality/v3.WrrLocalityValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/rbac/audit_loggers/stream/v3.StdoutAuditLog
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CertificateProviderPluginInstance
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CertificateValidationContext
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CertificateValidationContextMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CertificateValidationContextValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CertificateValidationContext_TrustChainVerification
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContextMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContextValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CertificateProvider
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CertificateProviderInstance
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CertificateProviderMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CertificateProviderValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CertificateProvider_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CombinedCertificateValidationContext
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CombinedCertificateValidationContextMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CombinedCertificateValidationContextValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_CombinedValidationContext
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_ValidationContext
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_ValidationContextCertificateProvider
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_ValidationContextCertificateProviderInstance
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.CommonTlsContext_ValidationContextSdsSecretConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.DownstreamTlsContext
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.DownstreamTlsContextMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.DownstreamTlsContextValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.DownstreamTlsContext_DisableStatelessSessionResumption
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.DownstreamTlsContext_OcspStaplePolicy
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.DownstreamTlsContext_SessionTicketKeys
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.DownstreamTlsContext_SessionTicketKeysSdsSecretConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.GenericSecret
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.GenericSecretMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.GenericSecretValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.PrivateKeyProvider
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.PrivateKeyProviderMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.PrivateKeyProviderValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.PrivateKeyProvider_TypedConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SPIFFECertValidatorConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SPIFFECertValidatorConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SPIFFECertValidatorConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SPIFFECertValidatorConfig_TrustDomain
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SPIFFECertValidatorConfig_TrustDomainMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SPIFFECertValidatorConfig_TrustDomainValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SdsSecretConfig
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SdsSecretConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SdsSecretConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.Secret
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SecretMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SecretValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.Secret_GenericSecret
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.Secret_SessionTicketKeys
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.Secret_TlsCertificate
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.Secret_ValidationContext
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SubjectAltNameMatcher
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SubjectAltNameMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SubjectAltNameMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.SubjectAltNameMatcher_SanType
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsCertificate
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsCertificateMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsCertificateValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsKeyLog
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsKeyLogMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsKeyLogValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsParameters
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsParametersMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsParametersValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsParameters_TlsProtocol
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsSessionTicketKeys
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsSessionTicketKeysMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.TlsSessionTicketKeysValidationError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.UpstreamTlsContext
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.UpstreamTlsContextMultiError
*github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3.UpstreamTlsContextValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.AdsDummy
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.AggregatedDiscoveryService_StreamAggregatedResourcesClient
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DeltaDiscoveryRequest
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DeltaDiscoveryRequestMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DeltaDiscoveryRequestValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DeltaDiscoveryResponse
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DeltaDiscoveryResponseMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DeltaDiscoveryResponseValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DiscoveryRequest
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DiscoveryRequestMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DiscoveryRequestValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DiscoveryResponse
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DiscoveryResponseMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DiscoveryResponseValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraintsMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraintsValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_AndConstraints
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_Constraint
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_ConstraintList
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_ConstraintListMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_ConstraintListValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_NotConstraints
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_OrConstraints
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_SingleConstraint
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_SingleConstraintMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_SingleConstraintValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_SingleConstraint_Exists
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_SingleConstraint_Exists_
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.DynamicParameterConstraints_SingleConstraint_Value
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.Resource
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.ResourceLocator
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.ResourceMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.ResourceName
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.ResourceNameMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.ResourceNameValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.ResourceValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.Resource_CacheControl
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.aggregatedDiscoveryServiceClient
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.aggregatedDiscoveryServiceDeltaAggregatedResourcesClient
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.aggregatedDiscoveryServiceDeltaAggregatedResourcesServer
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.aggregatedDiscoveryServiceStreamAggregatedResourcesClient
*github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3.aggregatedDiscoveryServiceStreamAggregatedResourcesServer
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.LoadStatsRequest
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.LoadStatsRequestMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.LoadStatsRequestValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.LoadStatsResponse
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.LoadStatsResponseMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.LoadStatsResponseValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.loadReportingServiceClient
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.loadReportingServiceStreamLoadStatsClient
*github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3.loadReportingServiceStreamLoadStatsServer
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfig
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfigStatus
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfig_GenericXdsConfig
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfig_GenericXdsConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientConfig_GenericXdsConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientStatusRequest
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientStatusRequestMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientStatusRequestValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientStatusResponse
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientStatusResponseMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ClientStatusResponseValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.ConfigStatus
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfig
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfigMultiError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfigValidationError
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfig_ClusterConfig
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfig_EndpointConfig
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfig_ListenerConfig
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfig_RouteConfig
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.PerXdsConfig_ScopedRouteConfig
*github.com/envoyproxy/go-control-plane/envoy/service/status/v3.clientStatusDiscoveryServiceStreamClientStatusServer
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.Cookie
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.CookieMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.CookieValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformationMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformationValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation_Operation
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation_OperationMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation_OperationValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation_Operation_MergeSlashes
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation_Operation_MergeSlashes_
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation_Operation_NormalizePathRFC3986
*github.com/envoyproxy/go-control-plane/envoy/type/http/v3.PathTransformation_Operation_NormalizePathRfc_3986
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.DoubleMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.DoubleMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.DoubleMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.DoubleMatcher_Exact
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.DoubleMatcher_Range
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.FilterStateMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.FilterStateMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.FilterStateMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.FilterStateMatcher_StringMatch
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestHeaderMatchInput
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestHeaderMatchInputMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestHeaderMatchInputValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestQueryParamMatchInput
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestQueryParamMatchInputMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestQueryParamMatchInputValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestTrailerMatchInput
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestTrailerMatchInputMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpRequestTrailerMatchInputValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpResponseHeaderMatchInput
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpResponseHeaderMatchInputMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpResponseHeaderMatchInputValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpResponseStatusCodeClassMatchInput
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpResponseStatusCodeMatchInput
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpResponseTrailerMatchInput
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpResponseTrailerMatchInputMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.HttpResponseTrailerMatchInputValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ListMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ListMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ListMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ListMatcher_OneOf
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ListStringMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ListStringMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ListStringMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcher_PathSegment
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcher_PathSegmentMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcher_PathSegmentValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.MetadataMatcher_PathSegment_Key
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.NodeMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.NodeMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.NodeMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.OrMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.OrMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.OrMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.PathMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.PathMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.PathMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.PathMatcher_Path
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatchAndSubstitute
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatchAndSubstituteMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatchAndSubstituteValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatcher_GoogleRE2
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatcher_GoogleRE2MultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatcher_GoogleRE2ValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.RegexMatcher_GoogleRe2
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcher_Contains
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcher_Exact
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcher_Prefix
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcher_SafeRegex
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StringMatcher_Suffix
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcher_PathSegment
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcher_PathSegmentMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcher_PathSegmentValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.StructMatcher_PathSegment_Key
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcherMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcherValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher_BoolMatch
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher_DoubleMatch
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher_ListMatch
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher_NullMatch
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher_NullMatch_
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher_OrMatch
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher_PresentMatch
*github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3.ValueMatcher_StringMatch
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKey
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKeyMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKeyValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKey_PathSegment
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKey_PathSegmentMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKey_PathSegmentValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKey_PathSegment_Key
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKindMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKindValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind_Cluster
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind_Cluster_
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind_Host
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind_Host_
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind_Request
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind_Request_
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind_Route
*github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3.MetadataKind_Route_
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTagMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTagValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_Environment
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_EnvironmentMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_EnvironmentValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_Environment_
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_Header
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_HeaderMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_HeaderValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_Literal
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_LiteralMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_LiteralValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_Literal_
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_Metadata
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_MetadataMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_MetadataValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_Metadata_
*github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3.CustomTag_RequestHeader
*github.com/envoyproxy/go-control-plane/envoy/type/v3.CodecClientType
*github.com/envoyproxy/go-control-plane/envoy/type/v3.DoubleRange
*github.com/envoyproxy/go-control-plane/envoy/type/v3.FractionalPercent
*github.com/envoyproxy/go-control-plane/envoy/type/v3.FractionalPercentMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.FractionalPercentValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.FractionalPercent_DenominatorType
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicy
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicyMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicyValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicy_FilterState
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicy_FilterStateMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicy_FilterStateValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicy_FilterState_
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicy_SourceIp
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HashPolicy_SourceIp_
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HttpStatus
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HttpStatusMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.HttpStatusValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.Int32Range
*github.com/envoyproxy/go-control-plane/envoy/type/v3.Int64Range
*github.com/envoyproxy/go-control-plane/envoy/type/v3.Percent
*github.com/envoyproxy/go-control-plane/envoy/type/v3.PercentMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.PercentValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategy
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategyMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategyValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategy_BlanketRule
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategy_BlanketRule_
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategy_RequestsPerTimeUnit
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategy_RequestsPerTimeUnitMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategy_RequestsPerTimeUnitValidationError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategy_RequestsPerTimeUnit_
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitStrategy_TokenBucket
*github.com/envoyproxy/go-control-plane/envoy/type/v3.RateLimitUnit
*github.com/envoyproxy/go-control-plane/envoy/type/v3.SemanticVersion
*github.com/envoyproxy/go-control-plane/envoy/type/v3.StatusCode
*github.com/envoyproxy/go-control-plane/envoy/type/v3.TokenBucket
*github.com/envoyproxy/go-control-plane/envoy/type/v3.TokenBucketMultiError
*github.com/envoyproxy/go-control-plane/envoy/type/v3.TokenBucketValidationError
*github.com/envoyproxy/protoc-gen-validate/validate.AnyRules
*github.com/envoyproxy/protoc-gen-validate/validate.BoolRules
*github.com/envoyproxy/protoc-gen-validate/validate.BytesRules
*github.com/envoyproxy/protoc-gen-validate/validate.BytesRules_Ip
*github.com/envoyproxy/protoc-gen-validate/validate.BytesRules_Ipv4
*github.com/envoyproxy/protoc-gen-validate/validate.BytesRules_Ipv6
*github.com/envoyproxy/protoc-gen-validate/validate.DoubleRules
*github.com/envoyproxy/protoc-gen-validate/validate.DurationRules
*github.com/envoyproxy/protoc-gen-validate/validate.EnumRules
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Any
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Bool
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Bytes
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Double
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Duration
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Enum
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Fixed32
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Fixed64
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Float
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Int32
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Int64
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Map
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Repeated
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Sfixed32
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Sfixed64
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Sint32
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Sint64
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_String_
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Timestamp
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Uint32
*github.com/envoyproxy/protoc-gen-validate/validate.FieldRules_Uint64
*github.com/envoyproxy/protoc-gen-validate/validate.Fixed32Rules
*github.com/envoyproxy/protoc-gen-validate/validate.Fixed64Rules
*github.com/envoyproxy/protoc-gen-validate/validate.FloatRules
*github.com/envoyproxy/protoc-gen-validate/validate.Int32Rules
*github.com/envoyproxy/protoc-gen-validate/validate.Int64Rules
*github.com/envoyproxy/protoc-gen-validate/validate.KnownRegex
*github.com/envoyproxy/protoc-gen-validate/validate.MapRules
*github.com/envoyproxy/protoc-gen-validate/validate.MessageRules
*github.com/envoyproxy/protoc-gen-validate/validate.RepeatedRules
*github.com/envoyproxy/protoc-gen-validate/validate.SFixed32Rules
*github.com/envoyproxy/protoc-gen-validate/validate.SFixed64Rules
*github.com/envoyproxy/protoc-gen-validate/validate.SInt32Rules
*github.com/envoyproxy/protoc-gen-validate/validate.SInt64Rules
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_Address
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_Email
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_Hostname
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_Ip
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_Ipv4
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_Ipv6
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_Uri
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_UriRef
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_Uuid
*github.com/envoyproxy/protoc-gen-validate/validate.StringRules_WellKnownRegex
*github.com/envoyproxy/protoc-gen-validate/validate.TimestampRules
*github.com/envoyproxy/protoc-gen-validate/validate.UInt32Rules
*github.com/envoyproxy/protoc-gen-validate/validate.UInt64Rules
*github.com/go-logr/logr.Logger
*github.com/go-logr/logr/funcr.Caller
*github.com/go-logr/logr/funcr.Formatter
*github.com/go-logr/logr/funcr.Options
*github.com/go-logr/stdr.logger
*github.com/golang/groupcache/lru.Cache
*github.com/golang/groupcache/lru.entry
*github.com/golang/protobuf/proto.RequiredNotSetError
*github.com/golang/protobuf/ptypes.DynamicAny
*github.com/google/s2a-go.ClientOptions
*github.com/google/s2a-go.FallbackDialer
*github.com/google/s2a-go.FallbackOptions
*github.com/google/s2a-go.Identity
*github.com/google/s2a-go.TLSClientConfigOptions
*github.com/google/s2a-go.hostname
*github.com/google/s2a-go.s2aTLSClientConfigFactory
*github.com/google/s2a-go.s2aTransportCreds
*github.com/google/s2a-go.spiffeID
*github.com/google/s2a-go.uid
*github.com/google/s2a-go/internal/authinfo.S2AAuthInfo
*github.com/google/s2a-go/internal/handshaker.ClientHandshakerOptions
*github.com/google/s2a-go/internal/handshaker.ServerHandshakerOptions
*github.com/google/s2a-go/internal/handshaker.s2aHandshaker
*github.com/google/s2a-go/internal/proto/common_go_proto.Ciphersuite
*github.com/google/s2a-go/internal/proto/common_go_proto.Identity
*github.com/google/s2a-go/internal/proto/common_go_proto.Identity_GaiaId
*github.com/google/s2a-go/internal/proto/common_go_proto.Identity_Hostname
*github.com/google/s2a-go/internal/proto/common_go_proto.Identity_MdbUsername
*github.com/google/s2a-go/internal/proto/common_go_proto.Identity_SpiffeId
*github.com/google/s2a-go/internal/proto/common_go_proto.Identity_Uid
*github.com/google/s2a-go/internal/proto/common_go_proto.TLSVersion
*github.com/google/s2a-go/internal/proto/s2a_context_go_proto.S2AContext
*github.com/google/s2a-go/internal/proto/s2a_go_proto.AuthenticationMechanism
*github.com/google/s2a-go/internal/proto/s2a_go_proto.AuthenticationMechanism_Token
*github.com/google/s2a-go/internal/proto/s2a_go_proto.ClientSessionStartReq
*github.com/google/s2a-go/internal/proto/s2a_go_proto.ResumptionTicketReq
*github.com/google/s2a-go/internal/proto/s2a_go_proto.ServerSessionStartReq
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionNextReq
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionReq
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionReq_ClientStart
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionReq_Next
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionReq_ResumptionTicket
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionReq_ServerStart
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionResp
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionResult
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionState
*github.com/google/s2a-go/internal/proto/s2a_go_proto.SessionStatus
*github.com/google/s2a-go/internal/proto/s2a_go_proto.s2AServiceClient
*github.com/google/s2a-go/internal/proto/s2a_go_proto.s2AServiceSetUpSessionClient
*github.com/google/s2a-go/internal/proto/s2a_go_proto.s2AServiceSetUpSessionServer
*github.com/google/s2a-go/internal/proto/v2/common_go_proto.AlpnProtocol
*github.com/google/s2a-go/internal/proto/v2/common_go_proto.Ciphersuite
*github.com/google/s2a-go/internal/proto/v2/common_go_proto.ConnectionSide
*github.com/google/s2a-go/internal/proto/v2/common_go_proto.TLSVersion
*github.com/google/s2a-go/internal/proto/v2/s2a_context_go_proto.S2AContext
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.AlpnPolicy
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.AuthenticationMechanism
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.AuthenticationMechanism_Token
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.GetTlsConfigurationReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.GetTlsConfigurationResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.GetTlsConfigurationResp_ClientTlsConfiguration
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.GetTlsConfigurationResp_ClientTlsConfiguration_
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.GetTlsConfigurationResp_ServerTlsConfiguration
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.GetTlsConfigurationResp_ServerTlsConfiguration_
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.GetTlsConfigurationResp_ServerTlsConfiguration_RequestClientCertificate
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadPrivateKeyOperationReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadPrivateKeyOperationReq_PrivateKeyOperation
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadPrivateKeyOperationReq_RawBytes
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadPrivateKeyOperationReq_Sha256Digest
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadPrivateKeyOperationReq_Sha384Digest
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadPrivateKeyOperationReq_Sha512Digest
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadPrivateKeyOperationResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadResumptionKeyOperationReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadResumptionKeyOperationReq_ResumptionKeyOperation
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.OffloadResumptionKeyOperationResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionReq_GetTlsConfigurationReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionReq_OffloadPrivateKeyOperationReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionReq_OffloadResumptionKeyOperationReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionReq_ValidatePeerCertificateChainReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionResp_GetTlsConfigurationResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionResp_OffloadPrivateKeyOperationResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionResp_OffloadResumptionKeyOperationResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SessionResp_ValidatePeerCertificateChainResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.SignatureAlgorithm
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.Status
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.ValidatePeerCertificateChainReq
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.ValidatePeerCertificateChainReq_ClientPeer
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.ValidatePeerCertificateChainReq_ClientPeer_
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.ValidatePeerCertificateChainReq_ServerPeer
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.ValidatePeerCertificateChainReq_ServerPeer_
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.ValidatePeerCertificateChainReq_VerificationMode
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.ValidatePeerCertificateChainResp
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.ValidatePeerCertificateChainResp_ValidationResult
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.s2AServiceClient
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.s2AServiceSetUpSessionClient
*github.com/google/s2a-go/internal/proto/v2/s2a_go_proto.s2AServiceSetUpSessionServer
*github.com/google/s2a-go/internal/record.ConnParameters
*github.com/google/s2a-go/internal/record.conn
*github.com/google/s2a-go/internal/record.ticketSender
*github.com/google/s2a-go/internal/record/internal/aeadcrypter.aesgcm
*github.com/google/s2a-go/internal/record/internal/aeadcrypter.chachapoly
*github.com/google/s2a-go/internal/record/internal/halfconn.S2AHalfConnection
*github.com/google/s2a-go/internal/record/internal/halfconn.aesgcm128sha256
*github.com/google/s2a-go/internal/record/internal/halfconn.aesgcm256sha384
*github.com/google/s2a-go/internal/record/internal/halfconn.chachapolysha256
*github.com/google/s2a-go/internal/record/internal/halfconn.counter
*github.com/google/s2a-go/internal/record/internal/halfconn.defaultHKDFExpander
*github.com/google/s2a-go/internal/tokenmanager.AccessTokenManager
*github.com/google/s2a-go/internal/tokenmanager.singleTokenAccessTokenManager
*github.com/google/s2a-go/internal/v2.s2AGrpcStream
*github.com/google/s2a-go/internal/v2.s2av2TransportCreds
*github.com/google/s2a-go/internal/v2/remotesigner.remoteSigner
*github.com/google/s2a-go/retry.S2ARetryer
*github.com/google/s2a-go/retry.defaultBackoff
*github.com/google/s2a-go/stream.S2AStream
*github.com/google/uuid.Domain
*github.com/google/uuid.Time
*github.com/google/uuid.UUID
*github.com/google/uuid.Variant
*github.com/google/uuid.Version
*github.com/google/uuid.invalidLengthError
*github.com/googleapis/enterprise-certificate-proxy/client.Connection
*github.com/googleapis/enterprise-certificate-proxy/client.Key
*github.com/googleapis/enterprise-certificate-proxy/client/util.EnterpriseCertificateConfig
*github.com/googleapis/gax-go/v2.Backoff
*github.com/googleapis/gax-go/v2.CallOption
*github.com/googleapis/gax-go/v2.CallSettings
*github.com/googleapis/gax-go/v2.Retryer
*github.com/googleapis/gax-go/v2.boRetryer
*github.com/googleapis/gax-go/v2.contentSniffer
*github.com/googleapis/gax-go/v2.errorRetryer
*github.com/googleapis/gax-go/v2.grpcOpt
*github.com/googleapis/gax-go/v2.retryerOption
*github.com/googleapis/gax-go/v2.timeoutOpt
*github.com/googleapis/gax-go/v2/apierror.APIError
*github.com/googleapis/gax-go/v2/apierror.ErrDetails
*github.com/googleapis/gax-go/v2/apierror/internal/proto.CustomError
*github.com/googleapis/gax-go/v2/apierror/internal/proto.CustomError_CustomErrorCode
*github.com/googleapis/gax-go/v2/apierror/internal/proto.Error
*github.com/googleapis/gax-go/v2/apierror/internal/proto.Error_Status
*github.com/googlecloudplatform/gcsfuse/v2/internal/auth.proxyTokenSource
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/data.FileInfo
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/data.FileInfoKey
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/data.FileSpec
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/file.CacheHandle
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/file.CacheHandler
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/file/downloader.Job
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/file/downloader.JobManager
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/file/downloader.JobStatus
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/lru.Cache
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/lru.ValueType
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/lru.entry
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.Type
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.cacheEntry
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.entry
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.statCacheBucketView
*github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.typeCache
*github.com/googlecloudplatform/gcsfuse/v2/internal/config.FileCacheConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/config.GrpcClientConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/config.LogConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/config.LogRotateConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/config.MetadataCacheConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/config.MountConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/contentcache.CacheFileObjectMetadata
*github.com/googlecloudplatform/gcsfuse/v2/internal/contentcache.CacheObject
*github.com/googlecloudplatform/gcsfuse/v2/internal/contentcache.CacheObjectKey
*github.com/googlecloudplatform/gcsfuse/v2/internal/contentcache.ContentCache
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.ServerConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs.fileSystem
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.DirHandle
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.FileHandle
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.sortedDirents
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Core
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.DirInode
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.FileInode
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Generation
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.GenerationBackedInode
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Inode
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.SymlinkInode
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.baseDirInode
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.dirInode
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.explicitDirInode
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.lookupCount
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.errorMapping
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.monitoring
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.BucketConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.SyncerBucket
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.appendObjectCreator
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.bucketManager
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.contentTypeBucket
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.fullObjectCreator
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.prefixBucket
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.randomReader
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.syncer
*github.com/googlecloudplatform/gcsfuse/v2/internal/gcsx.tempFile
*github.com/googlecloudplatform/gcsfuse/v2/internal/locker.checker
*github.com/googlecloudplatform/gcsfuse/v2/internal/locker.debugger
*github.com/googlecloudplatform/gcsfuse/v2/internal/locker.rwChecker
*github.com/googlecloudplatform/gcsfuse/v2/internal/locker.rwDebugger
*github.com/googlecloudplatform/gcsfuse/v2/internal/logger.loggerFactory
*github.com/googlecloudplatform/gcsfuse/v2/internal/monitor.monitoringBucket
*github.com/googlecloudplatform/gcsfuse/v2/internal/monitor.monitoringReadCloser
*github.com/googlecloudplatform/gcsfuse/v2/internal/mount.ClientProtocol
*github.com/googlecloudplatform/gcsfuse/v2/internal/ratelimit.limiter
*github.com/googlecloudplatform/gcsfuse/v2/internal/ratelimit.readerCloser
*github.com/googlecloudplatform/gcsfuse/v2/internal/ratelimit.throttledBucket
*github.com/googlecloudplatform/gcsfuse/v2/internal/ratelimit.throttledReader
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage.bucketHandle
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage.debugBucket
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage.debugReader
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage.storageClient
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/caching.fastStatBucket
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/fake.bucket
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/fake.fakeObject
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/fake.fakeObjectSlice
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ByteRange
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ComposeObjectsRequest
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ComposeSource
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.CopyObjectRequest
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.CreateObjectRequest
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.DeleteObjectRequest
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ExtendedObjectAttributes
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ListObjectsRequest
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Listing
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.MinObject
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.NotFoundError
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Object
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.PreconditionError
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.Projection
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.ReadObjectRequest
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.StatObjectRequest
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/gcs.UpdateObjectRequest
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.StorageClientConfig
*github.com/googlecloudplatform/gcsfuse/v2/internal/storage/storageutil.userAgentRoundTripper
*github.com/grpc-ecosystem/grpc-gateway/v2/runtime.op
*github.com/grpc-ecosystem/grpc-gateway/v2/runtime.protoEnum
*github.com/jacobsa/daemonize.logMsg
*github.com/jacobsa/daemonize.logMsgWriter
*github.com/jacobsa/daemonize.outcomeMsg
*github.com/jacobsa/fuse.Connection
*github.com/jacobsa/fuse.MountConfig
*github.com/jacobsa/fuse.MountedFileSystem
*github.com/jacobsa/fuse.entry4
*github.com/jacobsa/fuse.initOp
*github.com/jacobsa/fuse.input1
*github.com/jacobsa/fuse.input10
*github.com/jacobsa/fuse.input11
*github.com/jacobsa/fuse.input12
*github.com/jacobsa/fuse.input13
*github.com/jacobsa/fuse.input14
*github.com/jacobsa/fuse.input15
*github.com/jacobsa/fuse.input16
*github.com/jacobsa/fuse.input17
*github.com/jacobsa/fuse.input2
*github.com/jacobsa/fuse.input3
*github.com/jacobsa/fuse.input5
*github.com/jacobsa/fuse.input6
*github.com/jacobsa/fuse.input7
*github.com/jacobsa/fuse.input8
*github.com/jacobsa/fuse.input9
*github.com/jacobsa/fuse.interruptOp
*github.com/jacobsa/fuse.opState
*github.com/jacobsa/fuse.unknownOp
*github.com/jacobsa/fuse/fuseops.BatchForgetEntry
*github.com/jacobsa/fuse/fuseops.BatchForgetOp
*github.com/jacobsa/fuse/fuseops.ChildInodeEntry
*github.com/jacobsa/fuse/fuseops.CreateFileOp
*github.com/jacobsa/fuse/fuseops.CreateLinkOp
*github.com/jacobsa/fuse/fuseops.CreateSymlinkOp
*github.com/jacobsa/fuse/fuseops.FallocateOp
*github.com/jacobsa/fuse/fuseops.FlushFileOp
*github.com/jacobsa/fuse/fuseops.ForgetInodeOp
*github.com/jacobsa/fuse/fuseops.GetInodeAttributesOp
*github.com/jacobsa/fuse/fuseops.GetXattrOp
*github.com/jacobsa/fuse/fuseops.HandleID
*github.com/jacobsa/fuse/fuseops.InodeAttributes
*github.com/jacobsa/fuse/fuseops.InodeID
*github.com/jacobsa/fuse/fuseops.ListXattrOp
*github.com/jacobsa/fuse/fuseops.LookUpInodeOp
*github.com/jacobsa/fuse/fuseops.MkDirOp
*github.com/jacobsa/fuse/fuseops.MkNodeOp
*github.com/jacobsa/fuse/fuseops.OpenDirOp
*github.com/jacobsa/fuse/fuseops.OpenFileOp
*github.com/jacobsa/fuse/fuseops.ReadDirOp
*github.com/jacobsa/fuse/fuseops.ReadFileOp
*github.com/jacobsa/fuse/fuseops.ReadSymlinkOp
*github.com/jacobsa/fuse/fuseops.ReleaseDirHandleOp
*github.com/jacobsa/fuse/fuseops.ReleaseFileHandleOp
*github.com/jacobsa/fuse/fuseops.RemoveXattrOp
*github.com/jacobsa/fuse/fuseops.RenameOp
*github.com/jacobsa/fuse/fuseops.RmDirOp
*github.com/jacobsa/fuse/fuseops.SetInodeAttributesOp
*github.com/jacobsa/fuse/fuseops.SetXattrOp
*github.com/jacobsa/fuse/fuseops.StatFSOp
*github.com/jacobsa/fuse/fuseops.SyncFileOp
*github.com/jacobsa/fuse/fuseops.UnlinkOp
*github.com/jacobsa/fuse/fuseops.WriteFileOp
*github.com/jacobsa/fuse/fuseutil.Dirent
*github.com/jacobsa/fuse/fuseutil.NotImplementedFileSystem
*github.com/jacobsa/fuse/fuseutil.fileSystemServer
*github.com/jacobsa/fuse/internal/buffer.InMessage
*github.com/jacobsa/fuse/internal/buffer.OutMessage
*github.com/jacobsa/fuse/internal/freelist.Freelist
*github.com/jacobsa/fuse/internal/fusekernel.Attr
*github.com/jacobsa/fuse/internal/fusekernel.AttrOut
*github.com/jacobsa/fuse/internal/fusekernel.CreateIn
*github.com/jacobsa/fuse/internal/fusekernel.EntryOut
*github.com/jacobsa/fuse/internal/fusekernel.GetxattrOut
*github.com/jacobsa/fuse/internal/fusekernel.InHeader
*github.com/jacobsa/fuse/internal/fusekernel.InitFlags
*github.com/jacobsa/fuse/internal/fusekernel.InitOut
*github.com/jacobsa/fuse/internal/fusekernel.MkdirIn
*github.com/jacobsa/fuse/internal/fusekernel.MknodIn
*github.com/jacobsa/fuse/internal/fusekernel.OpenFlags
*github.com/jacobsa/fuse/internal/fusekernel.OpenOut
*github.com/jacobsa/fuse/internal/fusekernel.OutHeader
*github.com/jacobsa/fuse/internal/fusekernel.Protocol
*github.com/jacobsa/fuse/internal/fusekernel.ReadIn
*github.com/jacobsa/fuse/internal/fusekernel.StatfsOut
*github.com/jacobsa/fuse/internal/fusekernel.WriteIn
*github.com/jacobsa/fuse/internal/fusekernel.WriteOut
*github.com/jacobsa/fuse/internal/fusekernel.flagName
*github.com/jacobsa/syncutil.Bundle
*github.com/jacobsa/syncutil.InvariantMutex
*github.com/jacobsa/timeutil.realClock
*github.com/russross/blackfriday/v2.CellAlignFlags
*github.com/russross/blackfriday/v2.HTMLRenderer
*github.com/russross/blackfriday/v2.HTMLRendererParameters
*github.com/russross/blackfriday/v2.HeadingData
*github.com/russross/blackfriday/v2.ListType
*github.com/russross/blackfriday/v2.Markdown
*github.com/russross/blackfriday/v2.Node
*github.com/russross/blackfriday/v2.NodeType
*github.com/russross/blackfriday/v2.Option
*github.com/russross/blackfriday/v2.Reference
*github.com/russross/blackfriday/v2.SPRenderer
*github.com/russross/blackfriday/v2.TableCellData
*github.com/russross/blackfriday/v2.WalkStatus
*github.com/russross/blackfriday/v2.nodeWalker
*github.com/russross/blackfriday/v2.reference
*github.com/urfave/cli.App
*github.com/urfave/cli.Args
*github.com/urfave/cli.Author
*github.com/urfave/cli.BoolFlag
*github.com/urfave/cli.BoolTFlag
*github.com/urfave/cli.Command
*github.com/urfave/cli.CommandCategories
*github.com/urfave/cli.CommandCategory
*github.com/urfave/cli.Context
*github.com/urfave/cli.DurationFlag
*github.com/urfave/cli.ExitError
*github.com/urfave/cli.Flag
*github.com/urfave/cli.Float64Flag
*github.com/urfave/cli.GenericFlag
*github.com/urfave/cli.Int64Slice
*github.com/urfave/cli.Int64SliceFlag
*github.com/urfave/cli.IntFlag
*github.com/urfave/cli.IntSlice
*github.com/urfave/cli.IntSliceFlag
*github.com/urfave/cli.MultiError
*github.com/urfave/cli.StringFlag
*github.com/urfave/cli.StringSlice
*github.com/urfave/cli.StringSliceFlag
*github.com/urfave/cli.cliTemplate
*github.com/urfave/cli.errRequiredFlags
*github.com/urfave/cli.fishCompletionTemplate
*go.opencensus.io/internal.BucketConfiguration
*go.opencensus.io/internal.ErrorBucketSummary
*go.opencensus.io/internal.LatencyBucketSummary
*go.opencensus.io/internal.PerMethodSummary
*go.opencensus.io/internal/tagencoding.Values
*go.opencensus.io/metric/metricdata.Bucket
*go.opencensus.io/metric/metricdata.BucketOptions
*go.opencensus.io/metric/metricdata.Descriptor
*go.opencensus.io/metric/metricdata.Distribution
*go.opencensus.io/metric/metricdata.Exemplar
*go.opencensus.io/metric/metricdata.LabelKey
*go.opencensus.io/metric/metricdata.LabelValue
*go.opencensus.io/metric/metricdata.Metric
*go.opencensus.io/metric/metricdata.Point
*go.opencensus.io/metric/metricdata.Summary
*go.opencensus.io/metric/metricdata.TimeSeries
*go.opencensus.io/metric/metricdata.Type
*go.opencensus.io/metric/metricexport.IntervalReader
*go.opencensus.io/metric/metricexport.Reader
*go.opencensus.io/metric/metricexport.ReaderOption
*go.opencensus.io/metric/metricexport.ReaderOptions
*go.opencensus.io/metric/metricproducer.Manager
*go.opencensus.io/metric/metricproducer.Producer
*go.opencensus.io/plugin/ocgrpc.ClientHandler
*go.opencensus.io/plugin/ocgrpc.rpcData
*go.opencensus.io/plugin/ochttp.Transport
*go.opencensus.io/plugin/ochttp.bodyTracker
*go.opencensus.io/plugin/ochttp.statsTransport
*go.opencensus.io/plugin/ochttp.traceTransport
*go.opencensus.io/plugin/ochttp.tracker
*go.opencensus.io/plugin/ochttp/propagation/b3.HTTPFormat
*go.opencensus.io/resource.Resource
*go.opencensus.io/stats.Float64Measure
*go.opencensus.io/stats.Int64Measure
*go.opencensus.io/stats.Measurement
*go.opencensus.io/stats.Options
*go.opencensus.io/stats.measureDescriptor
*go.opencensus.io/stats.recordOptions
*go.opencensus.io/stats/view.AggType
*go.opencensus.io/stats/view.Aggregation
*go.opencensus.io/stats/view.AggregationData
*go.opencensus.io/stats/view.CountData
*go.opencensus.io/stats/view.Data
*go.opencensus.io/stats/view.DistributionData
*go.opencensus.io/stats/view.LastValueData
*go.opencensus.io/stats/view.Row
*go.opencensus.io/stats/view.SumData
*go.opencensus.io/stats/view.View
*go.opencensus.io/stats/view.collector
*go.opencensus.io/stats/view.command
*go.opencensus.io/stats/view.getViewByNameReq
*go.opencensus.io/stats/view.getViewByNameResp
*go.opencensus.io/stats/view.measureRef
*go.opencensus.io/stats/view.recordReq
*go.opencensus.io/stats/view.registerViewReq
*go.opencensus.io/stats/view.retrieveDataReq
*go.opencensus.io/stats/view.retrieveDataResp
*go.opencensus.io/stats/view.setReportingPeriodReq
*go.opencensus.io/stats/view.unregisterFromViewReq
*go.opencensus.io/stats/view.viewInternal
*go.opencensus.io/stats/view.worker
*go.opencensus.io/tag.Key
*go.opencensus.io/tag.Map
*go.opencensus.io/tag.Metadata
*go.opencensus.io/tag.Mutator
*go.opencensus.io/tag.Tag
*go.opencensus.io/tag.encoderGRPC
*go.opencensus.io/tag.metadatas
*go.opencensus.io/tag.mutator
*go.opencensus.io/tag.tagContent
*go.opencensus.io/trace.Annotation
*go.opencensus.io/trace.Attribute
*go.opencensus.io/trace.Config
*go.opencensus.io/trace.Link
*go.opencensus.io/trace.MessageEvent
*go.opencensus.io/trace.SamplingDecision
*go.opencensus.io/trace.SamplingParameters
*go.opencensus.io/trace.Span
*go.opencensus.io/trace.SpanContext
*go.opencensus.io/trace.SpanData
*go.opencensus.io/trace.SpanID
*go.opencensus.io/trace.StartOption
*go.opencensus.io/trace.StartOptions
*go.opencensus.io/trace.Status
*go.opencensus.io/trace.TraceID
*go.opencensus.io/trace.TraceOptions
*go.opencensus.io/trace.bucket
*go.opencensus.io/trace.defaultIDGenerator
*go.opencensus.io/trace.evictedQueue
*go.opencensus.io/trace.internalOnly
*go.opencensus.io/trace.lruMap
*go.opencensus.io/trace.span
*go.opencensus.io/trace.spanStore
*go.opencensus.io/trace.tracer
*go.opencensus.io/trace/tracestate.Entry
*go.opencensus.io/trace/tracestate.Tracestate
*go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc.InterceptorInfo
*go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc.Option
*go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc.clientHandler
*go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc.config
*go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc.gRPCContext
*go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc.messageType
*go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc.metadataSupplier
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.Filter
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.Labeler
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.Option
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.Transport
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.bodyWrapper
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.config
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.optionFunc
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp.wrappedBody
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp/internal/semconvutil.httpConv
*go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp/internal/semconvutil.netConv
*go.opentelemetry.io/otel/attribute.Distinct
*go.opentelemetry.io/otel/attribute.EncoderID
*go.opentelemetry.io/otel/attribute.Iterator
*go.opentelemetry.io/otel/attribute.Key
*go.opentelemetry.io/otel/attribute.KeyValue
*go.opentelemetry.io/otel/attribute.Set
*go.opentelemetry.io/otel/attribute.Sortable
*go.opentelemetry.io/otel/attribute.Type
*go.opentelemetry.io/otel/attribute.Value
*go.opentelemetry.io/otel/codes.Code
*go.opentelemetry.io/otel/internal/global.ErrDelegator
*go.opentelemetry.io/otel/internal/global.ErrLogger
*go.opentelemetry.io/otel/internal/global.ErrorHandler
*go.opentelemetry.io/otel/internal/global.afCounter
*go.opentelemetry.io/otel/internal/global.afGauge
*go.opentelemetry.io/otel/internal/global.afUpDownCounter
*go.opentelemetry.io/otel/internal/global.aiCounter
*go.opentelemetry.io/otel/internal/global.aiGauge
*go.opentelemetry.io/otel/internal/global.aiUpDownCounter
*go.opentelemetry.io/otel/internal/global.delegatedInstrument
*go.opentelemetry.io/otel/internal/global.il
*go.opentelemetry.io/otel/internal/global.meter
*go.opentelemetry.io/otel/internal/global.meterProvider
*go.opentelemetry.io/otel/internal/global.nonRecordingSpan
*go.opentelemetry.io/otel/internal/global.registration
*go.opentelemetry.io/otel/internal/global.sfCounter
*go.opentelemetry.io/otel/internal/global.sfHistogram
*go.opentelemetry.io/otel/internal/global.sfUpDownCounter
*go.opentelemetry.io/otel/internal/global.siCounter
*go.opentelemetry.io/otel/internal/global.siHistogram
*go.opentelemetry.io/otel/internal/global.siUpDownCounter
*go.opentelemetry.io/otel/internal/global.textMapPropagator
*go.opentelemetry.io/otel/internal/global.tracer
*go.opentelemetry.io/otel/internal/global.tracerProvider
*go.opentelemetry.io/otel/metric.AddConfig
*go.opentelemetry.io/otel/metric.AddOption
*go.opentelemetry.io/otel/metric.Float64Callback
*go.opentelemetry.io/otel/metric.Float64CounterConfig
(dlv) p d.cache.(TypeCache)
Command failed: no type entry found, use 'types' for a list of valid types
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:653 (PC: 0x194727f)
   623:                 var gcsListing *gcs.Listing
   624:                 // Ask the bucket to list some objects.
   625:                 req := &gcs.ListObjectsRequest{
   626:                         Delimiter:                "/",
   627:                         IncludeTrailingDelimiter: true,
   628:                         Prefix:                   d.Name().GcsObjectName(),
   629:                         ContinuationToken:        tok,
   630:                         MaxResults:               MaxResultsForListObjectsCall,
   631:                         // Setting Projection param to noAcl since fetching owner and acls are not
   632:                         // required.
   633:                         ProjectionVal:            gcs.NoAcl,
   634:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   635:                 }
   636:
   637:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   638:                 if err != nil {
   639:                         err = fmt.Errorf("ListObjects: %w", err)
   640:                         return
   641:                 }
   642:
   643:                 PrintGcsListing(gcsListing, func(s string) {
   644:                         logger.Debugf("ListObjects: " + s)
   645:                 })
   646:
   647:                 cores = make(map[Name]*MinCoreForListing)
   648:                 defer func() {
   649:                         now := d.cacheClock.Now()
   650:                         for fullName, c := range cores {
   651:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   652:                         }
=> 653:                 }()
   654:
   655:                 listing = GcsListingToMinGcListing(gcsListing)
   656:
   657:                 d.hasObjectsListBeenRead.Store(true)
   658:         } else {
   659:                 listing = &(MinGcsListing{})
   660:
   661:                 i := 0
   662:                 index := d.cache.Index()
   663:                 for name, objtype := range index {
   664:                         logger.Debugf("Loading items from cache: #%d: name=%s objtype=%v\n", i, name, objtype)
   665:                         switch objtype {
   666:                         case metadata.NonexistentType:
   667:                                 break
   668:                         case metadata.UnknownType:
   669:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   670:                                 break
   671:                         default:
   672:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   673:                         }
   674:                         i++
   675:                 }
   676:         }
   677:
   678:         for _, o := range listing.Objects {
   679:                 // Skip empty results or the directory object backing this inode.
   680:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   681:                         continue
   682:                 }
   683:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:733 (PC: 0x1946c91)
Values returned:

   703:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   704:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   705:                         }
   706:                         cores[fileName] = file
   707:                 }
   708:         }
   709:
   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
=> 733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
   760:         }
   761:         return
   762: }
   763:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:740 (PC: 0x1947365)
Values returned:
        cores: map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
                {bucketName: "", objectName: "file1"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70000),
                        ItemType: RegularFileType (2),}, 
                {bucketName: "", objectName: "file2"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70030),
                        ItemType: RegularFileType (2),}, 
                {bucketName: "", objectName: "dir1/"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70060),
                        ItemType: ImplicitDirType (4),}, 
                {bucketName: "", objectName: "dir2/"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70090),
                        ItemType: ImplicitDirType (4),}, 
        ]
        newTok: ""
        err: error nil

   710:         // Return an appropriate continuation token, if any.
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
=> 740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
   760:         }
   761:         return
   762: }
   763:
   764: // LOCKS_REQUIRED(d)
   765: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   766:         childMetadata := map[string]string{
   767:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   768:         }
   769:         fullName := NewFileName(d.Name(), name)
   770:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:741 (PC: 0x1947427)
   711:         newTok = listing.ContinuationToken
   712:
   713:         if !d.implicitDirs {
   714:                 return
   715:         }
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
=> 741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
   746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
   760:         }
   761:         return
   762: }
   763:
   764: // LOCKS_REQUIRED(d)
   765: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   766:         childMetadata := map[string]string{
   767:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   768:         }
   769:         fullName := NewFileName(d.Name(), name)
   770:
   771:         o, err := d.createNewObject(ctx, fullName, childMetadata)
(dlv) p newTok
""
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:746 (PC: 0x1947564)
   716:
   717:         // Add implicit directories into the result.
   718:         for _, p := range listing.CollapsedRuns {
   719:                 pathBase := path.Base(p)
   720:                 dirName := NewDirName(d.Name(), pathBase)
   721:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   722:                         continue
   723:                 }
   724:
   725:                 implicitDir := &MinCoreForListing{
   726:                         // Bucket:    d.Bucket(),
   727:                         FullName: dirName,
   728:                         // MinObject: nil,
   729:                         ItemType: TypeFromMinCore(nil, false, dirName),
   730:                 }
   731:                 cores[dirName] = implicitDir
   732:         }
   733:         return
   734: }
   735:
   736: func (d *dirInode) ReadEntries(
   737:         ctx context.Context,
   738:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   739:         var cores map[Name]*MinCoreForListing
   740:         cores, newTok, err = d.readObjects(ctx, tok)
   741:         if err != nil {
   742:                 err = fmt.Errorf("read objects: %w", err)
   743:                 return
   744:         }
   745:
=> 746:         for fullName, core := range cores {
   747:                 entry := fuseutil.Dirent{
   748:                         Name: path.Base(fullName.LocalName()),
   749:                         Type: fuseutil.DT_Unknown,
   750:                 }
   751:                 switch core.Type() {
   752:                 case metadata.SymlinkType:
   753:                         entry.Type = fuseutil.DT_Link
   754:                 case metadata.RegularFileType:
   755:                         entry.Type = fuseutil.DT_File
   756:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   757:                         entry.Type = fuseutil.DT_Directory
   758:                 }
   759:                 entries = append(entries, entry)
   760:         }
   761:         return
   762: }
   763:
   764: // LOCKS_REQUIRED(d)
   765: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   766:         childMetadata := map[string]string{
   767:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   768:         }
   769:         fullName := NewFileName(d.Name(), name)
   770:
   771:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   772:         if err != nil {
   773:                 return nil, err
   774:         }
   775:         m := storageutil.ConvertObjToMinObject(o)
   776:
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
        {bucketName: "", objectName: "file1"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70000),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "file2"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70030),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "dir1/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70060),
                ItemType: ImplicitDirType (4),}, 
        {bucketName: "", objectName: "dir2/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a70090),
                ItemType: ImplicitDirType (4),}, 
]
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1      
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715316741,"nanos":992846290},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
time="10/05/2024 04:52:21.993325" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 04:52:22.321503" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715316794,"nanos":748032285},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
time="10/05/2024 04:53:14.748367" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 04:53:15.054381" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1 
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715316832,"nanos":72893466},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
time="10/05/2024 04:53:52.073183" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 04:53:52.413418" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$  fusermount -uz $mountpath ; ./creationSituation.sh 1   
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715316865,"nanos":493197888},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/config.yml]\n"}
time="10/05/2024 04:54:25.493529" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 04:54:25.789419" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$ vi creationSituation.sh 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$ export | grep 'bucket\|mountpath\|logfile' 
declare -x OLDPWD="/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/set-up-bucket"
declare -x bucket="gargnitin-empty-bucket"
declare -x gcsdirpath="gargnitin-empty-bucket/list-through-metadata-cache-expt"
declare -x logfile="/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log"
declare -x mountpath="/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount"
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$ mkdir fix-branch
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$ cd fix-branch/
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ls
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ln -sfv ../creationSituation.sh 
'./creationSituation.sh' -> '../creationSituation.sh'
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ls -l ../delve\ commands.txt     
lrwxrwxrwx 1 gargnitin primarygroup 54 May  9 08:52 '../delve commands.txt' -> '../20240429-fix-empty-dirname-issue/delve commands.txt'
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ls -l ..
total 36
-rw-r----- 1 gargnitin primarygroup  227 May  9 13:12  config.yml
-rwxr-x--- 1 gargnitin primarygroup 1457 May 10 04:56  creationSituation.sh
lrwxrwxrwx 1 gargnitin primarygroup   54 May  9 08:52 'delve commands.txt' -> '../20240429-fix-empty-dirname-issue/delve commands.txt'
drwxr-x--- 2 gargnitin primarygroup 4096 May 10 04:59  fix-branch
-rw-r----- 1 gargnitin primarygroup   21 May  9 08:47  go.mod
-rw-r----- 1 gargnitin primarygroup   97 May  9 08:53  go.work
-rw-r----- 1 gargnitin primarygroup  426 May  9 08:53  go.work.sum
-rw-r----- 1 gargnitin primarygroup  727 May  9 08:44  info.txt
drwxr-x--- 2 gargnitin primarygroup 4096 May 10 04:58  master-branch
drwxr-x--- 2 gargnitin primarygroup 4096 May  9 07:34  set-up-bucket
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ mv ../go.mod ../go.work ../go.sum ../info.txt 
mv: target '../info.txt': Not a directory
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ mv ../go.mod ../go.work ../go.sum ../info.txt  .
mv: cannot stat '../go.sum': No such file or directory
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ls                               
creationSituation.sh  go.mod  go.work  info.txt
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ mv ../go.work.sum .
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ls -ls ..
total 20
4 -rw-r----- 1 gargnitin primarygroup  227 May  9 13:12  config.yml
4 -rwxr-x--- 1 gargnitin primarygroup 1457 May 10 04:56  creationSituation.sh
0 lrwxrwxrwx 1 gargnitin primarygroup   54 May  9 08:52 'delve commands.txt' -> '../20240429-fix-empty-dirname-issue/delve commands.txt'
4 drwxr-x--- 2 gargnitin primarygroup 4096 May 10 05:02  fix-branch
4 drwxr-x--- 2 gargnitin primarygroup 4096 May 10 04:58  master-branch
4 drwxr-x--- 2 gargnitin primarygroup 4096 May  9 07:34  set-up-bucket
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ln -sfv ../config.yml .
'./config.yml' -> '../config.yml'
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ mv ../../20240429-fix-empty-dirname-issue/                    
config.yml               delve commands.txt       fs_testing_through_code/ master-branch/           tmp.txt
creationSituation.sh     fix-branch/              hello.txt                test-run.sh              
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ls -l ..                         
total 20
-rw-r----- 1 gargnitin primarygroup  227 May  9 13:12  config.yml
-rwxr-x--- 1 gargnitin primarygroup 1457 May 10 04:56  creationSituation.sh
lrwxrwxrwx 1 gargnitin primarygroup   54 May  9 08:52 'delve commands.txt' -> '../20240429-fix-empty-dirname-issue/delve commands.txt'
drwxr-x--- 2 gargnitin primarygroup 4096 May 10 05:02  fix-branch
drwxr-x--- 2 gargnitin primarygroup 4096 May 10 04:58  master-branch
drwxr-x--- 2 gargnitin primarygroup 4096 May  9 07:34  set-up-bucket
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt/fix-branch$ ..
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240905-list-thru-metadata-cache-expt$ ..
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks$ ls
202307-08-gzip-support        20240202-stat-cache-entry-size-experiment  202403-docker-failure-with-go-1.22      implit-dirs-io-error
202307-vertex_ai_job_slow     20240212-type-cache-size-effect            20240429-fix-empty-dirname-issue        oncall
20231215-low-fsync-frequency  20240306-gke-handson                       20240509-list-thru-metadata-cache-expt  playground
20240125-overlay-fs-expt      20240318-vertex-ai-experiments             2024q2-automate-perf-tests
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks$ cd 20240509-list-thru-metadata-cache-expt/fix-branch/
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715318333,"nanos":619923102},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 05:18:53.620261" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 05:18:53.923163" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ echo $?
0
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715318671,"nanos":394666717},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 05:24:31.395016" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 05:24:31.743135" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ echo $?                          
0
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
# github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode
../../../src/gcsfuse/internal/fs/inode/dir.go:28:2: "github.com/googlecloudplatform/gcsfuse/v2/internal/logger" imported and not used
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715320757,"nanos":654330129},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 05:59:17.654743" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 05:59:17.948464" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715321233,"nanos":995409558},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 06:07:13.996263" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 06:07:14.307623" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715321557,"nanos":78208125},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 06:12:37.078621" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 06:12:37.406458" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972e76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 1972e76
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:680
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:654
Breakpoint 3 set at 0x19467af for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:654
(dlv) c
{"timestamp":{"seconds":1715321842,"nanos":495692115},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(107):1 total:1) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:654 (hits goroutine(107):1 total:1) (PC: 0x19467af)
   624:         for _, obj := range listing.Objects {
   625:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   626:         }
   627:         strs = append(strs, "    ]")
   628:
   629:         strs = append(strs, "    CollapsedRuns=[")
   630:         for _, cr := range listing.CollapsedRuns {
   631:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   632:         }
   633:         strs = append(strs, "    ]")
   634:
   635:         strs = append(strs, "}")
   636:
   637:         return
   638: }
   639:
   640: // purely for debugging and logging. Remove later!
   641: func PrintMinGcsListing(listing *MinGcsListing, printFn func(string)) {
   642:         for _, str := range StrsOfMinGcsListing(listing) {
   643:                 printFn(str)
   644:         }
   645: }
   646:
   647: // LOCKS_REQUIRED(d)
   648: func (d *dirInode) readObjects(
   649:         ctx context.Context,
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
=> 654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 cores = make(map[Name]*MinCoreForListing)
   681:                 defer func() {
   682:                         now := d.cacheClock.Now()
   683:                         for fullName, c := range cores {
   684:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(108):1 total:2) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(74):1 total:3) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(152):1 total:4) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:654 (hits goroutine(152):1 total:2) (PC: 0x19467af)
   624:         for _, obj := range listing.Objects {
   625:                 strs = append(strs, fmt.Sprintf("        object=%#v", obj))
   626:         }
   627:         strs = append(strs, "    ]")
   628:
   629:         strs = append(strs, "    CollapsedRuns=[")
   630:         for _, cr := range listing.CollapsedRuns {
   631:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   632:         }
   633:         strs = append(strs, "    ]")
   634:
   635:         strs = append(strs, "}")
   636:
   637:         return
   638: }
   639:
   640: // purely for debugging and logging. Remove later!
   641: func PrintMinGcsListing(listing *MinGcsListing, printFn func(string)) {
   642:         for _, str := range StrsOfMinGcsListing(listing) {
   643:                 printFn(str)
   644:         }
   645: }
   646:
   647: // LOCKS_REQUIRED(d)
   648: func (d *dirInode) readObjects(
   649:         ctx context.Context,
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
=> 654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 cores = make(map[Name]*MinCoreForListing)
   681:                 defer func() {
   682:                         now := d.cacheClock.Now()
   683:                         for fullName, c := range cores {
   684:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697 (PC: 0x19467d9)
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 cores = make(map[Name]*MinCoreForListing)
   681:                 defer func() {
   682:                         now := d.cacheClock.Now()
   683:                         for fullName, c := range cores {
   684:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   685:                         }
   686:                 }()
   687:
   688:                 listing = GcsListingToMinGcListing(gcsListing)
   689:
   690:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   691:                 PrintMinGcsListing(listing, func(s string) {
   692:                         logger.Debugf("ListObjects: " + s)
   693:                 })
   694:
   695:                 d.hasObjectsListBeenRead.Store(true)
   696:         } else {
=> 697:                 listing = &(MinGcsListing{})
   698:
   699:                 i := 0                   // purely for debugging.. remove later!
   700:                 index := d.cache.Index() // entire map for type-cache entries
   701:                 for name, objtype := range index {
   702:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   703:                         switch objtype {
   704:                         case metadata.NonexistentType:
   705:                                 break
   706:                         case metadata.UnknownType:
   707:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   708:                                 break
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:699 (PC: 0x1946855)
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 cores = make(map[Name]*MinCoreForListing)
   681:                 defer func() {
   682:                         now := d.cacheClock.Now()
   683:                         for fullName, c := range cores {
   684:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   685:                         }
   686:                 }()
   687:
   688:                 listing = GcsListingToMinGcListing(gcsListing)
   689:
   690:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   691:                 PrintMinGcsListing(listing, func(s string) {
   692:                         logger.Debugf("ListObjects: " + s)
   693:                 })
   694:
   695:                 d.hasObjectsListBeenRead.Store(true)
   696:         } else {
   697:                 listing = &(MinGcsListing{})
   698:
=> 699:                 i := 0                   // purely for debugging.. remove later!
   700:                 index := d.cache.Index() // entire map for type-cache entries
   701:                 for name, objtype := range index {
   702:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   703:                         switch objtype {
   704:                         case metadata.NonexistentType:
   705:                                 break
   706:                         case metadata.UnknownType:
   707:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   708:                                 break
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:700 (PC: 0x194685e)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 cores = make(map[Name]*MinCoreForListing)
   681:                 defer func() {
   682:                         now := d.cacheClock.Now()
   683:                         for fullName, c := range cores {
   684:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   685:                         }
   686:                 }()
   687:
   688:                 listing = GcsListingToMinGcListing(gcsListing)
   689:
   690:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   691:                 PrintMinGcsListing(listing, func(s string) {
   692:                         logger.Debugf("ListObjects: " + s)
   693:                 })
   694:
   695:                 d.hasObjectsListBeenRead.Store(true)
   696:         } else {
   697:                 listing = &(MinGcsListing{})
   698:
   699:                 i := 0                   // purely for debugging.. remove later!
=> 700:                 index := d.cache.Index() // entire map for type-cache entries
   701:                 for name, objtype := range index {
   702:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   703:                         switch objtype {
   704:                         case metadata.NonexistentType:
   705:                                 break
   706:                         case metadata.UnknownType:
   707:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   708:                                 break
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:701 (PC: 0x1946886)
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 cores = make(map[Name]*MinCoreForListing)
   681:                 defer func() {
   682:                         now := d.cacheClock.Now()
   683:                         for fullName, c := range cores {
   684:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   685:                         }
   686:                 }()
   687:
   688:                 listing = GcsListingToMinGcListing(gcsListing)
   689:
   690:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   691:                 PrintMinGcsListing(listing, func(s string) {
   692:                         logger.Debugf("ListObjects: " + s)
   693:                 })
   694:
   695:                 d.hasObjectsListBeenRead.Store(true)
   696:         } else {
   697:                 listing = &(MinGcsListing{})
   698:
   699:                 i := 0                   // purely for debugging.. remove later!
   700:                 index := d.cache.Index() // entire map for type-cache entries
=> 701:                 for name, objtype := range index {
   702:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   703:                         switch objtype {
   704:                         case metadata.NonexistentType:
   705:                                 break
   706:                         case metadata.UnknownType:
   707:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   708:                                 break
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (PC: 0x19476fe)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 cores = make(map[Name]*MinCoreForListing)
   681:                 defer func() {
   682:                         now := d.cacheClock.Now()
   683:                         for fullName, c := range cores {
   684:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   685:                         }
   686:                 }()
   687:
   688:                 listing = GcsListingToMinGcListing(gcsListing)
   689:
   690:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   691:                 PrintMinGcsListing(listing, func(s string) {
   692:                         logger.Debugf("ListObjects: " + s)
   693:                 })
   694:
   695:                 d.hasObjectsListBeenRead.Store(true)
   696:         } else {
   697:                 listing = &(MinGcsListing{})
   698:
   699:                 i := 0                   // purely for debugging.. remove later!
   700:                 index := d.cache.Index() // entire map for type-cache entries
   701:                 for name, objtype := range index {
=> 702:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   703:                         switch objtype {
   704:                         case metadata.NonexistentType:
   705:                                 break
   706:                         case metadata.UnknownType:
   707:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   708:                                 break
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) c
Process 3250713 has exited with status 1
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:654
Breakpoint 1 set at 0x19467af for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:654
(dlv) c
{"timestamp":{"seconds":1715321897,"nanos":569100169},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:654 (hits goroutine(161):1 total:1) (PC: 0x19467af)
   649:         ctx context.Context,
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
=> 654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:655 (PC: 0x19468d4)
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
=> 655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:660 (PC: 0x19468e0)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
=> 660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (PC: 0x1946922)
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
=> 657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:658 (PC: 0x1946936)
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
=> 658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (PC: 0x1946964)
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
=> 657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:659 (PC: 0x194696e)
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
=> 659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 2 set at 0x1972e76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) bt
 0  0x000000000194696e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:659
 1  0x0000000001947d65 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776
 2  0x000000000195556b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:172
 3  0x0000000001955e53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:245
 4  0x000000000195625b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:283
 5  0x00000000019731bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2170
 6  0x0000000001959ea9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/wrappers/error_mapping.go:252
 7  0x000000000195df2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/wrappers/monitoring.go:282
 8  0x000000000193edbb in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
 9  0x000000000193dcc6 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
10  0x0000000000481d01 in runtime.goexit
    at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:659 (PC: 0x194696e)
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
=> 659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446404,0x4464e4,0x45f38e for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972e76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Command failed: could not find statement at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685, please use a line with a statement
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 2 set at 0x1946922 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
Breakpoint 3 set at 0x19476fe for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
(dlv) c
{"timestamp":{"seconds":1715322319,"nanos":579990759},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(85):1 total:1) (PC: 0x1972e76)
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(85):1 total:1) (PC: 0x1946922)
Warning: listing may not match stale executable
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
=> 657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(105):1 total:2) (PC: 0x1972e76)
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(106):1 total:3) (PC: 0x1972e76)
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(88):1 total:4) (PC: 0x1972e76)
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(88):1 total:1) (PC: 0x19476fe)
Warning: listing may not match stale executable
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:703 (PC: 0x194785b)
Warning: listing may not match stale executable
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
=> 703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
(dlv) p index
map[string]github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.Type [
        "dir2": ImplicitDirType (4), 
        "file1": RegularFileType (2), 
        "file2": RegularFileType (2), 
        "dir1": ImplicitDirType (4), 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:705 (PC: 0x1947868)
Warning: listing may not match stale executable
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
=> 705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:704 (PC: 0x1947930)
Warning: listing may not match stale executable
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
=> 704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:707 (PC: 0x1947940)
Warning: listing may not match stale executable
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
=> 707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
(dlv) p objtype
RegularFileType (2)
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:708 (PC: 0x1947944)
Warning: listing may not match stale executable
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
=> 708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:710 (PC: 0x1947a4f)
Warning: listing may not match stale executable
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
=> 710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(88):2 total:2) (PC: 0x19476fe)
Warning: listing may not match stale executable
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(88):3 total:3) (PC: 0x19476fe)
Warning: listing may not match stale executable
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(88):4 total:4) (PC: 0x19476fe)
Warning: listing may not match stale executable
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
(dlv) so
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:241 (PC: 0x195610a)
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
=> 241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:241 (PC: 0x195610a)
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
=> 241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
(dlv) n
> runtime.gopanic() /usr/lib/google-golang/src/runtime/panic.go:755 (PC: 0x4459f6)
Warning: debugging optimized function
Values returned:

   750:
   751:         runningPanicDefers.Add(1)
   752:
   753:         p.start(getcallerpc(), unsafe.Pointer(getcallersp()))
   754:         for {
=> 755:                 fn, ok := p.nextDefer()
   756:                 if !ok {
   757:                         break
   758:                 }
   759:                 fn()
   760:         }
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x446404,0x45f38e,0x4464e4 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1972e76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (4)
Breakpoint 2 (enabled) at 0x1946922 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (1)
Breakpoint 3 (enabled) at 0x19476fe for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (4)
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972e76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 1972e76
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 3 set at 0x1946922 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Breakpoint 4 set at 0x1947b18 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 5 set at 0x1946d71 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
Breakpoint 6 set at 0x194685e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 at 194685e
(dlv) c
{"timestamp":{"seconds":1715322493,"nanos":197708788},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(126):1 total:1) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(126):1 total:1) (PC: 0x1946922)
   627:         strs = append(strs, "    ]")
   628:
   629:         strs = append(strs, "    CollapsedRuns=[")
   630:         for _, cr := range listing.CollapsedRuns {
   631:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   632:         }
   633:         strs = append(strs, "    ]")
   634:
   635:         strs = append(strs, "}")
   636:
   637:         return
   638: }
   639:
   640: // purely for debugging and logging. Remove later!
   641: func PrintMinGcsListing(listing *MinGcsListing, printFn func(string)) {
   642:         for _, str := range StrsOfMinGcsListing(listing) {
   643:                 printFn(str)
   644:         }
   645: }
   646:
   647: // LOCKS_REQUIRED(d)
   648: func (d *dirInode) readObjects(
   649:         ctx context.Context,
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
=> 657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697 (hits goroutine(126):1 total:1) (PC: 0x1946d71)
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
=> 697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (hits goroutine(126):1 total:1) (PC: 0x1947b18)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:686 (PC: 0x1947bc7)
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
=> 686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (PC: 0x1947c6d)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:686 (PC: 0x1947bc7)
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
=> 686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (PC: 0x1947c6d)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:686 (PC: 0x1947bc7)
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
=> 686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (PC: 0x1947c6d)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:686 (PC: 0x1947bc7)
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
=> 686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (PC: 0x1947c6d)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:688 (PC: 0x1947c7f)
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
=> 688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:769 (PC: 0x194768a)
Values returned:

   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
=> 769:         return
   770: }
   771:
   772: func (d *dirInode) ReadEntries(
   773:         ctx context.Context,
   774:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   775:         var cores map[Name]*MinCoreForListing
   776:         cores, newTok, err = d.readObjects(ctx, tok)
   777:         if err != nil {
   778:                 err = fmt.Errorf("read objects: %w", err)
   779:                 return
   780:         }
   781:
   782:         for fullName, core := range cores {
   783:                 entry := fuseutil.Dirent{
   784:                         Name: path.Base(fullName.LocalName()),
   785:                         Type: fuseutil.DT_Unknown,
   786:                 }
   787:                 switch core.Type() {
   788:                 case metadata.SymlinkType:
   789:                         entry.Type = fuseutil.DT_Link
   790:                 case metadata.RegularFileType:
   791:                         entry.Type = fuseutil.DT_File
   792:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   793:                         entry.Type = fuseutil.DT_Directory
   794:                 }
   795:                 entries = append(entries, entry)
   796:         }
   797:         return
   798: }
   799:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776 (PC: 0x1947d65)
Values returned:
        cores: map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
                {bucketName: "", objectName: "file1"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000bc2a80),
                        ItemType: RegularFileType (2),}, 
                {bucketName: "", objectName: "file2"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000bc2ab0),
                        ItemType: RegularFileType (2),}, 
                {bucketName: "", objectName: "dir1/"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000bc2ae0),
                        ItemType: ImplicitDirType (4),}, 
                {bucketName: "", objectName: "dir2/"}: *{
                        FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000bc2b10),
                        ItemType: ImplicitDirType (4),}, 
        ]
        newTok: ""
        err: error nil

   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
   769:         return
   770: }
   771:
   772: func (d *dirInode) ReadEntries(
   773:         ctx context.Context,
   774:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   775:         var cores map[Name]*MinCoreForListing
=> 776:         cores, newTok, err = d.readObjects(ctx, tok)
   777:         if err != nil {
   778:                 err = fmt.Errorf("read objects: %w", err)
   779:                 return
   780:         }
   781:
   782:         for fullName, core := range cores {
   783:                 entry := fuseutil.Dirent{
   784:                         Name: path.Base(fullName.LocalName()),
   785:                         Type: fuseutil.DT_Unknown,
   786:                 }
   787:                 switch core.Type() {
   788:                 case metadata.SymlinkType:
   789:                         entry.Type = fuseutil.DT_Link
   790:                 case metadata.RegularFileType:
   791:                         entry.Type = fuseutil.DT_File
   792:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   793:                         entry.Type = fuseutil.DT_Directory
   794:                 }
   795:                 entries = append(entries, entry)
   796:         }
   797:         return
   798: }
   799:
   800: // LOCKS_REQUIRED(d)
   801: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   802:         childMetadata := map[string]string{
   803:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   804:         }
   805:         fullName := NewFileName(d.Name(), name)
   806:
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:777 (PC: 0x1947e27)
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
   769:         return
   770: }
   771:
   772: func (d *dirInode) ReadEntries(
   773:         ctx context.Context,
   774:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   775:         var cores map[Name]*MinCoreForListing
   776:         cores, newTok, err = d.readObjects(ctx, tok)
=> 777:         if err != nil {
   778:                 err = fmt.Errorf("read objects: %w", err)
   779:                 return
   780:         }
   781:
   782:         for fullName, core := range cores {
   783:                 entry := fuseutil.Dirent{
   784:                         Name: path.Base(fullName.LocalName()),
   785:                         Type: fuseutil.DT_Unknown,
   786:                 }
   787:                 switch core.Type() {
   788:                 case metadata.SymlinkType:
   789:                         entry.Type = fuseutil.DT_Link
   790:                 case metadata.RegularFileType:
   791:                         entry.Type = fuseutil.DT_File
   792:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   793:                         entry.Type = fuseutil.DT_Directory
   794:                 }
   795:                 entries = append(entries, entry)
   796:         }
   797:         return
   798: }
   799:
   800: // LOCKS_REQUIRED(d)
   801: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   802:         childMetadata := map[string]string{
   803:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   804:         }
   805:         fullName := NewFileName(d.Name(), name)
   806:
   807:         o, err := d.createNewObject(ctx, fullName, childMetadata)
(dlv) p tok
""
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:782 (PC: 0x1947f64)
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
   769:         return
   770: }
   771:
   772: func (d *dirInode) ReadEntries(
   773:         ctx context.Context,
   774:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   775:         var cores map[Name]*MinCoreForListing
   776:         cores, newTok, err = d.readObjects(ctx, tok)
   777:         if err != nil {
   778:                 err = fmt.Errorf("read objects: %w", err)
   779:                 return
   780:         }
   781:
=> 782:         for fullName, core := range cores {
   783:                 entry := fuseutil.Dirent{
   784:                         Name: path.Base(fullName.LocalName()),
   785:                         Type: fuseutil.DT_Unknown,
   786:                 }
   787:                 switch core.Type() {
   788:                 case metadata.SymlinkType:
   789:                         entry.Type = fuseutil.DT_Link
   790:                 case metadata.RegularFileType:
   791:                         entry.Type = fuseutil.DT_File
   792:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   793:                         entry.Type = fuseutil.DT_Directory
   794:                 }
   795:                 entries = append(entries, entry)
   796:         }
   797:         return
   798: }
   799:
   800: // LOCKS_REQUIRED(d)
   801: func (d *dirInode) CreateChildFile(ctx context.Context, name string) (*Core, error) {
   802:         childMetadata := map[string]string{
   803:                 FileMtimeMetadataKey: d.mtimeClock.Now().UTC().Format(time.RFC3339Nano),
   804:         }
   805:         fullName := NewFileName(d.Name(), name)
   806:
   807:         o, err := d.createNewObject(ctx, fullName, childMetadata)
   808:         if err != nil {
   809:                 return nil, err
   810:         }
   811:         m := storageutil.ConvertObjToMinObject(o)
   812:
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(127):1 total:2) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(128):1 total:3) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(154):1 total:4) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(154):1 total:1) (PC: 0x194685e)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:703 (PC: 0x1946886)
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
=> 703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
(dlv) p index
map[string]github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.Type [
        "dir1": ImplicitDirType (4), 
        "dir2": ImplicitDirType (4), 
        "file1": RegularFileType (2), 
        "file2": RegularFileType (2), 
]
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:704 (PC: 0x19476fe)
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
=> 704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
(dlv) b 718
Breakpoint 8 set at 0x1946e4e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (hits goroutine(154):1 total:1) (PC: 0x1946e4e)
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
=> 718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722 (PC: 0x1946f0c)
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
=> 722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:727 (PC: 0x1946f42)
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
=> 727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:737 (PC: 0x1947119)
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
=> 737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:738 (PC: 0x194717b)
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
=> 738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:740 (PC: 0x194718f)
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
=> 740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
   769:         return
   770: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:738 (PC: 0x19471ea)
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
=> 738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:742 (PC: 0x19471f4)
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
   769:         return
   770: }
   771:
   772: func (d *dirInode) ReadEntries(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:738 (PC: 0x1947206)
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
=> 738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:744 (PC: 0x1947216)
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
=> 744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
   769:         return
   770: }
   771:
   772: func (d *dirInode) ReadEntries(
   773:         ctx context.Context,
   774:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:241 (PC: 0x195610a)
   211:
   212:         // Fix up offset fields.
   213:         for i := 0; i < len(entries); i++ {
   214:                 entries[i].Offset = fuseops.DirOffset(i) + 1
   215:         }
   216:
   217:         // Return a bogus inode ID for each entry, but not the root inode ID.
   218:         //
   219:         // NOTE: As far as I can tell this is harmless. Minting and
   220:         // returning a real inode ID is difficult because fuse does not count
   221:         // readdir as an operation that increases the inode ID's lookup count, and
   222:         // we therefore don't get a forget for it later, but we would like to not
   223:         // have to remember every inode ID that we've ever minted for readdir.
   224:         //
   225:         // If it turns out this is not harmless, we'll need to switch to something
   226:         // like inode IDs based on (object name, generation) hashes. But then what
   227:         // about the birthday problem? And more importantly, what about our
   228:         // semantic of not minting a new inode ID when the generation changes due
   229:         // to a local action?
   230:         for i := range entries {
   231:                 entries[i].Inode = fuseops.RootInodeID + 1
   232:         }
   233:
   234:         return
   235: }
   236:
   237: // LOCKS_REQUIRED(dh.Mu)
   238: // LOCKS_EXCLUDED(dh.in)
   239: func (dh *DirHandle) ensureEntries(ctx context.Context, localFileEntries []fuseutil.Dirent) (err error) {
   240:         dh.in.Lock()
=> 241:         defer dh.in.Unlock()
   242:
   243:         // Read entries.
   244:         var entries []fuseutil.Dirent
   245:         entries, err = readAllEntries(ctx, dh.in, localFileEntries)
   246:         if err != nil {
   247:                 err = fmt.Errorf("readAllEntries: %w", err)
   248:                 return
   249:         }
   250:
   251:         // Update state.
   252:         dh.entries = entries
   253:         dh.entriesValid = true
   254:
   255:         return
   256: }
   257:
   258: ////////////////////////////////////////////////////////////////////////
   259: // Public interface
   260: ////////////////////////////////////////////////////////////////////////
   261:
   262: // ReadDir handles a request to read from the directory, without responding.
   263: //
   264: // Special case: we assume that a zero offset indicates that rewinddir has been
   265: // called (since fuse gives us no way to intercept and know for sure), and
   266: // start the listing process over again.
   267: //
   268: // LOCKS_REQUIRED(dh.Mu)
   269: // LOCKS_EXCLUDED(du.in)
   270: func (dh *DirHandle) ReadDir(
   271:         ctx context.Context,
(dlv) bt
 0  0x000000000195610a in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries.deferwrap1
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:241
 1  0x00000000004459f6 in runtime.gopanic
    at /usr/lib/google-golang/src/runtime/panic.go:759
 2  0x0000000000416785 in runtime.mapassign
    at /usr/lib/google-golang/src/runtime/map.go:573
 3  0x0000000001947272 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:744
 4  0x0000000001947d65 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776
 5  0x000000000195556b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.readAllEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:172
 6  0x0000000001955e53 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ensureEntries
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:245
 7  0x000000000195625b in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/handle.(*DirHandle).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/handle/dir_handle.go:283
 8  0x00000000019731bf in github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2170
 9  0x0000000001959ea9 in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*errorMapping).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/wrappers/error_mapping.go:252
10  0x000000000195df2e in github.com/googlecloudplatform/gcsfuse/v2/internal/fs/wrappers.(*monitoring).ReadDir
    at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/wrappers/monitoring.go:282
11  0x000000000193edbb in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).handleOp
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:199
12  0x000000000193dcc6 in github.com/jacobsa/fuse/fuseutil.(*fileSystemServer).ServeOps.gowrap1
    at /usr/local/google/home/gargnitin/go/pkg/mod/github.com/jacobsa/fuse@v0.0.0-20231003132804-d0f3daf365c3/fuseutil/file_system.go:123
13  0x0000000000481d01 in runtime.goexit
    at /usr/lib/google-golang/src/runtime/asm_amd64.s:1695
(dlv) c
Process 3266221 has exited with status 1
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972e76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 1972e76
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 3 set at 0x1946922 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Breakpoint 4 set at 0x1947b18 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 5 set at 0x1946d71 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
Breakpoint 6 set at 0x194685e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718
Breakpoint 7 set at 0x1946e4e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 at 1946e4e
(dlv) c
{"timestamp":{"seconds":1715322670,"nanos":745725332},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(152):1 total:1) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(152):1 total:1) (PC: 0x1946922)
   627:         strs = append(strs, "    ]")
   628:
   629:         strs = append(strs, "    CollapsedRuns=[")
   630:         for _, cr := range listing.CollapsedRuns {
   631:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   632:         }
   633:         strs = append(strs, "    ]")
   634:
   635:         strs = append(strs, "}")
   636:
   637:         return
   638: }
   639:
   640: // purely for debugging and logging. Remove later!
   641: func PrintMinGcsListing(listing *MinGcsListing, printFn func(string)) {
   642:         for _, str := range StrsOfMinGcsListing(listing) {
   643:                 printFn(str)
   644:         }
   645: }
   646:
   647: // LOCKS_REQUIRED(d)
   648: func (d *dirInode) readObjects(
   649:         ctx context.Context,
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
=> 657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697 (hits goroutine(152):1 total:1) (PC: 0x1946d71)
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
=> 697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (hits goroutine(152):1 total:1) (PC: 0x1946e4e)
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
=> 718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
(dlv) b 769
Breakpoint 9 set at 0x1947685 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:769
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (hits goroutine(152):2 total:2) (PC: 0x1946e4e)
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
=> 718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (hits goroutine(152):3 total:3) (PC: 0x1946e4e)
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
=> 718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
(dlv) b 722
Breakpoint 10 set at 0x1946f0c for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x4464e4,0x45f38e,0x446404 for (multiple functions)() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x4469a4 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1972e76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (1)
Breakpoint 3 (enabled) at 0x1946922 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (1)
Breakpoint 4 (enabled) at 0x1947b18 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (0)
Breakpoint 5 (enabled) at 0x1946d71 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697 (1)
Breakpoint 6 (enabled) at 0x194685e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (0)
Breakpoint 7 (enabled) at 0x1946e4e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (3)
Breakpoint 9 (enabled) at 0x1947685 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:769 (0)
Breakpoint 10 (enabled) at 0x1946f0c for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722 (0)
(dlv) clear 7
Breakpoint 7 cleared at 0x1946e4e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718
(dlv) l
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:718 (PC: 0x1946e4e)
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
=> 718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722 (hits goroutine(152):1 total:1) (PC: 0x1946f0c)
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
=> 722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:769 (hits goroutine(152):1 total:1) (PC: 0x1947685)
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
=> 769:         return
   770: }
   771:
   772: func (d *dirInode) ReadEntries(
   773:         ctx context.Context,
   774:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   775:         var cores map[Name]*MinCoreForListing
   776:         cores, newTok, err = d.readObjects(ctx, tok)
   777:         if err != nil {
   778:                 err = fmt.Errorf("read objects: %w", err)
   779:                 return
   780:         }
   781:
   782:         for fullName, core := range cores {
   783:                 entry := fuseutil.Dirent{
   784:                         Name: path.Base(fullName.LocalName()),
   785:                         Type: fuseutil.DT_Unknown,
   786:                 }
   787:                 switch core.Type() {
   788:                 case metadata.SymlinkType:
   789:                         entry.Type = fuseutil.DT_Link
   790:                 case metadata.RegularFileType:
   791:                         entry.Type = fuseutil.DT_File
   792:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   793:                         entry.Type = fuseutil.DT_Directory
   794:                 }
   795:                 entries = append(entries, entry)
   796:         }
   797:         return
   798: }
   799:
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
        {bucketName: "", objectName: "file1"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b6d590),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "file2"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b6d5c0),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "dir1/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b6d5f0),
                ItemType: ImplicitDirType (4),}, 
        {bucketName: "", objectName: "dir2/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000b6d620),
                ItemType: ImplicitDirType (4),}, 
]
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (hits goroutine(152):1 total:1) (PC: 0x1947b18)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(153):1 total:2) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(134):1 total:3) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(166):1 total:4) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(166):1 total:1) (PC: 0x194685e)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:703 (PC: 0x1946886)
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
=> 703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
(dlv) p index
map[string]github.com/googlecloudplatform/gcsfuse/v2/internal/cache/metadata.Type [
        "file1": RegularFileType (2), 
        "file2": RegularFileType (2), 
        "dir1": ImplicitDirType (4), 
        "dir2": ImplicitDirType (4), 
]
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722 (hits goroutine(166):1 total:2) (PC: 0x1946f0c)
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
=> 722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
(dlv) n 744
Process 3270072 has exited with status 1
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x0 for runtime.fatalsignal() <multiple locations>:0 (0)
Breakpoint unrecovered-panic (enabled) at 0x0 for runtime.fatalpanic() /usr/lib/google-golang/src/runtime/panic.go:1219 (0)
        print runtime.curg._panic.arg
Breakpoint 1 (suspended) at github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 3 (suspended) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 4 (suspended) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Breakpoint 5 (suspended) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 6 (suspended) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
Breakpoint 9 (suspended) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:769
Breakpoint 10 (suspended) at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972e76 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 1972e76
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 3 set at 0x1946922 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Breakpoint 4 set at 0x1947b18 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 5 set at 0x1946d71 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
Breakpoint 6 set at 0x194685e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722
Breakpoint 7 set at 0x1946f0c for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:769
Breakpoint 8 set at 0x1947685 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:769
(dlv) c
{"timestamp":{"seconds":1715322854,"nanos":560513489},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(150):1 total:1) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(150):1 total:1) (PC: 0x1946922)
   627:         strs = append(strs, "    ]")
   628:
   629:         strs = append(strs, "    CollapsedRuns=[")
   630:         for _, cr := range listing.CollapsedRuns {
   631:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   632:         }
   633:         strs = append(strs, "    ]")
   634:
   635:         strs = append(strs, "}")
   636:
   637:         return
   638: }
   639:
   640: // purely for debugging and logging. Remove later!
   641: func PrintMinGcsListing(listing *MinGcsListing, printFn func(string)) {
   642:         for _, str := range StrsOfMinGcsListing(listing) {
   643:                 printFn(str)
   644:         }
   645: }
   646:
   647: // LOCKS_REQUIRED(d)
   648: func (d *dirInode) readObjects(
   649:         ctx context.Context,
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
=> 657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697 (hits goroutine(150):1 total:1) (PC: 0x1946d71)
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
=> 697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722 (hits goroutine(150):1 total:1) (PC: 0x1946f0c)
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
=> 722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722 (hits goroutine(150):2 total:2) (PC: 0x1946f0c)
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
=> 722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:769 (hits goroutine(150):1 total:1) (PC: 0x1947685)
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
=> 769:         return
   770: }
   771:
   772: func (d *dirInode) ReadEntries(
   773:         ctx context.Context,
   774:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   775:         var cores map[Name]*MinCoreForListing
   776:         cores, newTok, err = d.readObjects(ctx, tok)
   777:         if err != nil {
   778:                 err = fmt.Errorf("read objects: %w", err)
   779:                 return
   780:         }
   781:
   782:         for fullName, core := range cores {
   783:                 entry := fuseutil.Dirent{
   784:                         Name: path.Base(fullName.LocalName()),
   785:                         Type: fuseutil.DT_Unknown,
   786:                 }
   787:                 switch core.Type() {
   788:                 case metadata.SymlinkType:
   789:                         entry.Type = fuseutil.DT_Link
   790:                 case metadata.RegularFileType:
   791:                         entry.Type = fuseutil.DT_File
   792:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   793:                         entry.Type = fuseutil.DT_Directory
   794:                 }
   795:                 entries = append(entries, entry)
   796:         }
   797:         return
   798: }
   799:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (hits goroutine(150):1 total:1) (PC: 0x1947b18)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(151):1 total:2) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(94):1 total:3) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(105):1 total:4) (PC: 0x1972e76)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(105):1 total:1) (PC: 0x194685e)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:722 (hits goroutine(105):1 total:3) (PC: 0x1946f0c)
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
=> 722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
(dlv) p listing
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing")(0xc000863220)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinGcsListing {
        Objects: []*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing len: 4, cap: 4, [
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000011ea8),
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000011ed8),
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000011f08),
                *(*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000011f38),
        ],
        CollapsedRuns: []string len: 0, cap: 0, nil,
        ContinuationToken: "",}
(dlv) p d.hasObjectsListBeenRead
sync/atomic.Bool {
        _: sync/atomic.noCopy {},
        v: 1,}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:727 (PC: 0x1946f42)
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
=> 727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:737 (PC: 0x1947119)
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
=> 737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:738 (PC: 0x194717b)
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
=> 738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
(dlv) p fileNae
Command failed: could not find symbol value for fileNae
(dlv) p fileName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir2"}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:740 (PC: 0x194718f)
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
   738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
=> 740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
   769:         return
   770: }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:738 (PC: 0x19471ea)
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         default:
   710:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   711:                         }
   712:                         i++
   713:                 }
   714:         }
   715:
   716:         for _, o := range listing.Objects {
   717:                 // Skip empty results or the directory object backing this inode.
   718:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   719:                         continue
   720:                 }
   721:
   722:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   723:
   724:                 // Given the alphabetical order of the objects, if a file "foo" and
   725:                 // directory "foo/" coexist, the directory would eventually occupy
   726:                 // the value of records["foo"].
   727:                 if strings.HasSuffix(o.Name, "/") {
   728:                         dirName := NewDirName(d.Name(), nameBase)
   729:                         explicitDir := &MinCoreForListing{
   730:                                 // Bucket:    d.Bucket(),
   731:                                 FullName: dirName,
   732:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   733:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   734:                         }
   735:                         cores[dirName] = explicitDir
   736:                 } else {
   737:                         fileName := NewFileName(d.Name(), nameBase)
=> 738:                         file := &MinCoreForListing{
   739:                                 // Bucket:    d.Bucket(),
   740:                                 FullName: fileName,
   741:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   742:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   743:                         }
   744:                         cores[fileName] = file
   745:                 }
   746:         }
   747:
   748:         // Return an appropriate continuation token, if any.
   749:         newTok = listing.ContinuationToken
   750:
   751:         if !d.implicitDirs {
   752:                 return
   753:         }
   754:
   755:         // Add implicit directories into the result.
   756:         for _, p := range listing.CollapsedRuns {
   757:                 pathBase := path.Base(p)
   758:                 dirName := NewDirName(d.Name(), pathBase)
   759:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   760:                         continue
   761:                 }
   762:
   763:                 implicitDir := &MinCoreForListing{
   764:                         FullName: dirName,
   765:                         ItemType: TypeFromMinCore(nil, false, dirName),
   766:                 }
   767:                 cores[dirName] = implicitDir
   768:         }
(dlv) p o
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000011ea8)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing {Name: "dir2", Type: ImplicitDirType (4)}
(dlv) p o
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000011ea8)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing {Name: "dir2", Type: ImplicitDirType (4)}
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1      
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715323607,"nanos":680894496},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 06:46:47.681372" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 06:46:47.991357" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972ef6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 1972ef6
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 3 set at 0x1946922 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Breakpoint 4 set at 0x1947b98 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 5 set at 0x1946d71 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
Breakpoint 6 set at 0x194685e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729
Breakpoint 7 set at 0x1946f0c for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776
Breakpoint 8 set at 0x1947685 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776 at 1947685
(dlv) c
{"timestamp":{"seconds":1715323672,"nanos":452034876},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(147):1 total:1) (PC: 0x1972ef6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(147):1 total:1) (PC: 0x1946922)
   627:         strs = append(strs, "    ]")
   628:
   629:         strs = append(strs, "    CollapsedRuns=[")
   630:         for _, cr := range listing.CollapsedRuns {
   631:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   632:         }
   633:         strs = append(strs, "    ]")
   634:
   635:         strs = append(strs, "}")
   636:
   637:         return
   638: }
   639:
   640: // purely for debugging and logging. Remove later!
   641: func PrintMinGcsListing(listing *MinGcsListing, printFn func(string)) {
   642:         for _, str := range StrsOfMinGcsListing(listing) {
   643:                 printFn(str)
   644:         }
   645: }
   646:
   647: // LOCKS_REQUIRED(d)
   648: func (d *dirInode) readObjects(
   649:         ctx context.Context,
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
=> 657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697 (hits goroutine(147):1 total:1) (PC: 0x1946d71)
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
=> 697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (hits goroutine(147):1 total:1) (PC: 0x1946f0c)
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
=> 729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (hits goroutine(147):2 total:2) (PC: 0x1946f0c)
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
=> 729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776 (hits goroutine(147):1 total:1) (PC: 0x1947685)
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
   766:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   767:                         continue
   768:                 }
   769:
   770:                 implicitDir := &MinCoreForListing{
   771:                         FullName: dirName,
   772:                         ItemType: TypeFromMinCore(nil, false, dirName),
   773:                 }
   774:                 cores[dirName] = implicitDir
   775:         }
=> 776:         return
   777: }
   778:
   779: func (d *dirInode) ReadEntries(
   780:         ctx context.Context,
   781:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   782:         var cores map[Name]*MinCoreForListing
   783:         cores, newTok, err = d.readObjects(ctx, tok)
   784:         if err != nil {
   785:                 err = fmt.Errorf("read objects: %w", err)
   786:                 return
   787:         }
   788:
   789:         for fullName, core := range cores {
   790:                 entry := fuseutil.Dirent{
   791:                         Name: path.Base(fullName.LocalName()),
   792:                         Type: fuseutil.DT_Unknown,
   793:                 }
   794:                 switch core.Type() {
   795:                 case metadata.SymlinkType:
   796:                         entry.Type = fuseutil.DT_Link
   797:                 case metadata.RegularFileType:
   798:                         entry.Type = fuseutil.DT_File
   799:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   800:                         entry.Type = fuseutil.DT_Directory
   801:                 }
   802:                 entries = append(entries, entry)
   803:         }
   804:         return
   805: }
   806:
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
        {bucketName: "", objectName: "file1"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a10db0),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "file2"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a10de0),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "dir1/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a10e10),
                ItemType: ImplicitDirType (4),}, 
        {bucketName: "", objectName: "dir2/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc000a10e40),
                ItemType: ImplicitDirType (4),}, 
]
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (hits goroutine(147):1 total:1) (PC: 0x1947b98)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(183):1 total:2) (PC: 0x1972ef6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(148):1 total:3) (PC: 0x1972ef6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(120):1 total:4) (PC: 0x1972ef6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(120):1 total:1) (PC: 0x194685e)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (hits goroutine(120):1 total:3) (PC: 0x1946f0c)
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
=> 729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
(dlv) c
Process 3305369 has exited with status 1
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) # general config
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) config source-list-line-count 30
(dlv) config max-string-len 128
(dlv) 
(dlv) #bucketHandle.ListObjects():
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:261
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:272
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #Return
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/storage/bucket_handle.go:309
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #fs operations from kernel
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).LookUpInode
Command failed: command not available
(dlv) b github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir
Breakpoint 1 set at 0x1972ef6 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 at 1972ef6
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).ReadEntries
Command failed: command not available
(dlv) #b github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:577
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:651
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:663
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Command failed: command not available
(dlv) #b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:706
Command failed: command not available
(dlv) 
Command failed: command not available
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
Breakpoint 3 set at 0x1946922 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
Breakpoint 4 set at 0x1947b98 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
Breakpoint 5 set at 0x1946d71 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
Breakpoint 6 set at 0x194685e for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729
Breakpoint 7 set at 0x1946f0c for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729
(dlv) b /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776
Breakpoint 8 set at 0x1947685 for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776
(dlv) 
Command failed: Breakpoint exists at /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776 at 1947685
(dlv) c
{"timestamp":{"seconds":1715323749,"nanos":374382379},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(80):1 total:1) (PC: 0x1972ef6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:657 (hits goroutine(80):1 total:1) (PC: 0x1946922)
   627:         strs = append(strs, "    ]")
   628:
   629:         strs = append(strs, "    CollapsedRuns=[")
   630:         for _, cr := range listing.CollapsedRuns {
   631:                 strs = append(strs, fmt.Sprintf("        %#v", cr))
   632:         }
   633:         strs = append(strs, "    ]")
   634:
   635:         strs = append(strs, "}")
   636:
   637:         return
   638: }
   639:
   640: // purely for debugging and logging. Remove later!
   641: func PrintMinGcsListing(listing *MinGcsListing, printFn func(string)) {
   642:         for _, str := range StrsOfMinGcsListing(listing) {
   643:                 printFn(str)
   644:         }
   645: }
   646:
   647: // LOCKS_REQUIRED(d)
   648: func (d *dirInode) readObjects(
   649:         ctx context.Context,
   650:         tok string) (cores map[Name]*MinCoreForListing, newTok string, err error) {
   651:
   652:         var listing *MinGcsListing
   653:
   654:         if !d.hasObjectsListBeenRead.Load() {
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
=> 657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:697 (hits goroutine(80):1 total:1) (PC: 0x1946d71)
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
=> 697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (hits goroutine(80):1 total:1) (PC: 0x1946f0c)
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
=> 729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (hits goroutine(80):2 total:2) (PC: 0x1946f0c)
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
=> 729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:776 (hits goroutine(80):1 total:1) (PC: 0x1947685)
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
   766:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   767:                         continue
   768:                 }
   769:
   770:                 implicitDir := &MinCoreForListing{
   771:                         FullName: dirName,
   772:                         ItemType: TypeFromMinCore(nil, false, dirName),
   773:                 }
   774:                 cores[dirName] = implicitDir
   775:         }
=> 776:         return
   777: }
   778:
   779: func (d *dirInode) ReadEntries(
   780:         ctx context.Context,
   781:         tok string) (entries []fuseutil.Dirent, newTok string, err error) {
   782:         var cores map[Name]*MinCoreForListing
   783:         cores, newTok, err = d.readObjects(ctx, tok)
   784:         if err != nil {
   785:                 err = fmt.Errorf("read objects: %w", err)
   786:                 return
   787:         }
   788:
   789:         for fullName, core := range cores {
   790:                 entry := fuseutil.Dirent{
   791:                         Name: path.Base(fullName.LocalName()),
   792:                         Type: fuseutil.DT_Unknown,
   793:                 }
   794:                 switch core.Type() {
   795:                 case metadata.SymlinkType:
   796:                         entry.Type = fuseutil.DT_Link
   797:                 case metadata.RegularFileType:
   798:                         entry.Type = fuseutil.DT_File
   799:                 case metadata.ImplicitDirType, metadata.ExplicitDirType:
   800:                         entry.Type = fuseutil.DT_Directory
   801:                 }
   802:                 entries = append(entries, entry)
   803:         }
   804:         return
   805: }
   806:
(dlv) b 770
Breakpoint 10 set at 0x194753a for github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:770
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing [
        {bucketName: "", objectName: "file1"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0004dd320),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "file2"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0004dd350),
                ItemType: RegularFileType (2),}, 
        {bucketName: "", objectName: "dir1/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0004dd380),
                ItemType: ImplicitDirType (4),}, 
        {bucketName: "", objectName: "dir2/"}: *{
                FullName: (*"github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name")(0xc0004dd3b0),
                ItemType: ImplicitDirType (4),}, 
]
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects.func2() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:685 (hits goroutine(80):1 total:1) (PC: 0x1947b98)
   655:                 var gcsListing *gcs.Listing
   656:                 // Ask the bucket to list some objects.
   657:                 req := &gcs.ListObjectsRequest{
   658:                         Delimiter:                "/",
   659:                         IncludeTrailingDelimiter: true,
   660:                         Prefix:                   d.Name().GcsObjectName(),
   661:                         ContinuationToken:        tok,
   662:                         MaxResults:               MaxResultsForListObjectsCall,
   663:                         // Setting Projection param to noAcl since fetching owner and acls are not
   664:                         // required.
   665:                         ProjectionVal:            gcs.NoAcl,
   666:                         IncludeFoldersAsPrefixes: d.enableManagedFoldersListing,
   667:                 }
   668:
   669:                 gcsListing, err = d.bucket.ListObjects(ctx, req)
   670:                 if err != nil {
   671:                         err = fmt.Errorf("ListObjects: %w", err)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
=> 685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(177):1 total:2) (PC: 0x1972ef6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) c
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(118):1 total:3) (PC: 0x1972ef6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs.(*fileSystem).ReadDir() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/fs.go:2148 (hits goroutine(179):1 total:4) (PC: 0x1972ef6)
  2118:         if err := fs.invalidateChildFileCacheIfExist(parent, fileName.GcsObjectName()); err != nil {
  2119:                 return fmt.Errorf("Unlink: while invalidating cache for delete file: %w", err)
  2120:         }
  2121:
  2122:         return
  2123: }
  2124:
  2125: // LOCKS_EXCLUDED(fs.mu)
  2126: func (fs *fileSystem) OpenDir(
  2127:         ctx context.Context,
  2128:         op *fuseops.OpenDirOp) (err error) {
  2129:         fs.mu.Lock()
  2130:         defer fs.mu.Unlock()
  2131:
  2132:         // Make sure the inode still exists and is a directory. If not, something has
  2133:         // screwed up because the VFS layer shouldn't have let us forget the inode
  2134:         // before opening it.
  2135:         in := fs.dirInodeOrDie(op.Inode)
  2136:
  2137:         // Allocate a handle.
  2138:         handleID := fs.nextHandleID
  2139:         fs.nextHandleID++
  2140:
  2141:         fs.handles[handleID] = handle.NewDirHandle(in, fs.implicitDirs)
  2142:         op.Handle = handleID
  2143:
  2144:         return
  2145: }
  2146:
  2147: // LOCKS_EXCLUDED(fs.mu)
=>2148: func (fs *fileSystem) ReadDir(
  2149:         ctx context.Context,
  2150:         op *fuseops.ReadDirOp) (err error) {
  2151:         if fs.mountConfig.FileSystemConfig.IgnoreInterrupts {
  2152:                 // When ignore interrupts config is set, we are creating a new context not
  2153:                 // cancellable by parent context.
  2154:                 var cancel context.CancelFunc
  2155:                 ctx, cancel = util.IsolateContextFromParentContext(ctx)
  2156:                 defer cancel()
  2157:         }
  2158:         // Find the handle.
  2159:         fs.mu.Lock()
  2160:         dh := fs.handles[op.Handle].(*handle.DirHandle)
  2161:         in := fs.dirInodeOrDie(op.Inode)
  2162:         // Fetch local file entries beforehand and pass it to directory handle as
  2163:         // we need fs lock to fetch local file entries.
  2164:         localFileEntries := in.LocalFileEntries(fs.localFileInodes)
  2165:         fs.mu.Unlock()
  2166:
  2167:         dh.Mu.Lock()
  2168:         defer dh.Mu.Unlock()
  2169:         // Serve the request.
  2170:         if err := dh.ReadDir(ctx, op, localFileEntries); err != nil {
  2171:                 return err
  2172:         }
  2173:
  2174:         return
  2175: }
  2176:
  2177: // LOCKS_EXCLUDED(fs.mu)
  2178: func (fs *fileSystem) ReleaseDirHandle(
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:702 (hits goroutine(179):1 total:1) (PC: 0x194685e)
   672:                         return
   673:                 }
   674:
   675:                 logger.Debugf("GCS ListObjects output: ")
   676:                 PrintGcsListing(gcsListing, func(s string) {
   677:                         logger.Debugf("ListObjects: " + s)
   678:                 })
   679:
   680:                 // This probably needs to be moved out of the
   681:                 // if !d.hasObjectsListBeenRead.Load() check.
   682:                 cores = make(map[Name]*MinCoreForListing)
   683:                 defer func() {
   684:                         now := d.cacheClock.Now()
   685:                         for fullName, c := range cores {
   686:                                 d.cache.Insert(now, path.Base(fullName.LocalName()), c.Type())
   687:                         }
   688:                 }()
   689:
   690:                 listing = GcsListingToMinGcListing(gcsListing)
   691:
   692:                 logger.Debugf("Internal ListObjects MinGcsListing: ")
   693:                 PrintMinGcsListing(listing, func(s string) {
   694:                         logger.Debugf("ListObjects: " + s)
   695:                 })
   696:
   697:                 d.hasObjectsListBeenRead.Store(true)
   698:         } else {
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
=> 702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:729 (hits goroutine(179):1 total:3) (PC: 0x1946f0c)
   699:                 listing = &(MinGcsListing{})
   700:
   701:                 i := 0                   // purely for debugging.. remove later!
   702:                 index := d.cache.Index() // entire map for type-cache entries
   703:                 for name, objtype := range index {
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
=> 729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:734 (PC: 0x1946f42)
   704:                         logger.Debugf("typecache-items[%d]: name=%s objtype=%v\n", i, name, objtype)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
=> 734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:735 (PC: 0x1946f85)
   705:                         switch objtype {
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
=> 735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
(dlv) p nameBase
"dir2"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:736 (PC: 0x1946fe7)
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
=> 736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
   766:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) p o
("*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing")(0xc000b34a20)
*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinObjectForListing {Name: "dir2/", Type: ImplicitDirType (4)}
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:738 (PC: 0x1946ffb)
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
=> 738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
   766:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   767:                         continue
   768:                 }
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:736 (PC: 0x1947054)
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
=> 736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
   766:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:740 (PC: 0x194705e)
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
=> 740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
   766:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   767:                         continue
   768:                 }
   769:
   770:                 implicitDir := &MinCoreForListing{
(dlv) 
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:736 (PC: 0x1947070)
   706:                         case metadata.NonexistentType:
   707:                         case metadata.UnknownType:
   708:                                 logger.Warnf("Entry of UnknownType in type-cache: %s", name)
   709:                         case metadata.ImplicitDirType:
   710:                                 fallthrough
   711:                         case metadata.ExplicitDirType:
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
=> 736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
   742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
   766:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
(dlv) p nameBase
"dir2"
(dlv) n
> github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.(*dirInode).readObjects() /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/internal/fs/inode/dir.go:742 (PC: 0x1947080)
   712:                                 if len(name) != 0 {
   713:                                         name += "/"
   714:                                 }
   715:                                 fallthrough
   716:                         default:
   717:                                 listing.Objects = append(listing.Objects, &MinObjectForListing{Name: name, Type: objtype})
   718:                         }
   719:                         i++
   720:                 }
   721:         }
   722:
   723:         for _, o := range listing.Objects {
   724:                 // Skip empty results or the directory object backing this inode.
   725:                 if o.Name == d.Name().GcsObjectName() || o.Name == "" {
   726:                         continue
   727:                 }
   728:
   729:                 nameBase := path.Base(o.Name) // ie. "bar" from "foo/bar/" or "foo/bar"
   730:
   731:                 // Given the alphabetical order of the objects, if a file "foo" and
   732:                 // directory "foo/" coexist, the directory would eventually occupy
   733:                 // the value of records["foo"].
   734:                 if strings.HasSuffix(o.Name, "/") {
   735:                         dirName := NewDirName(d.Name(), nameBase)
   736:                         explicitDir := &MinCoreForListing{
   737:                                 // Bucket:    d.Bucket(),
   738:                                 FullName: dirName,
   739:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   740:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, dirName),
   741:                         }
=> 742:                         cores[dirName] = explicitDir
   743:                 } else {
   744:                         fileName := NewFileName(d.Name(), nameBase)
   745:                         file := &MinCoreForListing{
   746:                                 // Bucket:    d.Bucket(),
   747:                                 FullName: fileName,
   748:                                 // MinObject: storageutil.ConvertObjToMinObject(o),
   749:                                 ItemType: o.Type, //TypeFromMinCore(storageutil.ConvertObjToMinObject(o), false, fileName),
   750:                         }
   751:                         cores[fileName] = file
   752:                 }
   753:         }
   754:
   755:         // Return an appropriate continuation token, if any.
   756:         newTok = listing.ContinuationToken
   757:
   758:         if !d.implicitDirs {
   759:                 return
   760:         }
   761:
   762:         // Add implicit directories into the result.
   763:         for _, p := range listing.CollapsedRuns {
   764:                 pathBase := path.Base(p)
   765:                 dirName := NewDirName(d.Name(), pathBase)
   766:                 if c, ok := cores[dirName]; ok && c.Type() == metadata.ExplicitDirType {
   767:                         continue
   768:                 }
   769:
   770:                 implicitDir := &MinCoreForListing{
   771:                         FullName: dirName,
   772:                         ItemType: TypeFromMinCore(nil, false, dirName),
(dlv) p dirNane
Command failed: could not find symbol value for dirNane
(dlv) p dirName
github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name {bucketName: "", objectName: "dir2/"}
(dlv) p cores
map[github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.Name]*github.com/googlecloudplatform/gcsfuse/v2/internal/fs/inode.MinCoreForListing nil
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ^C
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) c
{"timestamp":{"seconds":1715323987,"nanos":541179156},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
received SIGINT, stopping process (will not forward signal)
> runtime.futex() /usr/lib/google-golang/src/runtime/sys_linux_amd64.s:559 (PC: 0x483b03)
Warning: debugging optimized function
   554:         MOVQ    ts+16(FP), R10
   555:         MOVQ    addr2+24(FP), R8
   556:         MOVL    val3+32(FP), R9
   557:         MOVL    $SYS_futex, AX
   558:         SYSCALL
=> 559:         MOVL    AX, ret+40(FP)
   560:         RET
   561:
   562: // int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
   563: TEXT runtimeclone(SB),NOSPLIT|NOFRAME,$0
   564:         MOVL    flags+0(FP), DI
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
WARNING: undefined behavior - Go version go0.0 is too old for this version of Delve (minimum supported version 1.19)
Type 'help' for list of commands.
(dlv) c
{"timestamp":{"seconds":1715324086,"nanos":130085982},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
received SIGINT, stopping process (will not forward signal)
> runtime.futex() /usr/lib/google-golang/src/runtime/sys_linux_amd64.s:559 (PC: 0x483b03)
Warning: debugging optimized function
   554:         MOVQ    ts+16(FP), R10
   555:         MOVQ    addr2+24(FP), R8
   556:         MOVL    val3+32(FP), R9
   557:         MOVL    $SYS_futex, AX
   558:         SYSCALL
=> 559:         MOVL    AX, ret+40(FP)
   560:         RET
   561:
   562: // int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
   563: TEXT runtimeclone(SB),NOSPLIT|NOFRAME,$0
   564:         MOVL    flags+0(FP), DI
(dlv) q
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1 debug
fusermount: missing mountpoint argument
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ '[' 2 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 2 -gt 1 ']'
+ debug=1
+ '[' 1 -ne 0 ']'
+ echo 'Debugging ...'
Debugging ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 1 = 0 ']'
+ dlv --check-go-version=false debug /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse/. -- --foreground --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
^C
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1      
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715324882,"nanos":293570633},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 07:08:02.294558" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 07:08:02.633591" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715325223,"nanos":873037548},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 07:13:43.873401" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 07:13:44.181086" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-empty-bucket
+ filename=hello.txt
+ gcspath=gs://gargnitin-empty-bucket//hello.txt
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs --only-dir list-through-metadata-cache-expt -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715325806,"nanos":777299416},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 07:23:26.778047" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 07:23:27.092491" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi creationSituation.sh 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=1000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs --only-dir 1000_objects -o ro'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs --only-dir 1000_objects -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715326331,"nanos":62457791},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 07:32:11.062860" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 07:32:11.377278" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ echo $bucket
gargnitin-empty-bucket
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi creationSituation.sh          
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=1000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo 'export bucket=${bucket}'
export bucket=${bucket}
+ echo 'export onlydir=${onlydir}'
export onlydir=${onlydir}
+ echo 'export mountpath=${mountpath}'
export mountpath=${mountpath}
+ echo 'export logfile=${logfile}'
export logfile=${logfile}
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 1000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 1000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 1000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715326608,"nanos":500815216},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 07:36:48.501187" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 07:36:48.832145" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi creationSituation.sh          
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=1000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=1000_objects
onlydir=1000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 1000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 1000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 1000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715326653,"nanos":95826086},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 07:37:33.096185" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 07:37:33.404753" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ lsfusemnts 
gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2 not found in /etc/mtab
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ lsfusemnts                       
gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=1000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=1000_objects
onlydir=1000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 1000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 1000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 1000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715326736,"nanos":940793852},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 07:38:56.942862" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 07:38:57.261980" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ bucket=gargnitin-memory-testing-bucket-20230809
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ onlydir=1000_objects
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ export | grep 'mountpath\|logfile\|bucket\|onlydir'
declare -x bucket="gargnitin-memory-testing-bucket-20230809"
declare -x gcsdirpath="gargnitin-empty-bucket/list-through-metadata-cache-expt"
declare -x logfile="/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log"
declare -x mountpath="/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount"
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1                                                                                                                                    
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715331589,"nanos":779646210},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 08:59:49.780383" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 08:59:50.086259" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715331610,"nanos":716482467},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:00:10.716846" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 09:00:11.033020" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz ; ./creationSituation.sh 1
fusermount: missing mountpoint argument
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715331632,"nanos":382524767},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:00:32.382952" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 09:00:32.674014" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz
fusermount: missing mountpoint argument
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ fusermount -uz $mountpath 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ alias unload='fusermount -uz $mountpath'                                                                                                                                          
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload; ./creationSituation.sh 1 
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715333188,"nanos":141747401},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:26:28.142057" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 09:26:28.463286" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload; ./creationSituation.sh 1
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'fix branch (1) ...'
fix branch (1) ...
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715333240,"nanos":673761519},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:27:20.674255" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 09:27:20.982057" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 1 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 1 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 3
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 1 -gt 0 ']'
+ '[' 3 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 0
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 1 -gt 0 ']'
+ '[' 0 = 2 ']'
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 1 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 bucket 
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' bucket = debug -o bucket = Debug ']'
+ '[' 2 -gt 2 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 bucket
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' bucket = debug -o bucket = Debug ']'
+ '[' 2 -gt 2 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 run   
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' run = debug -o run = Debug ']'
+ '[' 2 -gt 2 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 run
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 2 -gt 2 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 r  
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' r = debug -o r = Debug -o r = DEBUG ']'
+ '[' r = run -o r = Run -o r = RUN ']'
+ echo 'Unknown 2nd argument: r, should be debug or run'
Unknown 2nd argument: r, should be debug or run
+ '[' 2 -gt 2 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 r
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' r = debug -o r = Debug -o r = DEBUG ']'
+ '[' r = run -o r = Run -o r = RUN ']'
+ echo 'Unknown 2nd argument: r, should be debug or run'
Unknown 2nd argument: r, should be debug or run
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 DEBUG
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' DEBUG = debug -o DEBUG = Debug -o DEBUG = DEBUG ']'
+ debug=1
+ '[' 2 -gt 2 ']'
+ '[' 1 -ne 0 ']'
+ echo 'Debugging in Delve ...'
Debugging in Delve ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 3      
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 1 -gt 0 ']'
+ '[' 3 = 2 ']'
+ '[' 3 = 1 ']'
+ echo 'Unknown 1st argument: 3, should be 1 (for fix-branch) or 2 (for master-branch)'
Unknown 1st argument: 3, should be 1 (for fix-branch) or 2 (for master-branch)
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 3 Debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 3 = 2 ']'
+ '[' 3 = 1 ']'
+ echo 'Unknown 1st argument: 3, should be 1 (for fix-branch) or 2 (for master-branch)'
Unknown 1st argument: 3, should be 1 (for fix-branch) or 2 (for master-branch)
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 Debug  
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' Debug = debug -o Debug = Debug -o Debug = DEBUG ']'
+ debug=1
+ '[' 2 -gt 2 ']'
+ '[' 1 -ne 0 ']'
+ echo 'Debugging in Delve ...'
Debugging in Delve ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 De   
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' De = debug -o De = Debug -o De = DEBUG ']'
+ '[' De = run -o De = Run -o De = RUN ']'
+ echo 'Unknown 2nd argument: De, should be debug or run'
Unknown 2nd argument: De, should be debug or run
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 Debug
+ echo Number of args: 2
Number of args: 2
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 2 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 2 -gt 1 ']'
+ '[' Debug = debug -o Debug = Debug -o Debug = DEBUG ']'
+ debug=1
+ '[' 2 -gt 2 ']'
+ '[' 1 -ne 0 ']'
+ echo 'Debugging in Delve ...'
Debugging in Delve ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 Debug bucket onlydir
+ echo Number of args: 4
Number of args: 4
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 4 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 4 -gt 1 ']'
+ '[' Debug = debug -o Debug = Debug -o Debug = DEBUG ']'
+ debug=1
+ '[' 4 -gt 2 ']'
+ bucket=bucket
+ '[' 4 -gt 3 ']'
+ onlydir=onlydir
+ '[' 1 -ne 0 ']'
+ echo 'Debugging in Delve ...'
Debugging in Delve ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: bucket, onlydir: onlydir'
bucket picked: bucket, onlydir: onlydir
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 Debug buc-ket only-dir                                                                                                                                    
+ echo Number of args: 4
Number of args: 4
+ debug=0
+ run=1
+ near_bucket=gargnitin-bucket-asia-se1-1
+ far_bucket=gargnitin-memory-testing-bucket-20230809
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ master_branch=master
+ '[' 4 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 4 -gt 1 ']'
+ '[' Debug = debug -o Debug = Debug -o Debug = DEBUG ']'
+ debug=1
+ '[' 4 -gt 2 ']'
+ bucket=buc-ket
+ '[' 4 -gt 3 ']'
+ onlydir=only-dir
+ '[' 1 -ne 0 ']'
+ echo 'Debugging in Delve ...'
Debugging in Delve ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: buc-ket, onlydir: only-dir'
bucket picked: buc-ket, onlydir: only-dir
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload; ./creationSituation.sh 1 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 1
Number of args: 1
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 1 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 1 -gt 1 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715334461,"nanos":501961124},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:47:41.502405" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 09:47:41.834103" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload; ./creationSituation.sh 1 gargnitin-memory-testing-bucket-20230809 10000_objects
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' gargnitin-memory-testing-bucket-20230809 = debug -o gargnitin-memory-testing-bucket-20230809 = Debug -o gargnitin-memory-testing-bucket-20230809 = DEBUG ']'
+ '[' gargnitin-memory-testing-bucket-20230809 = run -o gargnitin-memory-testing-bucket-20230809 = Run -o gargnitin-memory-testing-bucket-20230809 = RUN ']'
+ echo 'Unknown 2nd argument: gargnitin-memory-testing-bucket-20230809, should be debug or run'
Unknown 2nd argument: gargnitin-memory-testing-bucket-20230809, should be debug or run
+ exit 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload; ./creationSituation.sh 1 run gargnitin-memory-testing-bucket-20230809 10000_objects                                                                                        
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 4
Number of args: 4
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 4 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 4 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 4 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 4 -gt 3 ']'
+ onlydir=10000_objects
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715334494,"nanos":103778328},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:48:14.105641" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 09:48:14.412976" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload; ./creationSituation.sh 1 run gargnitin-memory-testing-bucket-20230809 10000_objects
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 4
Number of args: 4
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 4 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 4 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 4 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 4 -gt 3 ']'
+ onlydir=10000_objects
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715334520,"nanos":104394620},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:48:40.106102" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 09:48:40.417194" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload; ./creationSituation.sh 1 run gargnitin-memory-testing-bucket-20230809 100000_objects
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 4
Number of args: 4
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 4 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 4 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 4 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 4 -gt 3 ']'
+ onlydir=100000_objects
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 100000_objects'
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 100000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=100000_objects
onlydir=100000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 100000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 100000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro --only-dir 100000_objects gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715334539,"nanos":441983908},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:48:59.442407" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 09:48:59.756931" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ declare -r near_bucket=gargnitin-bucket-asia-se1-1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ onlydir=10000_objects
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 10000_objects'
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 10000_objects
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=10000_objects
onlydir=10000_objects
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z 10000_objects ']'
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mkdir: created directory '/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount'
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro --only-dir 10000_objects gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715334730,"nanos":735114576},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:52:10.735565" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 09:52:10.893223" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715334805,"nanos":44828459},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:53:25.045512" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 09:53:25.193409" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715335079,"nanos":761816389},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 09:57:59.762187" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 09:57:59.975009" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715335282,"nanos":428534438},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 10:01:22.428940" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 10:01:22.590112" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-l
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715335378,"nanos":227914471},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 10:02:58.229823" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 10:02:58.385939" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715335408,"nanos":62604203},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 10:03:28.062994" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 10:03:28.209138" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715335654,"nanos":984006325},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 10:07:34.985009" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 10:07:35.152192" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ unload^C                                  
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715335772,"nanos":772961318},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 10:09:32.773447" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 10:09:32.923108" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $far_bucket  
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715335928,"nanos":153528956},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 10:12:08.153968" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 10:12:08.523719" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 run $far_bucket                                               
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2 not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
directory ../../../src2/googlecloudplatform/gcsfuse is contained in a module that is not one of the workspace modules listed in go.work. You can add the module to the workspace using:
        go work use ../../../src2/googlecloudplatform/gcsfuse
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../master-branch/
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ ./creationSituation.sh 2 run $far_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2 not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
{"timestamp":{"seconds":1715336204,"nanos":165529633},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch/config.yml]\n"}
time="10/05/2024 10:16:44.165956" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2\n"
time="10/05/2024 10:16:44.520480" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ ./creationSituation.sh 2 run $near_bucket                                           
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
mkdir: created directory '/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2'
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2 not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
{"timestamp":{"seconds":1715336527,"nanos":62943741},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch/config.yml]\n"}
time="10/05/2024 10:22:07.065252" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2\n"
time="10/05/2024 10:22:07.219832" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ cd ../fix-branch/       
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 2 run $near_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
directory ../../../src2/googlecloudplatform/gcsfuse is contained in a module that is not one of the workspace modules listed in go.work. You can add the module to the workspace using:
        go work use ../../../src2/googlecloudplatform/gcsfuse
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket                                                        
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715337421,"nanos":70821021},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 10:37:01.071264" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/   
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $far_bucket                                                         
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715344877,"nanos":379027454},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 12:41:17.379339" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 12:41:17.694566" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $far_bucket 
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715344889,"nanos":444670717},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 12:41:29.445028" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 12:41:29.745996" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../master-branch/
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ ./creationSituation.sh 2 run $far_bucket                                                      
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-2.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2
{"timestamp":{"seconds":1715345357,"nanos":552364046},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch/config.yml]\n"}
time="10/05/2024 12:49:17.553487" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount2\n"
time="10/05/2024 12:49:17.866919" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ ./creationSituation.sh 2 run $near_bucket                                                     
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2 not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-2.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2
{"timestamp":{"seconds":1715346462,"nanos":243888448},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch/config.yml]\n"}
time="10/05/2024 01:07:42.244344" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount2\n"
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ cd ../fix-branch/
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run $near_bucket                                                        
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715346837,"nanos":131273808},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 01:13:57.131847" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
time="10/05/2024 01:13:57.286087" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cat config.yml 
metadata-cache:
  stat-cache-max-size-mb: -1
  type-cache-max-size-mb: -1
  ttl-secs: -1
logging:
  format: text
  severity: warning
  log-rotate:
      backup-file-count: 0
      max-file-size-mb: 1000000
      compress: false
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run gargnitin-empty-bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-empty-bucket
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-empty-bucket, onlydir: '
bucket picked: gargnitin-empty-bucket, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-empty-bucket
bucket=gargnitin-empty-bucket
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715349620,"nanos":640287867},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:00:20.640753" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 02:00:20.945006" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run gargnitin-empty-bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-empty-bucket
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-empty-bucket, onlydir: '
bucket picked: gargnitin-empty-bucket, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-empty-bucket
bucket=gargnitin-empty-bucket
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715349683,"nanos":709688582},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:01:23.710366" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 02:01:24.033434" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ ./creationSituation.sh 1 run gargnitin-empty-bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-empty-bucket
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-empty-bucket, onlydir: '
bucket picked: gargnitin-empty-bucket, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-empty-bucket
bucket=gargnitin-empty-bucket
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715349737,"nanos":237266943},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:02:17.237725" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../master-branch/
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ ./creationSituation.sh 2 run gargnitin-empty-bucket                                                                                                                                
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-empty-bucket
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-empty-bucket, onlydir: '
bucket picked: gargnitin-empty-bucket, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=gargnitin-empty-bucket
bucket=gargnitin-empty-bucket
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2 not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log --log-format=text --implicit-dirs -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
{"timestamp":{"seconds":1715349961,"nanos":660841320},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch/config.yml]\n"}
time="10/05/2024 02:06:01.661178" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2\n"
time="10/05/2024 02:06:02.761041" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ cd ../master-branch/ && ./creationSituation.sh 2 run gargnitin-empty-bucket                                                                                                         
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-empty-bucket
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: gargnitin-empty-bucket, onlydir: '
bucket picked: gargnitin-empty-bucket, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=gargnitin-empty-bucket
bucket=gargnitin-empty-bucket
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-2.log --log-format=text --implicit-dirs -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2
{"timestamp":{"seconds":1715350213,"nanos":42481527},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch/config.yml]\n"}
time="10/05/2024 02:10:13.042846" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount2\n"
time="10/05/2024 02:10:13.355904" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run gargnitin-empty-bucket                                                                                                            
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-empty-bucket
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-empty-bucket, onlydir: '
bucket picked: gargnitin-empty-bucket, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-empty-bucket
bucket=gargnitin-empty-bucket
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket.log --log-format=text --implicit-dirs -o ro gargnitin-empty-bucket /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount
{"timestamp":{"seconds":1715350224,"nanos":160324154},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:10:24.160761" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-empty-bucket-mount\n"
time="10/05/2024 02:10:24.474210" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ branch=gargnitin-empty-bucket-mountgargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket               
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715350347,"nanos":805318694},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:12:27.806244" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 02:12:28.127709" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ branch=princer-read-cache-load-test 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715350429,"nanos":646471314},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:13:49.647393" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 02:13:49.957196" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ branch=princer-read-cache-load-test
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: '
bucket picked: gargnitin-memory-testing-bucket-20230809, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-memory-testing-bucket-20230809
bucket=gargnitin-memory-testing-bucket-20230809
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809.log --log-format=text --implicit-dirs -o ro gargnitin-memory-testing-bucket-20230809 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount
{"timestamp":{"seconds":1715350447,"nanos":787405241},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/
google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:14:07.787790" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-memory-testing-bucket-20230809-mount\n"
time="10/05/2024 02:14:08.084915" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ echo $bucket                       
gargnitin-memory-testing-bucket-20230809
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ bucket=princer-read-cache-load-testgargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ echo $bucket                       
princer-read-cache-load-test
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=princer-read-cache-load-test
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: princer-read-cache-load-test, onlydir: '
bucket picked: princer-read-cache-load-test, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=princer-read-cache-load-test
bucket=princer-read-cache-load-test
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
mkdir: created directory '/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount'
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount not found i
n /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro princer-read-cache-load-test /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
{"timestamp":{"seconds":1715350481,"nanos":197426484},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:14:41.197776" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount\n"
time="10/05/2024 02:14:42.487257" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=princer-read-cache-load-test
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: princer-read-cache-load-test, onlydir: '
bucket picked: princer-read-cache-load-test, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=princer-read-cache-load-test
bucket=princer-read-cache-load-test
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro princer-read-cache-load-test /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
{"timestamp":{"seconds":1715350581,"nanos":984773683},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:16:21.986651" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount\n"
time="10/05/2024 02:16:23.440721" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml                      
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml                      
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=princer-read-cache-load-test
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: princer-read-cache-load-test, onlydir: '
bucket picked: princer-read-cache-load-test, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=princer-read-cache-load-test
bucket=princer-read-cache-load-test
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro princer-read-cache-load-test /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
{"timestamp":{"seconds":1715350680,"nanos":404254393},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 02:18:00.404692" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount\n"
time="10/05/2024 02:18:01.861760" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../master-branch/ && ./creationSituation.sh 2 run $bucket                                                                                                                           
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 2 = 2 ']'
+ run=2
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=princer-read-cache-load-test
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 2 -gt 1 ']'
+ echo 'Code picked: master ...'
Code picked: master ...
+ echo 'bucket picked: princer-read-cache-load-test, onlydir: '
bucket picked: princer-read-cache-load-test, onlydir: 
+ '[' 2 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-2.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse
+ echo bucket=princer-read-cache-load-test
bucket=princer-read-cache-load-test
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-2.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-2.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-2.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2
mkdir: created directory '/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2'
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2 not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src2/googlecloudplatform/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-2.log --log-format=text --implicit-dirs -o ro princer-read-cache-load-test /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2
{"timestamp":{"seconds":1715351725,"nanos":357113703},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch/config.yml]\n"}
time="10/05/2024 02:35:25.358038" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount2\n"
time="10/05/2024 02:35:26.860094" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/master-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket                                                                                                                        
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=princer-read-cache-load-test
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: princer-read-cache-load-test, onlydir: '
bucket picked: princer-read-cache-load-test, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=princer-read-cache-load-test
bucket=princer-read-cache-load-test
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro princer-read-cache-load-test /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
{"timestamp":{"seconds":1715354240,"nanos":724528518},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 03:17:20.724844" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount\n"
time="10/05/2024 03:17:21.059490" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=princer-read-cache-load-test
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: princer-read-cache-load-test, onlydir: '
bucket picked: princer-read-cache-load-test, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=princer-read-cache-load-test
bucket=princer-read-cache-load-test
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro princer-read-cache-load-test /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
{"timestamp":{"seconds":1715354350,"nanos":744914234},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
parsing config file failed: error parsing config file: log severity should be one of [trace, debug, info, warning, error, off]
exit status 1
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml                      
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=princer-read-cache-load-test
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: princer-read-cache-load-test, onlydir: '
bucket picked: princer-read-cache-load-test, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=princer-read-cache-load-test
bucket=princer-read-cache-load-test
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
fusermount: entry for /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount not found in /etc/mtab
+ true
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro princer-read-cache-load-test /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
{"timestamp":{"seconds":1715354376,"nanos":566448499},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 03:19:36.566806" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount\n"
time="10/05/2024 03:19:38.121737" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=princer-read-cache-load-test
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: princer-read-cache-load-test, onlydir: '
bucket picked: princer-read-cache-load-test, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=princer-read-cache-load-test
bucket=princer-read-cache-load-test
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test.log --log-format=text --implicit-dirs -o ro princer-read-cache-load-test /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount
{"timestamp":{"seconds":1715354564,"nanos":949544387},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 03:22:44.950411" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/princer-read-cache-load-test-mount\n"
time="10/05/2024 03:22:46.431394" severity=INFO message="File system has been successfully mounted."
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ vi config.yml 
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ bucket=$near_bucket        
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ cd ../fix-branch/ && ./creationSituation.sh 1 run $bucket
+ declare -r near_bucket=gargnitin-bucket-asia-se1-1
+ declare -r far_bucket=gargnitin-memory-testing-bucket-20230809
+ declare -r fix_branch=gargnitin/list-thru-metadata-cache-expt/v1
+ declare -r master_branch=master
+ echo Number of args: 3
Number of args: 3
+ debug=0
+ run=1
+ bucket=gargnitin-memory-testing-bucket-20230809
+ '[' 3 -gt 0 ']'
+ '[' 1 = 2 ']'
+ '[' 1 = 1 ']'
+ run=1
+ '[' 3 -gt 1 ']'
+ '[' run = debug -o run = Debug -o run = DEBUG ']'
+ '[' run = run -o run = Run -o run = RUN ']'
+ debug=0
+ '[' 3 -gt 2 ']'
+ bucket=gargnitin-bucket-asia-se1-1
+ '[' 3 -gt 3 ']'
+ '[' 0 -ne 0 ']'
+ echo 'Running ...'
Running ...
+ '[' 1 -gt 1 ']'
+ echo 'Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...'
Code picked: gargnitin/list-thru-metadata-cache-expt/v1 ...
+ echo 'bucket picked: gargnitin-bucket-asia-se1-1, onlydir: '
bucket picked: gargnitin-bucket-asia-se1-1, onlydir: 
+ '[' 1 -gt 1 ']'
+ mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_src_dir=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse
+ echo bucket=gargnitin-bucket-asia-se1-1
bucket=gargnitin-bucket-asia-se1-1
+ echo onlydir=
onlydir=
+ echo mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
mountpath=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
logfile=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log
+ gcsfuse_args='--config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro'
+ '[' '!' -z '' ']'
+ mkdir -pv /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ echo ''
+ fusermount -uz /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
+ '[' 0 = 0 ']'
+ go run /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/src/gcsfuse --config-file=config.yml --log-file=/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1.log --log-format=text --implicit-dirs -o ro gargnitin-bucket-asia-se1-1 /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount
{"timestamp":{"seconds":1715369241,"nanos":175670889},"severity":"INFO","message":"Value of [config-file] resolved from [config.yml] to [/usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch/config.yml]\n"}
time="10/05/2024 07:27:21.176317" severity=INFO message="Start gcsfuse/unknown (Go version go1.23-20240419-RC02 cl/626470163 +7f76c00fc5 X:fieldtrack,boringcrypto) for app \"\" using mount point: /usr/local/google/home/gargnitin/work/cloud/storage/client/gcsfuse/test_buckets/gargnitin-bucket-asia-se1-1-mount\n"
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509
gargnitin@gargnitin:~/work/cloud/storage/client/gcsfuse/tasks/20240509-list-thru-metadata-cache-expt/fix-branch$ 
